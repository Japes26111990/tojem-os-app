TOJEM Application - Full Codebase
Generated on: 06/24/2025 08:59:19


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\api\firebase.js
==================================================
import { initializeApp } from 'firebase/app';
import { getAuth } from 'firebase/auth';
import { getFirestore } from 'firebase/firestore';

// Your web app's Firebase configuration from the .env.local file
const firebaseConfig = {
  apiKey: import.meta.env.VITE_FIREBASE_API_KEY,
  authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,
  projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID,
  storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID,
  appId: import.meta.env.VITE_FIREBASE_APP_ID,
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);

// Initialize and export Firebase services
export const auth = getAuth(app);
export const db = getFirestore(app);

export default app;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\api\firestore.js
==================================================
import { db } from './firebase';
import { collection, getDocs, addDoc, deleteDoc, doc, serverTimestamp, onSnapshot, query, orderBy, updateDoc, where, getDoc, writeBatch, setDoc, runTransaction, increment, limit, startAfter } from 'firebase/firestore';

// --- DEPARTMENTS API ---
const departmentsCollection = collection(db, 'departments');
export const getDepartments = async () => {
  const snapshot = await getDocs(departmentsCollection);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};
export const addDepartment = (departmentName) => {
  return addDoc(departmentsCollection, { name: departmentName });
};
export const deleteDepartment = (departmentId) => {
  const departmentDoc = doc(db, 'departments', departmentId);
  return deleteDoc(departmentDoc);
};

// --- SKILLS API ---
const skillsCollection = collection(db, 'skills');
const skillHistoryCollection = collection(db, 'skillHistory');
export const getSkills = async () => {
  const snapshot = await getDocs(query(skillsCollection, orderBy('name')));
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};
export const addSkill = (skillName) => {
  return addDoc(skillsCollection, { name: skillName });
};
export const updateSkill = (skillId, updatedData) => {
  const skillDoc = doc(db, 'skills', skillId);
  return updateDoc(skillDoc, updatedData);
};
export const deleteSkill = (skillId) => {
  const skillDoc = doc(db, 'skills', skillId);
  return deleteDoc(skillDoc);
};
export const getSkillHistoryForEmployee = async (employeeId) => {
  const q = query(skillHistoryCollection, where('employeeId', '==', employeeId));
  const snapshot = await getDocs(q);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};

// --- TOOLS API ---
const toolsCollection = collection(db, 'tools');
export const getTools = async () => {
  const snapshot = await getDocs(toolsCollection);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};
export const addTool = (toolName) => {
  return addDoc(toolsCollection, { name: toolName });
};
export const deleteTool = (toolId) => {
  const toolDoc = doc(db, 'tools', toolId);
  return deleteDoc(toolDoc);
};

// --- TOOL ACCESSORIES API ---
const toolAccessoriesCollection = collection(db, 'toolAccessories');
export const getToolAccessories = async () => {
  const snapshot = await getDocs(toolAccessoriesCollection);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};
export const addToolAccessory = (accessoryData) => {
  return addDoc(toolAccessoriesCollection, accessoryData);
};
export const deleteToolAccessory = (accessoryId) => {
  const accessoryDoc = doc(db, 'toolAccessories', accessoryId);
  return deleteDoc(accessoryDoc);
};

// --- EMPLOYEES API ---
const employeesCollection = collection(db, 'employees');
export const getEmployees = async () => {
  const snapshot = await getDocs(employeesCollection);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};
export const addEmployee = (employeeData) => {
  return addDoc(employeesCollection, employeeData);
};
export const deleteEmployee = (employeeId) => {
  const employeeDoc = doc(db, 'employees', employeeId);
  return deleteDoc(employeeDoc);
};
export const getEmployeeSkills = async (employeeId) => {
  const employeeDocRef = doc(db, 'employees', employeeId);
  const employeeDoc = await getDoc(employeeDocRef);
  if (employeeDoc.exists()) {
    return employeeDoc.data().skills || {};
  }
  return {};
};
export const updateEmployeeSkillsAndLogHistory = async (employee, skillsData, allSkills) => {
  const employeeDocRef = doc(db, 'employees', employee.id);
  const batch = writeBatch(db);
  batch.update(employeeDocRef, { skills: skillsData });
  const allSkillsMap = new Map(allSkills.map(s => [s.id, s.name]));
  for (const skillId in skillsData) {
    const proficiency = skillsData[skillId];
    const newHistoryRef = doc(skillHistoryCollection);
    const historyRecord = {
      employeeId: employee.id,
      employeeName: employee.name,
      skillId: skillId,
      skillName: allSkillsMap.get(skillId) || 'Unknown Skill',
      proficiency: proficiency,
      assessmentDate: serverTimestamp()
    };
    batch.set(newHistoryRef, historyRecord);
  }
  return batch.commit();
};

// --- SUPPLIERS API ---
const suppliersCollection = collection(db, 'suppliers');
export const getSuppliers = async () => {
  const snapshot = await getDocs(suppliersCollection);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};
export const addSupplier = (supplierData) => {
  return addDoc(suppliersCollection, supplierData);
};
export const deleteSupplier = (supplierId) => {
  const supplierDoc = doc(db, 'suppliers', supplierId);
  return deleteDoc(supplierDoc);
};
export const updateSupplier = (supplierId, updatedData) => {
  const supplierDoc = doc(db, 'suppliers', supplierId);
  return updateDoc(supplierDoc, updatedData);
};

// --- INVENTORY APIs ---
const workshopSuppliesCollection = collection(db, 'workshopSupplies');
const componentsCollection = collection(db, 'components');
const rawMaterialsCollection = collection(db, 'rawMaterials');
export const getWorkshopSupplies = async () => {
  const snapshot = await getDocs(workshopSuppliesCollection);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};
export const addWorkshopSupply = (supplyData) => {
  return addDoc(workshopSuppliesCollection, supplyData);
};
export const deleteWorkshopSupply = (supplyId) => {
  const supplyDoc = doc(db, 'workshopSupplies', supplyId);
  return deleteDoc(supplyDoc);
};
export const updateWorkshopSupply = (supplyId, updatedData) => {
  const supplyDoc = doc(db, 'workshopSupplies', supplyId);
  return updateDoc(supplyDoc, updatedData);
};
export const getComponents = async () => {
  const snapshot = await getDocs(componentsCollection);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};
export const addComponent = (componentData) => {
  return addDoc(componentsCollection, componentData);
};
export const deleteComponent = (componentId) => {
  const componentDoc = doc(db, 'components', componentId);
  return deleteDoc(componentDoc);
};
export const updateComponent = (componentId, updatedData) => {
  const componentDoc = doc(db, 'components', componentId);
  return updateDoc(componentDoc, updatedData);
};
export const getRawMaterials = async () => {
  const snapshot = await getDocs(rawMaterialsCollection);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};
export const addRawMaterial = (materialData) => {
  return addDoc(rawMaterialsCollection, materialData);
};
export const deleteRawMaterial = (materialId) => {
  const materialDoc = doc(db, 'rawMaterials', materialId);
  return deleteDoc(materialDoc);
};
export const updateRawMaterial = (materialId, updatedData) => {
  const materialDoc = doc(db, 'rawMaterials', materialId);
  return updateDoc(materialDoc, updatedData);
};

// --- OVERHEADS API ---
const overheadsCategoriesCollection = collection(db, 'overheadsCategories');
export const getOverheadCategories = async () => {
  const snapshot = await getDocs(overheadsCategoriesCollection);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};
export const addOverheadCategory = (categoryData) => {
  return addDoc(overheadsCategoriesCollection, categoryData);
};
export const updateOverheadCategory = (categoryId, updatedData) => {
  const categoryDoc = doc(db, 'overheadsCategories', categoryId);
  return updateDoc(categoryDoc, updatedData);
};
export const deleteOverheadCategory = async (categoryId) => {
  const categoryDocRef = doc(db, 'overheadsCategories', categoryId);
  const expensesSnapshot = await getDocs(collection(categoryDocRef, 'expenses'));
  const batch = writeBatch(db);
  expensesSnapshot.docs.forEach(expDoc => {
    batch.delete(expDoc.ref);
  });
  batch.delete(categoryDocRef);
  return batch.commit();
};
export const getOverheadExpenses = async (categoryId) => {
  const expensesCollectionRef = collection(db, 'overheadsCategories', categoryId, 'expenses');
  const snapshot = await getDocs(expensesCollectionRef);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};
export const addOverheadExpense = (categoryId, expenseData) => {
  const expensesCollectionRef = collection(db, 'overheadsCategories', categoryId, 'expenses');
  return addDoc(expensesCollectionRef, expenseData);
};
export const updateOverheadExpense = (categoryId, expenseId, updatedData) => {
  const expenseDocRef = doc(db, 'overheadsCategories', categoryId, 'expenses', expenseId);
  return updateDoc(expenseDocRef, updatedData);
};
export const deleteOverheadExpense = (categoryId, expenseId) => {
  const expenseDocRef = doc(db, 'overheadsCategories', categoryId, 'expenses', expenseId);
  return deleteDoc(expenseDocRef);
};

// --- PURCHASE QUEUE API ---
const purchaseQueueCollection = collection(db, 'purchaseQueue');
export const getPurchaseQueue = async () => {
  const snapshot = await getDocs(purchaseQueueCollection);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};
export const addToPurchaseQueue = (itemData) => {
  return addDoc(purchaseQueueCollection, { ...itemData, status: 'pending', queuedAt: serverTimestamp() });
};
export const markItemsAsOrdered = async (supplier, itemsToOrder, orderQuantities) => {
  if (!itemsToOrder || itemsToOrder.length === 0) return;
  const batch = writeBatch(db);
  const orderDate = new Date();
  const etaDays = supplier.estimatedEtaDays || 0;
  const expectedArrivalDate = new Date();
  expectedArrivalDate.setDate(orderDate.getDate() + Number(etaDays));
  itemsToOrder.forEach(item => {
    const docRef = doc(db, 'purchaseQueue', item.id);
    const recommendedQty = Math.max(0, (item.standardStockLevel || 0) - (item.currentStock || 0));
    const orderQty = orderQuantities[item.id] || recommendedQty;
    batch.update(docRef, {
      status: 'ordered',
      orderDate: orderDate,
      expectedArrivalDate: expectedArrivalDate,
      orderedQty: Number(orderQty)
    });
  });
  return batch.commit();
};
export const receiveStockAndUpdateInventory = async (queuedItem, quantityReceived) => {
  if (!queuedItem || !quantityReceived || quantityReceived <= 0) {
    throw new Error("Invalid item or quantity received.");
  }
  const itemCategory = queuedItem.category;
  const inventoryItemId = queuedItem.itemId;
  let inventoryCollectionName;
  if (itemCategory === 'Component') inventoryCollectionName = 'components';
  else if (itemCategory === 'Raw Material') inventoryCollectionName = 'rawMaterials';
  else if (itemCategory === 'Workshop Supply') inventoryCollectionName = 'workshopSupplies';
  else throw new Error(`Unknown inventory category: ${itemCategory}`);
  const inventoryDocRef = doc(db, inventoryCollectionName, inventoryItemId);
  const purchaseQueueDocRef = doc(db, 'purchaseQueue', queuedItem.id);
  const batch = writeBatch(db);
  const inventoryDoc = await getDoc(inventoryDocRef);
  if (!inventoryDoc.exists()) throw new Error("Original inventory item not found.");
  const currentStock = inventoryDoc.data().currentStock || 0;
  const newStockLevel = Number(currentStock) + Number(quantityReceived);
  batch.update(inventoryDocRef, { currentStock: newStockLevel });
  batch.update(purchaseQueueDocRef, { status: 'completed' });
  return batch.commit();
};
export const requeueOrDeleteItem = async (queuedItem) => {
  const itemCategory = queuedItem.category.replace(' ', '');
  const inventoryCollectionName = `${itemCategory.charAt(0).toLowerCase() + itemCategory.slice(1)}s`;
  const inventoryDocRef = doc(db, inventoryCollectionName, queuedItem.itemId);
  const purchaseQueueDocRef = doc(db, 'purchaseQueue', queuedItem.id);
  const inventoryDoc = await getDoc(inventoryDocRef);
  if (!inventoryDoc.exists()) {
    return deleteDoc(purchaseQueueDocRef);
  }
  const itemData = inventoryDoc.data();
  if (itemData.currentStock < itemData.reorderLevel) {
    return updateDoc(purchaseQueueDocRef, { status: 'pending' });
  } else {
    return deleteDoc(purchaseQueueDocRef);
  }
};

// --- MASTER INVENTORY API ---
export const getAllInventoryItems = async () => {
  const [components, rawMaterials, workshopSupplies] = await Promise.all([
    getComponents(),
    getRawMaterials(),
    getWorkshopSupplies()
  ]);
  const allItems = [
    ...components.map(item => ({ ...item, category: 'Component' })),
    ...rawMaterials.map(item => ({ ...item, category: 'Raw Material' })),
    ...workshopSupplies.map(item => ({ ...item, category: 'Workshop Supply' })),
  ];
  return allItems;
};

// --- JOB STEP DETAILS API ---
const jobStepDetailsCollection = collection(db, 'jobStepDetails');
export const getJobStepDetails = async () => {
  const snapshot = await getDocs(jobStepDetailsCollection);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};
export const setJobStepDetail = (productId, departmentId, data) => {
  const recipeId = `${productId}_${departmentId}`;
  const docRef = doc(db, 'jobStepDetails', recipeId);
  return setDoc(docRef, { ...data, productId, departmentId });
};


// --- OLD PRODUCT CATALOG API (Used for JobCardCreator & Fitment) ---
const manufacturersCollection = collection(db, 'manufacturers');
const makesCollection = collection(db, 'makes');
const modelsCollection = collection(db, 'models');
const partsCollection = collection(db, 'parts');
export const getManufacturers = async () => {
  const snapshot = await getDocs(manufacturersCollection);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};
export const addManufacturer = (name) => addDoc(manufacturersCollection, { name });
export const getMakes = async () => {
  const snapshot = await getDocs(makesCollection);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};
export const addMake = (data) => addDoc(makesCollection, data);
export const getModels = async () => {
  const snapshot = await getDocs(modelsCollection);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};
export const addModel = (data) => addDoc(modelsCollection, data);
export const getParts = async () => {
  const snapshot = await getDocs(partsCollection);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};
export const addPart = (data) => addDoc(partsCollection, data);
export const updatePart = (partId, updatedData) => {
  const partDoc = doc(db, 'parts', partId);
  return updateDoc(partDoc, updatedData);
};

// --- JOB CARDS API ---
const jobCardsCollection = collection(db, 'createdJobCards');
export const searchPreviousJobs = async (searchText) => {
  if (!searchText) return [];
  const q = query(
    jobCardsCollection,
    where('partName', '>=', searchText),
    where('partName', '<=', searchText + '\uf8ff'),
    orderBy('partName'),
    orderBy('createdAt', 'desc'),
    limit(10)
  );
  const snapshot = await getDocs(q);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};
export const checkExistingJobRecipe = async (partId, departmentId) => {
  if (!partId || !departmentId) {
    return false;
  }
  const q = query(
    jobCardsCollection,
    where('partId', '==', partId),
    where('departmentId', '==', departmentId),
    limit(1)
  );
  const snapshot = await getDocs(q);
  return !snapshot.empty;
};
export const addJobCard = (jobCardData) => {
  return addDoc(jobCardsCollection, {
    ...jobCardData,
    createdAt: serverTimestamp()
  });
};
export const listenToJobCards = (callback) => {
  const q = query(jobCardsCollection, orderBy('createdAt', 'desc'));
  const unsubscribe = onSnapshot(q, (snapshot) => {
    const jobs = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    callback(jobs);
  });
  return unsubscribe;
};
export const getJobByJobId = async (jobId) => {
  const q = query(jobCardsCollection, where("jobId", "==", jobId));
  const querySnapshot = await getDocs(q);
  if (querySnapshot.empty) {
    throw new Error(`No job found with ID: ${jobId}`);
  }
  const jobDoc = querySnapshot.docs[0];
  return { id: jobDoc.id, ...jobDoc.data() };
};
export const updateJobStatus = async (docId, newStatus) => {
  const jobDocRef = doc(db, 'createdJobCards', docId);
  const jobDoc = await getDoc(jobDocRef);
  if (!jobDoc.exists()) {
    throw new Error("Job not found!");
  }
  const currentData = jobDoc.data();
  const dataToUpdate = {
    status: newStatus,
  };
  if (newStatus === 'In Progress') {
    if (!currentData.startedAt) {
      dataToUpdate.startedAt = serverTimestamp();
    } else if (currentData.status === 'Paused' && currentData.pausedAt) {
      const pauseDuration = new Date().getTime() - currentData.pausedAt.toDate().getTime();
      dataToUpdate.totalPausedMilliseconds = increment(pauseDuration);
      dataToUpdate.pausedAt = null;
    }
  } else if (newStatus === 'Paused') {
    dataToUpdate.pausedAt = serverTimestamp();
  } else if (newStatus === 'Awaiting QC') {
    dataToUpdate.completedAt = serverTimestamp();
  }
  return updateDoc(jobDocRef, dataToUpdate);
};
export const processQcDecision = async (job, isApproved, rejectionReason = '') => {
  const allInventory = await getAllInventoryItems();
  const inventoryMap = new Map(allInventory.map(item => [item.id, item]));
  const allEmployees = await getEmployees();
  const employeeMap = new Map(allEmployees.map(emp => [emp.id, emp]));
  return runTransaction(db, async (transaction) => {
    const jobRef = doc(db, 'createdJobCards', job.id);
    const jobDoc = await transaction.get(jobRef);
    if (!jobDoc.exists()) {
      throw "Job document does not exist!";
    }
    const currentJobData = jobDoc.data();
    const dataToUpdate = {};
    if (isApproved) {
      dataToUpdate.status = 'Complete';
      dataToUpdate.completedAt = serverTimestamp();
      let materialCost = 0;
      let laborCost = 0;
      if (currentJobData.processedConsumables && currentJobData.processedConsumables.length > 0) {
        for (const consumable of currentJobData.processedConsumables) {
          const inventoryItem = inventoryMap.get(consumable.id);
          if (inventoryItem && inventoryItem.price !== undefined) {
            materialCost += (inventoryItem.price * consumable.quantity);
          } else if (consumable.price !== undefined) {
            materialCost += (consumable.price * consumable.quantity);
          }
        }
      }
      dataToUpdate.materialCost = materialCost;
      const employee = employeeMap.get(currentJobData.employeeId);
      const hourlyRate = employee?.hourlyRate || 0;
      if (currentJobData.startedAt && hourlyRate > 0) {
        let activeSeconds = (new Date().getTime() - currentJobData.startedAt.toDate().getTime()) / 1000;
        if (currentJobData.totalPausedMilliseconds) {
          activeSeconds -= Math.floor(currentJobData.totalPausedMilliseconds / 1000);
        }
        const activeHours = activeSeconds > 0 ? activeSeconds / 3600 : 0;
        laborCost = activeHours * hourlyRate;
      }
      dataToUpdate.laborCost = laborCost;
      dataToUpdate.totalCost = materialCost + laborCost;
    } else {
      dataToUpdate.status = 'Issue';
      dataToUpdate.issueReason = rejectionReason;
    }
    transaction.update(jobRef, dataToUpdate);
    if (isApproved && currentJobData.processedConsumables && currentJobData.processedConsumables.length > 0) {
      for (const consumable of currentJobData.processedConsumables) {
        const inventoryItem = inventoryMap.get(consumable.id);
        if (!inventoryItem) continue;
        let collectionName = '';
        if (inventoryItem.category === 'Component') collectionName = 'components';
        else if (inventoryItem.category === 'Raw Material') collectionName = 'rawMaterials';
        else if (inventoryItem.category === 'Workshop Supply') collectionName = 'workshopSupplies';
        if (collectionName) {
          const itemRef = doc(db, collectionName, consumable.id);
          transaction.update(itemRef, { currentStock: increment(-consumable.quantity) });
          const currentStock = Number(inventoryItem.currentStock);
          const reorderLevel = Number(inventoryItem.reorderLevel);
          const newStockLevel = currentStock - consumable.quantity;
          if (reorderLevel > 0 && currentStock >= reorderLevel && newStockLevel < reorderLevel) {
            const newQueueDocRef = doc(collection(db, 'purchaseQueue'));
            transaction.set(newQueueDocRef, {
              itemId: inventoryItem.id, itemName: inventoryItem.name, supplierId: inventoryItem.supplierId,
              itemCode: inventoryItem.itemCode || '', category: inventoryItem.category, currentStock: newStockLevel,
              reorderLevel: reorderLevel, standardStockLevel: inventoryItem.standardStockLevel, price: inventoryItem.price,
              unit: inventoryItem.unit, status: 'pending', queuedAt: serverTimestamp()
            });
          }
        }
      }
    }
  });
};

// --- GENERIC DOCUMENT API ---
export const updateDocument = async (collectionName, docId, data) => {
  const docRef = doc(db, collectionName, docId);
  const dataToSave = { ...data };
  delete dataToSave.id;
  return updateDoc(docRef, dataToSave);
};
export const deleteDocument = async (collectionName, docId) => {
  const docRef = doc(db, collectionName, docId);
  return deleteDoc(docRef);
};
export const getCompletedJobsForEmployee = async (employeeId) => {
  if (!employeeId) return [];
  const q = query(
    jobCardsCollection,
    where('employeeId', '==', employeeId),
    where('status', 'in', ['Complete', 'Issue', 'Archived - Issue'])
  );
  const snapshot = await getDocs(q);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};

// ===================================================================
// NEW: UNIFIED PRODUCT CATALOG API v3
// ===================================================================
const productsCollection = collection(db, 'products');
const productCategoriesCollection = collection(db, 'productCategories');
const fitmentCollection = collection(db, 'fitment');
const productRecipeLinksCollection = collection(db, 'productRecipeLinks');

// --- Product Categories ---
export const getProductCategories = async () => {
    const snapshot = await getDocs(query(productCategoriesCollection, orderBy('name')));
    return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};
export const addProductCategory = (categoryName) => {
    return addDoc(productCategoriesCollection, { name: categoryName });
};
export const deleteProductCategory = async (categoryId) => {
    return deleteDoc(doc(db, 'productCategories', categoryId));
};

// --- Products (with duplicate part number check) ---
export const getProducts = async () => {
    const snapshot = await getDocs(query(productsCollection, orderBy('name')));
    return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};
export const addProduct = async (productData) => {
    const q = query(productsCollection, where("partNumber", "==", productData.partNumber));
    const querySnapshot = await getDocs(q);
    if (!querySnapshot.empty) {
        throw new Error(`A product with Part Number "${productData.partNumber}" already exists.`);
    }
    return addDoc(productsCollection, {
        ...productData,
        sellingPrice: Number(productData.sellingPrice) || 0,
        createdAt: serverTimestamp()
    });
};
export const updateProduct = (productId, updatedData) => {
    const productDoc = doc(db, 'products', productId);
    return updateDoc(productDoc, updatedData);
};
export const deleteProduct = async (productId) => {
    const batch = writeBatch(db);
    const productDoc = doc(db, 'products', productId);
    batch.delete(productDoc);
    const fitmentQuery = query(fitmentCollection, where('productId', '==', productId));
    const fitmentSnapshot = await getDocs(fitmentQuery);
    fitmentSnapshot.forEach(doc => batch.delete(doc.ref));
    const recipeLinkQuery = query(productRecipeLinksCollection, where('productId', '==', productId));
    const recipeLinkSnapshot = await getDocs(recipeLinkQuery);
    recipeLinkSnapshot.forEach(doc => batch.delete(doc.ref));
    return batch.commit();
};

// --- Fitment (Linking Products to Models) ---
export const getFitmentForProduct = async (productId) => {
    const q = query(fitmentCollection, where('productId', '==', productId));
    const snapshot = await getDocs(q);
    return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};
export const addFitment = (productId, modelId, modelName, makeName, manufacturerName) => {
    return addDoc(fitmentCollection, { 
        productId, 
        modelId,
        modelName,
        makeName,
        manufacturerName
    });
};
export const removeFitment = (fitmentId) => {
    const fitmentDoc = doc(db, 'fitment', fitmentId);
    return deleteDoc(fitmentDoc);
};

// --- Recipe Links (Linking Recipes to Products) ---
export const getLinkedRecipesForProduct = async (productId) => {
    const q = query(productRecipeLinksCollection, where('productId', '==', productId));
    const snapshot = await getDocs(q);
    return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
};
export const linkRecipeToProduct = (linkData) => {
    return addDoc(productRecipeLinksCollection, linkData);
};
export const unlinkRecipeFromProduct = (linkId) => {
    const linkDoc = doc(db, 'productRecipeLinks', linkId);
    return deleteDoc(linkDoc);
};



==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\features\job_cards\CustomJobCreator.jsx
==================================================
import React, { useState, useEffect, useRef } from 'react';
import Input from '../../ui/Input';
import Textarea from '../../ui/Textarea';
import Dropdown from '../../ui/Dropdown'; // Still used for Department/Employee
import Button from '../../ui/Button';
import { addJobCard, getDepartments, getEmployees, getTools, getToolAccessories, getAllInventoryItems } from '../../../api/firestore';
import { Search } from 'lucide-react'; // Import Search icon

const CustomJobCreator = () => {
    const [jobData, setJobData] = useState({
        jobName: '', // This will be the partName for custom jobs
        departmentId: '',
        employeeId: '',
        description: '',
        estimatedTime: '',
        steps: '', // Stored as a single string, split by newline
        selectedTools: new Set(),
        selectedAccessories: new Set(),
        consumables: [], // List of { id, name, quantity, unit, price } for custom jobs linked to inventory
    });

    const [allDepartments, setAllDepartments] = useState([]);
    const [allEmployees, setAllEmployees] = useState([]);
    const [allTools, setAllTools] = useState([]);
    const [allToolAccessories, setAllToolAccessories] = useState([]);
    const [allInventoryItems, setAllInventoryItems] = useState([]); // For consumables selection
    const [loading, setLoading] = useState(true);

    // State for the searchable consumable input
    const [consumableSearchTerm, setConsumableSearchTerm] = useState('');
    const [filteredConsumableOptions, setFilteredConsumableOptions] = useState([]);
    const [selectedConsumableItem, setSelectedConsumableItem] = useState(null); // Full item object
    const [consumableQuantity, setConsumableQuantity] = useState('');

    // Ref to handle clicks outside the search results
    const consumableSearchRef = useRef(null);

    // Ref to hold the dynamically generated Job Card Preview content for printing
    const customJobPreviewRef = useRef(null);

    useEffect(() => {
        const fetchData = async () => {
            setLoading(true);
            try {
                const [departments, employees, tools, toolAccessories, inventoryItems] = await Promise.all([
                    getDepartments(),
                    getEmployees(),
                    getTools(),
                    getToolAccessories(),
                    getAllInventoryItems()
                ]);
                setAllDepartments(departments);
                setAllEmployees(employees);
                setAllTools(tools);
                setAllToolAccessories(toolAccessories);
                setAllInventoryItems(inventoryItems);
            } catch (error) {
                console.error("Error fetching data for custom job creator:", error);
                alert("Failed to load necessary data for custom job creation.");
            } finally {
                setLoading(false);
            }
        };
        fetchData();
    }, []);

    // Effect for consumable search filtering
    useEffect(() => {
        if (consumableSearchTerm.length > 0) {
            const lowerCaseSearchTerm = consumableSearchTerm.toLowerCase();
            const filtered = allInventoryItems.filter(item =>
                item.name.toLowerCase().includes(lowerCaseSearchTerm) ||
                (item.itemCode && item.itemCode.toLowerCase().includes(lowerCaseSearchTerm))
            ).slice(0, 10); // Limit results for performance
            setFilteredConsumableOptions(filtered);
        } else {
            setFilteredConsumableOptions([]);
        }
    }, [consumableSearchTerm, allInventoryItems]);

    // Handle clicks outside the consumable search results to close them
    useEffect(() => {
        const handleClickOutside = (event) => {
            if (consumableSearchRef.current && !consumableSearchRef.current.contains(event.target)) {
                setFilteredConsumableOptions([]); // Close the dropdown
            }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => {
            document.removeEventListener('mousedown', handleClickOutside);
        };
    }, []);


    const handleInputChange = (e) => {
        const { name, value } = e.target;
        setJobData(prev => ({ ...prev, [name]: value }));
    };

    const handleToolToggle = (toolId) => {
        setJobData(prev => {
            const newTools = new Set(prev.selectedTools);
            if (newTools.has(toolId)) {
                newTools.delete(toolId);
                const accessoriesOfTool = allToolAccessories.filter(a => a.toolId === toolId).map(a => a.id);
                const newAccessories = new Set(prev.selectedAccessories);
                accessoriesOfTool.forEach(accId => newAccessories.delete(accId));
                return { ...prev, selectedTools: newTools, selectedAccessories: newAccessories };
            } else {
                newTools.add(toolId);
                return { ...prev, selectedTools: newTools };
            }
        });
    };

    const handleAccessoryToggle = (accessoryId) => {
        setJobData(prev => {
            const newAccessories = new Set(prev.selectedAccessories);
            newAccessories.has(accessoryId) ? newAccessories.delete(accessoryId) : newAccessories.add(accessoryId);
            return { ...prev, selectedAccessories: newAccessories };
        });
    };

    // When a consumable item is selected from the search results
    const selectConsumableFromSearch = (item) => {
        setSelectedConsumableItem(item); // Store the full item object
        setConsumableSearchTerm(item.name); // Display the name in the search box
        setFilteredConsumableOptions([]); // Hide search results
    };

    // Adds the selected consumable to the list
    const addConsumable = () => {
        if (!selectedConsumableItem || parseFloat(consumableQuantity) <= 0 || isNaN(parseFloat(consumableQuantity))) {
            alert("Please select a consumable from the list and enter a valid quantity.");
            return;
        }

        // Check if consumable already exists in the list to prevent duplicates
        const isDuplicate = jobData.consumables.some(c => c.id === selectedConsumableItem.id);
        if (isDuplicate) {
            alert("This consumable has already been added. Please remove it first if you want to change its quantity.");
            return;
        }

        setJobData(prev => ({
            ...prev,
            // Add id for stock deduction, and name/unit/price for display/costing
            consumables: [...prev.consumables, {
                id: selectedConsumableItem.id, // Crucial for stock deduction
                name: selectedConsumableItem.name,
                quantity: parseFloat(consumableQuantity),
                unit: selectedConsumableItem.unit || 'units', // Use inventory item's unit or default
                price: selectedConsumableItem.price || 0 // Use inventory item's price
            }]
        }));
        // Reset consumable inputs after adding
        setSelectedConsumableItem(null);
        setConsumableQuantity('');
        setConsumableSearchTerm('');
        setFilteredConsumableOptions([]);
    };

    // Removes a consumable from the list
    const removeConsumable = (indexToRemove) => {
        setJobData(prev => ({
            ...prev,
            consumables: prev.consumables.filter((_, index) => index !== indexToRemove)
        }));
    };

    // Handles the form submission for creating the custom job card
    const handleSubmit = async (e) => {
        e.preventDefault();

        // Basic validation for essential fields
        if (!jobData.jobName.trim()) { alert("Please enter a Job Name / Part Description."); return; }
        if (!jobData.departmentId) { alert("Please select a Department."); return; }
        if (!jobData.description.trim()) { alert("Please enter a Job Description."); return; }
        if (!jobData.steps.trim()) { alert("Please enter the Job Steps."); return; }
        
        // Prepare data for Firestore
        const newJobId = `CUSTOM-${Date.now()}`;
        const finalJobData = {
            jobId: newJobId, // Unique ID for custom jobs
            partName: jobData.jobName.trim(), // Use jobName as partName for custom jobs
            departmentId: jobData.departmentId,
            departmentName: allDepartments.find(d => d.id === jobData.departmentId)?.name || 'Unknown Department',
            employeeId: jobData.employeeId || 'unassigned', // Allow unassigned, but record 'unassigned' string
            employeeName: allEmployees.find(e => e.id === jobData.employeeId)?.name || 'Unassigned',
            status: 'Pending', // Initial status for all new jobs
            description: jobData.description.trim(),
            estimatedTime: parseFloat(jobData.estimatedTime) || 0,
            steps: jobData.steps.split('\n').filter(s => s.trim() !== ''), // Split steps by new line
            // Convert Sets of IDs to arrays of full tool/accessory objects for job card data
            tools: Array.from(jobData.selectedTools).map(toolId => allTools.find(t => t.id === toolId)).filter(Boolean),
            accessories: Array.from(jobData.selectedAccessories).map(accId => allToolAccessories.find(a => a.id === accId)).filter(Boolean),
            processedConsumables: jobData.consumables, // Consumables with linked IDs, quantities, and prices
            isCustomJob: true, // Flag this job as custom for future filtering/logic
        };

        try {
            await addJobCard(finalJobData);
            alert(`Custom Job Card ${finalJobData.jobId} created successfully!`);

            // --- Print Logic for Custom Job Card ---
            // Construct the HTML for the job card preview dynamically
            const departmentName = allDepartments.find(d => d.id === jobData.departmentId)?.name || 'Unknown Department';
            const employeeName = allEmployees.find(e => e.id === jobData.employeeId)?.name || 'Unassigned';

            const printContents = `
                <div style="font-family: sans-serif; padding: 20px; color: #333;">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; padding-bottom: 15px; border-bottom: 1px solid #eee;">
                        <div>
                            <h1 style="font-size: 28px; font-weight: bold; margin: 0;">Job Card</h1>
                            <p style="font-size: 14px; color: #666; margin: 0;">Part: <span style="font-weight: 600;">${finalJobData.partName}</span></p>
                            <p style="font-size: 14px; color: #666; margin: 0;">Department: <span style="font-weight: 600;">${departmentName}</span></p>
                        </div>
                        <div style="text-align: right;">
                           <img src="https://api.qrserver.com/v1/create-qr-code/?data=${encodeURIComponent(newJobId)}&size=80x80" alt="QR Code" style="margin-bottom: 5px;"/>
                           <p style="font-size: 10px; color: #999; margin: 0;">${newJobId}</p>
                        </div>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
                        <div>
                            <div style="border-radius: 8px; width: 100%; height: 200px; margin-bottom: 15px; background-color: #f5f5f5; display: flex; align-items: center; justify-content: center; color: #aaa; border: 1px solid #ddd;">
                                <span>No Image Available</span>
                            </div>
                            <div style="font-size: 13px; line-height: 1.6;">
                                <p style="margin: 0;"><b>Employee:</b> ${employeeName}</p>
                                <p style="margin: 0;"><b>Est. Time:</b> ${finalJobData.estimatedTime || 'N/A'} mins</p>
                                <p style="margin: 0;"><b>Description:</b> ${finalJobData.description || 'No description.'}</p>
                            </div>
                        </div>
                        <div style="font-size: 13px; line-height: 1.6;">
                            <div>
                                <h3 style="font-size: 16px; font-weight: bold; margin-bottom: 10px;">Required Tools & Accessories</h3>
                                <ul style="list-style: disc; padding-left: 20px; margin: 0;">
                                    ${finalJobData.tools?.length > 0 ? finalJobData.tools.map(tool => `<li>${tool.name}</li>`).join('') : '<li>No tools required.</li>'}
                                    ${finalJobData.accessories?.length > 0 ? finalJobData.accessories.map(acc => `<li style="margin-left: 15px;">${acc.name}</li>`).join('') : ''}
                                </ul>
                            </div>
                            <div style="margin-top: 20px;">
                                <h3 style="font-size: 16px; font-weight: bold; margin-bottom: 10px;">Required Consumables</h3>
                                <ul style="list-style: disc; padding-left: 20px; margin: 0;">
                                    ${finalJobData.processedConsumables?.length > 0 ? finalJobData.processedConsumables.map(c => `<li><span style="font-weight: 600;">${c.name}</span>: ${c.quantity} ${c.unit} (R${c.price.toFixed(2)})</li>`).join('') : '<li>No consumables required.</li>'}
                                </ul>
                            </div>
                        </div>
                    </div>
                    <div style="margin-top: 20px; border-top: 1px solid #eee; padding-top: 15px;">
                        <h3 style="font-size: 16px; font-weight: bold; margin-bottom: 10px;">Steps</h3>
                        <ol style="list-style: decimal; padding-left: 20px; margin: 0;">
                            ${finalJobData.steps?.length > 0 ? finalJobData.steps.map(step => `<li>${step}</li>`).join('') : '<li>No steps defined.</li>'}
                        </ol>
                    </div>
                </div>
            `;

            const printWindow = window.open('', '_blank', 'height=800,width=1000');
            printWindow.document.write(`
                <html>
                <head>
                    <title>Custom Job Card ${newJobId}</title>
                    <style>
                        /* Basic print styles to make it look decent */
                        body { margin: 0; padding: 20px; font-family: Arial, sans-serif; }
                        h1, h3 { color: #333; }
                        p, li { color: #555; }
                        @media print {
                            body { print-color-adjust: exact; -webkit-print-color-adjust: exact; }
                            button { display: none; /* Hide print button when printing */ }
                        }
                    </style>
                </head>
                <body>
                    ${printContents}
                    <div style="margin-top: 20px; text-align: center;">
                        <button onclick="window.print()" style="padding: 10px 20px; background-color: #3b82f6; color: white; border-radius: 8px; border: none; cursor: pointer;">Print This Job Card</button>
                    </div>
                </body>
                </html>
            `);
            printWindow.document.close();

            // Wait for the window content to load before attempting to print automatically
            printWindow.onload = () => {
                setTimeout(() => printWindow.print(), 500); // Attempt auto-print after a short delay
            };
            // --- End Print Logic ---

            // Reset form fields after successful creation
            setJobData({
                jobName: '',
                departmentId: '',
                employeeId: '',
                description: '',
                estimatedTime: '',
                steps: '',
                selectedTools: new Set(),
                selectedAccessories: new Set(),
                consumables: [],
            });
            setSelectedConsumableItem(null);
            setConsumableQuantity('');
            setConsumableSearchTerm('');
            setFilteredConsumableOptions([]);

        } catch (error) {
            console.error("Error creating custom job card:", error);
            alert("Failed to create custom job card.");
        }
    };

    // Display loading message while data is being fetched
    if (loading) return <p className="text-center text-gray-400">Loading custom job form data...</p>;

    return (
        <div className="bg-gray-800 p-6 rounded-xl border border-gray-700 max-w-4xl mx-auto">
            <h3 className="text-lg font-semibold text-white mb-4">Create a One-Off / Custom Job Card</h3>
            <form onSubmit={handleSubmit} className="space-y-6">
                <Input label="Job Name / Part Description" name="jobName" value={jobData.jobName} onChange={handleInputChange} placeholder="e.g., Repair Customer's Custom Bracket" />
                <Dropdown label="Department" name="departmentId" value={jobData.departmentId} onChange={handleInputChange} options={allDepartments} placeholder="Select Department" />
                <Dropdown label="Employee (Optional)" name="employeeId" value={jobData.employeeId} onChange={handleInputChange} options={allEmployees} placeholder="Select Employee..." />
                <Textarea label="Job Description" name="description" value={jobData.description} onChange={handleInputChange} placeholder="e.g., Weld crack in bracket and repaint" rows={3} />
                <Input label="Estimated Time (minutes)" name="estimatedTime" type="number" value={jobData.estimatedTime} onChange={handleInputChange} placeholder="e.g., 90" />
                <Textarea label="Steps (one per line)" name="steps" value={jobData.steps} onChange={handleInputChange} placeholder="1. Clean area&#10;2. Weld crack&#10;3. Sand smooth&#10;4. Paint" rows={5} />

                {/* Tools & Accessories Selection */}
                <div>
                    <h4 className="font-semibold text-white mb-2">Required Tools & Accessories</h4>
                    <div className="max-h-60 overflow-y-auto space-y-3 p-4 bg-gray-900/50 rounded-lg">
                        {(allTools || []).map(tool => (
                            <div key={tool.id}>
                                <label className="flex items-center space-x-2 text-sm font-semibold text-gray-200">
                                    <input type="checkbox" checked={jobData.selectedTools.has(tool.id)} onChange={() => handleToolToggle(tool.id)} className="h-4 w-4 rounded bg-gray-700 text-blue-600 focus:ring-blue-500" />
                                    <span>{tool.name}</span>
                                </label>
                                {jobData.selectedTools.has(tool.id) && (
                                    <div className="pl-6 mt-1 space-y-1 text-xs border-l-2 border-gray-700">
                                        {(allToolAccessories.filter(acc => acc.toolId === tool.id)).map(accessory => (
                                            <label key={accessory.id} className="flex items-center space-x-2 text-xs text-gray-300">
                                                <input type="checkbox" checked={jobData.selectedAccessories.has(accessory.id)} onChange={() => handleAccessoryToggle(accessory.id)} className="h-3 w-3 rounded bg-gray-700 text-blue-600 focus:ring-blue-500" />
                                                <span>{accessory.name}</span>
                                            </label>
                                        ))}
                                    </div>
                                )}
                            </div>
                        ))}
                    </div>
                </div>

                {/* Consumables Input - Now a searchable dropdown linked to inventory */}
                <div>
                    <h4 className="font-semibold text-white mb-2">Required Consumables (Select from Inventory)</h4>
                    <div className="p-4 bg-gray-900/50 rounded-lg space-y-3">
                        <div className="flex items-end gap-2" ref={consumableSearchRef}>
                            <div className="flex-grow relative">
                                <Input
                                    label="Consumable Item"
                                    name="consumableSearch"
                                    value={consumableSearchTerm}
                                    onChange={(e) => {
                                        setConsumableSearchTerm(e.target.value);
                                        setSelectedConsumableItem(null); // Clear selected item if typing
                                    }}
                                    placeholder="Search by name or code..."
                                />
                                <Search className="absolute right-3 top-1/2 -translate-y-1/2 text-gray-400" size={20} />
                                {/* Search Results */}
                                {consumableSearchTerm.length > 0 && filteredConsumableOptions.length > 0 && (
                                    <ul className="absolute z-10 bg-gray-700 border border-gray-600 rounded-md w-full mt-1 max-h-48 overflow-y-auto shadow-lg">
                                        {filteredConsumableOptions.map(item => (
                                            <li
                                                key={item.id}
                                                className="p-2 text-sm text-gray-200 hover:bg-blue-600 hover:text-white cursor-pointer"
                                                onClick={() => selectConsumableFromSearch(item)}
                                            >
                                                {item.name} ({item.itemCode || 'N/A'}) - {item.unit} (R{item.price.toFixed(2)})
                                            </li>
                                        ))}
                                    </ul>
                                )}
                            </div>
                            <div className="w-24">
                                <Input
                                    label="Quantity"
                                    name="quantity"
                                    type="number"
                                    step="any"
                                    value={consumableQuantity}
                                    onChange={(e) => setConsumableQuantity(e.target.value)}
                                    placeholder="e.g., 0.5"
                                />
                            </div>
                            <Button type="button" onClick={addConsumable} disabled={!selectedConsumableItem || parseFloat(consumableQuantity) <= 0 || isNaN(parseFloat(consumableQuantity))}>Add</Button>
                        </div>
                        <ul className="space-y-2 max-h-40 overflow-y-auto border-t border-gray-700 pt-3">
                            {jobData.consumables.length > 0 ? (
                                jobData.consumables.map((c, index) => (
                                    <li key={index} className="flex justify-between items-center bg-gray-700 p-2 rounded text-sm text-gray-200">
                                        <span>{c.name} : {c.quantity} {c.unit} (R{c.price.toFixed(2)})</span>
                                        <Button type="button" onClick={() => removeConsumable(index)} variant="danger" className="py-0.5 px-2 text-xs">X</Button>
                                    </li>
                                ))
                            ) : (
                                <li className="text-gray-400 text-sm">No consumables added yet.</li>
                            )}
                        </ul>
                    </div>
                </div>

                <div className="text-center">
                    <Button type="submit" variant="primary">Create Custom Job Card</Button>
                </div>
            </form>
        </div>
    );
};

export default CustomJobCreator;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\features\job_cards\JobCardCreator.jsx
==================================================
import React, { useState, useEffect, useMemo, useRef } from 'react';
import { getManufacturers, getMakes, getModels, getParts, getDepartments, getEmployees, addJobCard, getJobStepDetails, getTools, getToolAccessories, getAllInventoryItems, checkExistingJobRecipe, setJobStepDetail } from '../../../api/firestore';
import { processConsumables } from '../../../utils/jobUtils'; // <-- IMPORT THE UTILITY
import Dropdown from '../../ui/Dropdown';
import Button from '../../ui/Button';
import Textarea from '../../ui/Textarea';
import Input from '../../ui/Input';
import { Search } from 'lucide-react';

// The RecipeConsumableEditor component remains unchanged.
// Paste the existing RecipeConsumableEditor component code here.
const RecipeConsumableEditor = ({ consumables, selectedConsumables, onAdd, onRemove }) => {
    const [consumableType, setConsumableType] = useState('fixed');
    const [selectedFixedItemId, setSelectedFixedItemId] = useState('');
    const [fixedQty, setFixedQty] = useState('');
    const [selectedDimItemId, setSelectedDimItemId] = useState('');
    const [cuts, setCuts] = useState([]);
    const [cutRule, setCutRule] = useState({ dimensions: '', notes: '' });
    const [fixedSearchTerm, setFixedSearchTerm] = useState('');
    const [filteredFixedOptions, setFilteredFixedOptions] = useState([]);
    const [selectedFixedItemDetails, setSelectedFixedItemDetails] = useState(null); 
    const [dimSearchTerm, setDimSearchTerm] = useState('');
    const [filteredDimOptions, setFilteredDimOptions] = useState([]);
    const [selectedDimItemDetails, setSelectedDimItemDetails] = useState(null);
    const searchRefFixed = useRef(null);
    const searchRefDim = useRef(null);

    useEffect(() => {
        if (fixedSearchTerm.length > 0) {
            const lowerCaseSearchTerm = fixedSearchTerm.toLowerCase();
            const filtered = consumables.filter(item =>
                item.name.toLowerCase().includes(lowerCaseSearchTerm) ||
                (item.itemCode && item.itemCode.toLowerCase().includes(lowerCaseSearchTerm))
            ).slice(0, 10);
            setFilteredFixedOptions(filtered);
        } else {
            setFilteredFixedOptions([]);
        }
    }, [fixedSearchTerm, consumables]);

    useEffect(() => {
        if (dimSearchTerm.length > 0) {
            const lowerCaseSearchTerm = dimSearchTerm.toLowerCase();
            const filtered = consumables.filter(item =>
                (item.name.toLowerCase().includes('mat') || item.category === 'Raw Material') &&
                (item.name.toLowerCase().includes(lowerCaseSearchTerm) ||
                (item.itemCode && item.itemCode.toLowerCase().includes(lowerCaseSearchTerm)))
            ).slice(0, 10);
            setFilteredDimOptions(filtered);
        } else {
            setFilteredDimOptions([]);
        }
    }, [dimSearchTerm, consumables]);

    useEffect(() => {
        const handleClickOutside = (event) => {
            if (searchRefFixed.current && !searchRefFixed.current.contains(event.target)) {
                setFilteredFixedOptions([]);
            }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
    }, []);

    useEffect(() => {
        const handleClickOutside = (event) => {
            if (searchRefDim.current && !searchRefDim.current.contains(event.target)) {
                setFilteredDimOptions([]);
            }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
    }, []);

    const handleAddConsumable = () => {
        let newConsumable;
        switch (consumableType) {
            case 'fixed':
                if (!selectedFixedItemDetails || !fixedQty || parseFloat(fixedQty) <= 0) return alert("Please select an item and enter a valid quantity.");
                newConsumable = { type: 'fixed', itemId: selectedFixedItemDetails.id, quantity: Number(fixedQty) };
                break;
            case 'dimensional':
                if (!selectedDimItemDetails || cuts.length === 0) return alert("Please select a material and add at least one cutting instruction.");
                newConsumable = { type: 'dimensional', itemId: selectedDimItemDetails.id, cuts };
                break;
            default: return;
        }
        if (!selectedConsumables.find(c => c.itemId === newConsumable.itemId)) {
            onAdd(newConsumable);
            setFixedSearchTerm('');
            setFixedQty('');
            setSelectedFixedItemDetails(null);
            setDimSearchTerm('');
            setCuts([]);
            setCutRule({ dimensions: '', notes: '' });
            setSelectedDimItemDetails(null);
        } else {
            alert("This consumable has already been added to the recipe.");
        }
    };
    const getConsumableName = (id) => consumables.find(c => c.id === id)?.name || 'Unknown Item';
    return (
        <div>
            <h5 className="font-semibold mb-2 text-gray-200">Required Consumables for Recipe</h5>
            <div className="p-4 bg-gray-800 rounded-lg space-y-4">
                <div className="flex gap-2 bg-gray-700 p-1 rounded-md">
                    <button type="button" onClick={() => setConsumableType('fixed')} className={`flex-1 p-2 text-sm rounded transition-colors ${consumableType === 'fixed' ? 'bg-blue-600 text-white' : 'hover:bg-blue-500/20'}`}>Fixed Quantity</button>
                    <button type="button" onClick={() => setConsumableType('dimensional')} className={`flex-1 p-2 text-sm rounded transition-colors ${consumableType === 'dimensional' ? 'bg-blue-600 text-white' : 'hover:bg-blue-500/20'}`}>Dimensional Cuts</button>
                </div>
                {consumableType === 'fixed' && (
                    <div className="flex items-end gap-2 animate-fade-in" ref={searchRefFixed}>
                        <div className="flex-grow relative">
                            <Input
                                label="Item"
                                value={fixedSearchTerm}
                                onChange={e => {
                                    setFixedSearchTerm(e.target.value);
                                    setSelectedFixedItemDetails(null);
                                }}
                                placeholder="Search by name or code..."
                            />
                            <Search className="absolute right-3 top-1/2 -translate-y-1/2 text-gray-400" size={20} />
                            {fixedSearchTerm.length > 0 && filteredFixedOptions.length > 0 && (
                                <ul className="absolute z-10 bg-gray-700 border border-gray-600 rounded-md w-full mt-1 max-h-48 overflow-y-auto shadow-lg">
                                    {filteredFixedOptions.map(item => (
                                        <li
                                            key={item.id}
                                            className="p-2 text-sm text-gray-200 hover:bg-blue-600 hover:text-white cursor-pointer"
                                            onClick={() => {
                                                setSelectedFixedItemDetails(item);
                                                setSelectedFixedItemId(item.id);
                                                setFixedSearchTerm(item.name);
                                                setFilteredFixedOptions([]);
                                            }}
                                        >
                                            {item.name} ({item.itemCode || 'N/A'}) - {item.unit || 'units'} (R{item.price?.toFixed(2) || '0.00'})
                                        </li>
                                    ))}
                                </ul>
                            )}
                        </div>
                        <div className="w-24">
                            <Input
                                label="Qty"
                                type="number"
                                value={fixedQty}
                                onChange={e => setFixedQty(e.target.value)}
                                placeholder="e.g., 5"
                            />
                        </div>
                        <Button
                            type="button"
                            onClick={handleAddConsumable}
                            disabled={!selectedFixedItemDetails || parseFloat(fixedQty) <= 0 || isNaN(parseFloat(fixedQty))}
                        >
                            Add
                        </Button>
                    </div>
                )}
                {consumableType === 'dimensional' && (
                    <div className="space-y-3 animate-fade-in" ref={searchRefDim}>
                         <div className="flex-grow relative">
                            <Input
                                label="Material to Cut"
                                value={dimSearchTerm}
                                onChange={e => {
                                    setDimSearchTerm(e.target.value);
                                    setSelectedDimItemDetails(null);
                                }}
                                placeholder="Search by name or code..."
                            />
                            <Search className="absolute right-3 top-1/2 -translate-y-1/2 text-gray-400" size={20} />
                            {dimSearchTerm.length > 0 && filteredDimOptions.length > 0 && (
                                <ul className="absolute z-10 bg-gray-700 border border-gray-600 rounded-md w-full mt-1 max-h-48 overflow-y-auto shadow-lg">
                                    {filteredDimOptions.map(item => (
                                        <li
                                            key={item.id}
                                            className="p-2 text-sm text-gray-200 hover:bg-blue-600 hover:text-white cursor-pointer"
                                            onClick={() => {
                                                setSelectedDimItemDetails(item);
                                                setSelectedDimItemId(item.id);
                                                setDimSearchTerm(item.name);
                                                setFilteredDimOptions([]);
                                            }}
                                        >
                                            {item.name} ({item.itemCode || 'N/A'}) - {item.unit || 'units'} (R{item.price?.toFixed(2) || '0.00'})
                                        </li>
                                    ))}
                                </ul>
                            )}
                        </div>
                        <div className="p-2 border border-gray-700 rounded-md">
                            <p className="text-xs text-gray-400 mb-2">Cutting Instructions</p>
                            <div className="flex items-end gap-2">
                                <Input label="Dimensions (e.g., 120cm x 80cm)" value={cutRule.dimensions} onChange={e => setCutRule({...cutRule, dimensions: e.target.value})} />
                                <Input label="Notes" value={cutRule.notes} onChange={e => setCutRule({...cutRule, notes: e.target.value})} />
                                <Button type="button" onClick={() => { if(cutRule.dimensions) { setCuts([...cuts, cutRule]); setCutRule({ dimensions: '', notes: '' }); }}}>Add Cut</Button>
                            </div>
                            <ul className="text-xs mt-2 space-y-1">{cuts.map((c, i) => <li key={i}>{c.dimensions} ({c.notes})</li>)}</ul>
                        </div>
                        <Button
                            type="button"
                            onClick={handleAddConsumable}
                            className="w-full"
                            disabled={!selectedDimItemDetails || cuts.length === 0}
                        >
                            Add Dimensional Consumable
                        </Button>
                    </div>
                )}
                <h6 className="text-sm font-bold pt-2 border-t border-gray-700 text-gray-200">Recipe Consumables</h6>
                <ul className="space-y-2 max-h-40 overflow-y-auto">
                    {selectedConsumables.map((c, i) => (
                        <li key={i} className="flex justify-between items-center bg-gray-700 p-2 rounded text-sm text-gray-200">
                            <div>
                                <p className="font-semibold">{getConsumableName(c.itemId)}</p>
                                {c.type === 'fixed' && <p className="text-xs text-gray-400">Qty: {c.quantity}</p>}
                                {c.type === 'dimensional' && <p className="text-xs text-gray-400">{c.cuts.length} cut(s) required</p>}
                            </div>
                            <Button type="button" onClick={() => onRemove(c.itemId)} variant="danger" className="py-0.5 px-2 text-xs">X</Button>
                        </li>
                    ))}
                </ul>
            </div>
        </div>
    );
};


// The JobCardPreview component also remains unchanged.
// Paste the existing JobCardPreview component code here.
const JobCardPreview = ({ details }) => {
    if (!details) return null;
    return (
        <div className="mt-8 p-6 bg-gray-800 rounded-xl border border-gray-700">
            <h2 className="text-2xl font-bold text-white mb-6">Generated Job Card Preview</h2>
            <div id="job-card-print-area" className="bg-white text-gray-800 p-8 rounded-lg shadow-lg">
                <div className="flex justify-between items-start pb-4 border-b">
                    <div>
                        <h1 className="text-3xl font-bold text-gray-900">Job Card</h1>
                        <p className="text-gray-600">Part: <span className="font-semibold">{details.partName}</span></p>
                        <p className="text-gray-600">Department: <span className="font-semibold">{details.departmentName}</span></p>
                    </div>
                    <div className="text-right">
                       <img src={`https://api.qrserver.com/v1/create-qr-code/?data=${encodeURIComponent(details.jobId)}&size=80x80`} alt="QR Code"/>
                       <p className="text-xs text-gray-500 mt-1">{details.jobId}</p>
                    </div>
                </div>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-8 mt-6">
                    <div>
                        {details.photoUrl ? ( <img src={details.photoUrl} alt={details.partName} className="rounded-lg object-cover w-full h-64 mb-4 border" /> ) : ( <div className="rounded-lg w-full h-64 mb-4 border bg-gray-100 flex items-center justify-center text-gray-400"><span>No Image Available</span></div> )}
                        <div className="space-y-2 text-sm">
                            <p><b>Employee:</b> {details.employeeName}</p>
                            <p><b>Est. Time:</b> {details.estimatedTime || 'N/A'} mins</p>
                            <p><b>Description:</b> {details.description || 'No description.'}</p>
                        </div>
                    </div>
                    <div className="space-y-4">
                        <div>
                            <h3 className="text-lg font-bold text-gray-800 mb-2">Required Tools & Accessories</h3>
                            <ul className="list-disc list-inside text-gray-600 space-y-1 text-sm">
                                {details.tools?.length > 0 ? details.tools.map((tool) => <li key={tool.id}>{tool.name}</li>) : <li>No tools required.</li>}
                                {details.accessories?.length > 0 ? details.accessories.map((acc) => <li key={acc.id} className="ml-4">{acc.name}</li>) : null}
                            </ul>
                        </div>
                        <div>
                            <h3 className="text-lg font-bold text-gray-800 mb-2">Required Consumables</h3>
                            <ul className="list-disc list-inside text-gray-600 space-y-2 text-sm">
                                {details.processedConsumables?.length > 0 ? details.processedConsumables.map((c, i) => (
                                    <li key={i}>
                                        <span className="font-semibold">{c.name}</span>
                                        {c.quantity && <span>: {c.quantity.toFixed(3)} {c.unit}</span>}
                                        {c.notes && <span className="text-xs italic text-gray-500 ml-1">{c.notes}</span>}
                                        {c.cuts && (
                                            <ul className="list-square list-inside ml-4 mt-1">
                                                {c.cuts.map((cut, j) => <li key={j}>{cut.dimensions} <span className="text-xs italic text-gray-500">{cut.notes}</span></li>)}
                                            </ul>
                                        )}
                                    </li>
                                )) : <li>No consumables required.</li>}
                            </ul>
                        </div>
                    </div>
                </div>
                <div className="mt-6 border-t pt-4">
                    <h3 className="text-lg font-bold text-gray-800 mb-2">Steps</h3>
                    <ol className="list-decimal list-inside text-gray-600 space-y-1 text-sm">{details.steps?.length > 0 ? details.steps.map((step, i) => <li key={i}>{step}</li>) : <li>No steps defined.</li>}</ol>
                </div>
            </div>
        </div>
    )
};


// Main component
const JobCardCreator = () => {
    // State to hold all master data from Firestore
    const [allData, setAllData] = useState({ manufacturers:[], makes:[], models:[], parts:[], departments:[], employees:[], jobSteps: [], tools: [], toolAccessories: [], allConsumables: [] });
    const [loading, setLoading] = useState(true);
    // State to hold user selections in the dropdowns
    const [selection, setSelection] = useState({ manufacturerId: '', makeId: '', modelId: '', partId: '', departmentId: '', employeeId: '' });
    // State for the generated job card details to be previewed and saved
    const [jobDetails, setJobDetails] = useState(null);
    // State to hold current temperature from weather API for catalyst calculation
    const [currentTemp, setCurrentTemp] = useState(null);
    // Flags and states for "Define Recipe on Demand"
    const [showDefineRecipeForm, setShowDefineRecipeForm] = useState(false);
    const [tempRecipeDetails, setTempRecipeDetails] = useState({ description: '', estimatedTime: '', steps: '', tools: new Set(), accessories: new Set(), consumables: [] });
    const [isSavingNewRecipe, setIsSavingNewRecipe] = useState(false);

    // Fetch all necessary data when the component mounts
    useEffect(() => {
        const fetchAllData = async () => {
            setLoading(true);
            try {
                const weatherResponse = await fetch("https://api.open-meteo.com/v1/forecast?latitude=-33.92&longitude=18.42&current=temperature_2m");
                const weatherData = await weatherResponse.json();
                setCurrentTemp(weatherData.current.temperature_2m);

                const [man, mak, mod, par, dep, emp, steps, t, ta, inv] = await Promise.all([
                    getManufacturers(), getMakes(), getModels(), getParts(), getDepartments(), getEmployees(), getJobStepDetails(), getTools(), getToolAccessories(), getAllInventoryItems()
                ]);
                setAllData({ manufacturers: man, makes: mak, models: mod, parts: par, departments: dep, employees: emp, jobSteps: steps, tools: t, toolAccessories: ta, allConsumables: inv });
            } catch (error) {
                console.error("Failed to fetch initial data:", error);
                alert("Error fetching page data. Please check the console and refresh.");
                if (currentTemp === null) setCurrentTemp(20); // Fallback temperature if API fails
            } finally {
                setLoading(false);
            }
        };
        fetchAllData();
    }, []);

    // Handler for dropdown selections
    const handleSelection = (e) => {
        const { name, value } = e.target;
        setSelection(prev => {
            const updated = { ...prev, [name]: value };
            if (name === 'manufacturerId') { updated.makeId = ''; updated.modelId = ''; updated.partId = ''; }
            if (name === 'makeId') { updated.modelId = ''; updated.partId = ''; }
            if (name === 'modelId') { updated.partId = ''; }
            if (name === 'departmentId') { updated.employeeId = ''; }
            return updated;
        });
        setShowDefineRecipeForm(false);
        setTempRecipeDetails({ description: '', estimatedTime: '', steps: '', tools: new Set(), accessories: new Set(), consumables: [] });
    };

    // Memoized filtered options for dropdowns for performance
    const filteredMakes = useMemo(() => allData.makes.filter(m => m.manufacturerId === selection.manufacturerId), [allData.makes, selection.manufacturerId]);
    const filteredModels = useMemo(() => allData.models.filter(m => m.makeId === selection.makeId), [allData.models, selection.makeId]);
    const filteredParts = useMemo(() => allData.parts.filter(p => p.modelId === selection.modelId), [allData.parts, selection.modelId]);
    const filteredEmployees = useMemo(() => allData.employees.filter(e => e.departmentId === selection.departmentId), [allData.employees, selection.departmentId]);

    // Effect to generate job details whenever selections or data change
    useEffect(() => {
        const { partId, departmentId, employeeId } = selection;
        if (partId && departmentId && currentTemp !== null) {
            const part = allData.parts.find(p => p.id === partId);
            const department = allData.departments.find(d => d.id === departmentId);
            const employee = allData.employees.find(e => e.id === employeeId);
            
            let finalRecipeDetails = null;
            let isRecipeFoundInDb = false;

            const standardRecipe = allData.jobSteps.find(step => step.partId === partId && step.departmentId === departmentId);
            if (standardRecipe) {
                finalRecipeDetails = standardRecipe;
                isRecipeFoundInDb = true;
                setShowDefineRecipeForm(false);
            } else {
                setShowDefineRecipeForm(true);
                finalRecipeDetails = {
                    description: tempRecipeDetails.description || 'No description.',
                    estimatedTime: tempRecipeDetails.estimatedTime || 0,
                    steps: tempRecipeDetails.steps.split('\n').filter(s => s.trim() !== ''),
                    tools: Array.from(tempRecipeDetails.tools),
                    accessories: Array.from(tempRecipeDetails.accessories),
                    consumables: tempRecipeDetails.consumables
                };
            }
            
            if (part && department) {
                // <-- USE THE REFACTORED UTILITY FUNCTION
                const processed = processConsumables(finalRecipeDetails?.consumables, allData.allConsumables, currentTemp);

                const toolsForDisplay = (finalRecipeDetails?.tools || []).map(toolId => allData.tools.find(t => t.id === toolId)).filter(Boolean);
                const accessoriesForDisplay = (finalRecipeDetails?.accessories || []).map(accId => allData.toolAccessories.find(a => a.id === accId)).filter(Boolean);
                
                setJobDetails({
                    jobId: `JOB-${Date.now()}`,
                    partName: part.name,
                    partId: part.id,
                    photoUrl: part.photoUrl || '',
                    departmentId: department.id,
                    departmentName: department.name,
                    employeeId: employee ? employee.id : '',
                    employeeName: employee ? employee.name : 'Unassigned',
                    status: 'Pending',
                    description: finalRecipeDetails?.description || 'No description.',
                    estimatedTime: finalRecipeDetails?.estimatedTime || 0,
                    steps: finalRecipeDetails?.steps || [],
                    tools: toolsForDisplay,
                    accessories: accessoriesForDisplay,
                    consumables: finalRecipeDetails?.consumables || [],
                    processedConsumables: processed, // <-- Use the result from the utility function
                    isRecipeFoundInDb: isRecipeFoundInDb,
                });
            }
        } else {
            setJobDetails(null);
            setShowDefineRecipeForm(false);
        }
    }, [selection, allData, currentTemp, tempRecipeDetails]);

    // Handlers for inline recipe definition form
    const handleTempRecipeInputChange = (e) => {
        const { name, value } = e.target;
        setTempRecipeDetails(prev => ({ ...prev, [name]: value }));
    };
    const handleTempRecipeToolToggle = (toolId) => {
        setTempRecipeDetails(prev => {
            const newTools = new Set(prev.tools);
            newTools.has(toolId) ? newTools.delete(toolId) : newTools.add(toolId);
            return { ...prev, tools: newTools };
        });
    };
    const handleTempRecipeAccessoryToggle = (accId) => {
        setTempRecipeDetails(prev => {
            const newAccessories = new Set(prev.accessories);
            newAccessories.has(accId) ? newAccessories.delete(accId) : newAccessories.add(accId);
            return { ...prev, accessories: newAccessories };
        });
    };
    const handleTempRecipeConsumableAdd = (consumable) => {
        setTempRecipeDetails(prev => ({ ...prev, consumables: [...prev.consumables, consumable] }));
    };
    const handleTempRecipeConsumableRemove = (itemId) => {
        setTempRecipeDetails(prev => ({ ...prev, consumables: prev.consumables.filter(c => c.itemId !== itemId) }));
    };

    // Function to save the new recipe and create the job card
    const saveNewRecipeAndCreateJob = async () => {
        if (!jobDetails || !selection.partId || !selection.departmentId) return;
        if (!tempRecipeDetails.description.trim() || !tempRecipeDetails.estimatedTime || !tempRecipeDetails.steps.trim()) {
            alert("Please fill in Description, Estimated Time, and Steps for the new recipe.");
            return;
        }
        
        setIsSavingNewRecipe(true);
        try {
            const recipeData = {
                description: tempRecipeDetails.description.trim(),
                estimatedTime: Number(tempRecipeDetails.estimatedTime),
                steps: tempRecipeDetails.steps.split('\n').filter(s => s.trim() !== ''),
                tools: Array.from(tempRecipeDetails.tools),
                accessories: Array.from(tempRecipeDetails.accessories),
                consumables: tempRecipeDetails.consumables,
            };
            await setJobStepDetail(selection.partId, selection.departmentId, recipeData);
            alert("New recipe saved successfully!");
            
            const jobCardDataForCreation = {
                ...jobDetails,
                description: recipeData.description,
                estimatedTime: recipeData.estimatedTime,
                steps: recipeData.steps,
                tools: recipeData.tools.map(toolId => allData.tools.find(t => t.id === toolId)).filter(Boolean),
                accessories: recipeData.accessories.map(accId => allData.toolAccessories.find(a => a.id === accId)).filter(Boolean),
                consumables: recipeData.consumables,
                processedConsumables: processConsumables(recipeData.consumables, allData.allConsumables, currentTemp),
            };
            await addJobCard(jobCardDataForCreation);
            alert(`Job Card ${jobDetails.jobId} created successfully from new recipe!`);
            
            const printContents = document.getElementById('job-card-print-area').innerHTML;
            const printWindow = window.open('', '', 'height=800,width=1000');
            printWindow.document.write(`<html><head><title>Print Job Card</title><script src="https://cdn.tailwindcss.com/"></script><style>@media print { body { -webkit-print-color-adjust: exact; } button { display: none; } }</style></head><body><div class="p-8">${printContents}</div><div class="mt-4 text-center"><button onclick="window.print()" style="padding: 10px 20px; background-color: #3b82f6; color: white; border-radius: 8px; border: none; cursor: pointer;">Print This Job Card</button></div></body></html>`);
            printWindow.document.close();
            printWindow.onload = () => {
                setTimeout(() => printWindow.print(), 500);
            };

            const updatedJobSteps = await getJobStepDetails();
            setAllData(prev => ({ ...prev, jobSteps: updatedJobSteps }));
            handleResetFormAndPreview();
        } catch (error) {
            console.error("Error saving new recipe or creating job:", error);
            alert("Failed to save new recipe or create job. Please try again.");
        } finally {
            setIsSavingNewRecipe(false);
        }
    };

    // All other handlers (handleGenerateNewJobCard, handleResetFormAndPreview, handlePrintAndCreate) and the JSX rendering remain the same.
    // Paste the existing code for those handlers and the return statement here.
    const handleGenerateNewJobCard = async () => {
        if (!jobDetails) {
            alert("No job details to generate. Please select a part and department first.");
            return;
        }
        const confirmGenerate = window.confirm(
            `Are you sure you want to create another Job Card for "${jobDetails.partName}" in "${jobDetails.departmentName}"?` +
            (jobDetails.employeeName !== 'Unassigned' ? ` It will be assigned to ${jobDetails.employeeName}.` : "")
        );
        if (!confirmGenerate) return;

        try {
            const newJobCardData = {
                ...jobDetails,
                jobId: `JOB-${Date.now()}`,
                status: 'Pending',
                startedAt: null,
                completedAt: null,
                pausedAt: null,
                totalPausedMilliseconds: 0,
                materialCost: null,
                laborCost: null,
                totalCost: null,
                issueReason: null,
            };
            await addJobCard(newJobCardData);
            alert(`New Job Card ${newJobCardData.jobId} created successfully!`);
            
            const printContents = document.getElementById('job-card-print-area').innerHTML;
            const printWindow = window.open('', '', 'height=800,width=1000');
            printWindow.document.write(`<html><head><title>Print Job Card</title><script src="https://cdn.tailwindcss.com/"></script><style>@media print { body { -webkit-print-color-adjust: exact; } button { display: none; } }</style></head><body><div class="p-8">${printContents}</div><div class="mt-4 text-center"><button onclick="window.print()" style="padding: 10px 20px; background-color: #3b82f6; color: white; border-radius: 8px; border: none; cursor: pointer;">Print This Job Card</button></div></body></html>`);
            printWindow.document.close();
            printWindow.onload = () => {
                setTimeout(() => printWindow.print(), 500);
            };
            
            setJobDetails(prev => ({...prev, jobId: `JOB-${Date.now()}`}));
        } catch (error) {
            console.error("Error generating new job card:", error);
            alert("Failed to generate new job card.");
        }
    };

    const handleResetFormAndPreview = () => {
        setSelection({ manufacturerId: '', makeId: '', modelId: '', partId: '', departmentId: '', employeeId: '' });
        setJobDetails(null);
        setShowDefineRecipeForm(false);
        setTempRecipeDetails({ description: '', estimatedTime: '', steps: '', tools: new Set(), accessories: new Set(), consumables: [] });
    };

    const handlePrintAndCreate = async () => {
        if (!jobDetails) return;
        const recipeExistsInDb = await checkExistingJobRecipe(jobDetails.partId, jobDetails.departmentId);
        if (recipeExistsInDb) {
            const shouldCreateDuplicate = window.confirm("A job recipe with the same part and department already exists. Are you sure you want to create a new job card from this recipe?");
            if (!shouldCreateDuplicate) {
                alert("Job card creation cancelled.");
                return;
            }
        }
        
        try {
            await addJobCard(jobDetails);
            alert(`Job Card ${jobDetails.jobId} created successfully!`);

            const printContents = document.getElementById('job-card-print-area').innerHTML;
            const printWindow = window.open('', '', 'height=800,width=1000');
            printWindow.document.write(`<html><head><title>Print Job Card</title><script src="https://cdn.tailwindcss.com/"></script><style>@media print { body { -webkit-print-color-adjust: exact; } button { display: none; } }</style></head><body><div class="p-8">${printContents}</div><div class="mt-4 text-center"><button onclick="window.print()" style="padding: 10px 20px; background-color: #3b82f6; color: white; border-radius: 8px; border: none; cursor: pointer;">Print This Job Card</button></div></body></html>`);
            printWindow.document.close();
            printWindow.onload = () => {
                setTimeout(() => printWindow.print(), 500);
            };

            handleResetFormAndPreview();
        } catch (error) {
            console.error("Error creating job card:", error);
            alert("Failed to create job card.");
        }
    };

    if (loading) return <p className="text-center text-gray-400">Loading settings data...</p>;

    const renderActionButton = () => {
        if (!jobDetails) return null;
        if (showDefineRecipeForm) {
            return (
                <Button onClick={saveNewRecipeAndCreateJob} variant="primary" disabled={isSavingNewRecipe}>
                    {isSavingNewRecipe ? 'Saving Recipe...' : 'Define Recipe & Create First Job'}
                </Button>
            );
        } else {
            return (
                <div className="flex flex-col sm:flex-row gap-4 justify-center">
                    <Button onClick={handlePrintAndCreate} variant="primary">Print & Create Job</Button>
                    <Button onClick={handleGenerateNewJobCard} variant="secondary">Generate New Job Card</Button>
                </div>
            );
        }
    };

    return (
        <>
            <div className="bg-gray-800 p-6 rounded-xl border border-gray-700 shadow-lg mt-8">
                <h3 className="text-lg font-semibold text-white mb-6 text-center">
                    Create New Job from Catalog
                </h3>
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                    <Dropdown label="1. Manufacturer" name="manufacturerId" value={selection.manufacturerId} onChange={handleSelection} options={allData.manufacturers} placeholder="Select Manufacturer" />
                    <Dropdown label="2. Make" name="makeId" value={selection.makeId} onChange={handleSelection} options={filteredMakes} placeholder="Select Make" disabled={!selection.manufacturerId} />
                    <Dropdown label="3. Model" name="modelId" value={selection.modelId} onChange={handleSelection} options={filteredModels} placeholder="Select Model" disabled={!selection.makeId} />
                    <Dropdown label="4. Part" name="partId" value={selection.partId} onChange={handleSelection} options={filteredParts} placeholder="Select Part" disabled={!selection.modelId} />
                    <Dropdown label="5. Department" name="departmentId" value={selection.departmentId} onChange={handleSelection} options={allData.departments} placeholder="Select Department" />
                    <Dropdown label="6. Employee (Optional)" name="employeeId" value={selection.employeeId} onChange={handleSelection} options={filteredEmployees} placeholder="Select Employee..." disabled={!selection.departmentId} />
                </div>
                {showDefineRecipeForm && selection.partId && selection.departmentId && (
                    <div className="mt-8 p-6 bg-gray-900/50 rounded-lg border border-gray-700 animate-fade-in">
                        <h4 className="text-xl font-bold text-white mb-4">Define Recipe for New Part-Department Combination</h4>
                        <p className="text-gray-400 text-sm mb-4">No standard recipe found. Please define it now to create the first job card and save for future use.</p>
                        <div className="space-y-4">
                            <Input label="Description" name="description" value={tempRecipeDetails.description} onChange={handleTempRecipeInputChange} placeholder="e.g., Final assembly of side skirt" />
                            <Input label="Estimated Time (minutes)" name="estimatedTime" type="number" value={tempRecipeDetails.estimatedTime} onChange={handleTempRecipeInputChange} placeholder="e.g., 45" />
                            <Textarea label="Steps (one per line)" name="steps" value={tempRecipeDetails.steps} onChange={handleTempRecipeInputChange} rows={5} placeholder="1. Align panels...&#10;2. Apply adhesive..." />
                            <div>
                                <h5 className="font-semibold text-white mb-2">Required Tools & Accessories for Recipe</h5>
                                <div className="max-h-40 overflow-y-auto space-y-2 p-3 bg-gray-800 rounded-lg">
                                    {(allData.tools || []).map(tool => (
                                        <div key={tool.id}>
                                            <label className="flex items-center space-x-2 text-sm font-semibold text-gray-200">
                                                <input type="checkbox" checked={tempRecipeDetails.tools.has(tool.id)} onChange={() => handleTempRecipeToolToggle(tool.id)} className="h-4 w-4 rounded bg-gray-700 text-blue-600 focus:ring-blue-500" />
                                                <span>{tool.name}</span>
                                            </label>
                                            {tempRecipeDetails.tools.has(tool.id) && (
                                                <div className="pl-6 mt-1 space-y-1 text-xs border-l-2 border-gray-700">
                                                    {(allData.toolAccessories.filter(acc => acc.toolId === tool.id)).map(accessory => (
                                                        <label key={accessory.id} className="flex items-center space-x-2 text-xs text-gray-300">
                                                            <input type="checkbox" checked={tempRecipeDetails.accessories.has(accessory.id)} onChange={() => handleTempRecipeAccessoryToggle(accessory.id)} className="h-3 w-3 rounded bg-gray-700 text-blue-600 focus:ring-blue-500" />
                                                            <span>{accessory.name}</span>
                                                        </label>
                                                    ))}
                                                </div>
                                            )}
                                        </div>
                                    ))}
                                </div>
                            </div>
                            <div>
                                <RecipeConsumableEditor
                                    consumables={allData.allConsumables}
                                    selectedConsumables={tempRecipeDetails.consumables}
                                    onAdd={handleTempRecipeConsumableAdd}
                                    onRemove={handleTempRecipeConsumableRemove}
                                />
                            </div>
                        </div>
                    </div>
                )}
                {jobDetails && (
                    <div className="mt-8 text-center">
                        {renderActionButton()}
                    </div>
                )}
            </div>
            {jobDetails && <JobCardPreview details={jobDetails} />}
        </>
    );
};

export default JobCardCreator;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\features\qc\QcQueue.jsx
==================================================
import React, { useState, useEffect, useMemo } from 'react';
import { listenToJobCards, processQcDecision } from '../../../api/firestore'; // Use the new function
import Button from '../../ui/Button';

const QcQueue = () => {
  const [allJobs, setAllJobs] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const unsubscribe = listenToJobCards((fetchedJobs) => {
      setAllJobs(fetchedJobs);
      setLoading(false);
    });
    return () => unsubscribe();
  }, []);

  const qcJobs = useMemo(() => {
    return allJobs.filter(job => job.status === 'Awaiting QC');
  }, [allJobs]);

  const handleApprove = async (job) => {
    if (window.confirm(`Are you sure you want to approve this job? This will deduct used items from stock.`)) {
      try {
        await processQcDecision(job, true); // Call with 'true' for approval
        alert('Job approved and stock updated!');
      } catch (err) {
        alert('Failed to process approval.');
        console.error(err);
      }
    }
  };

  const handleReject = async (job) => {
    const reason = prompt(`Please provide a reason for rejecting this job:`);
    if (reason) {
      try {
        await processQcDecision(job, false, reason); // Call with 'false' and a reason for rejection
        alert('Job marked with an issue, and stock has been deducted.');
      } catch (err) {
        alert('Failed to process rejection.');
        console.error(err);
      }
    }
  };

  if (loading) return <p className="text-center text-gray-400">Loading QC queue...</p>;

  return (
    <div className="bg-gray-800 p-2 sm:p-6 rounded-xl border border-gray-700 shadow-lg">
      <div className="overflow-x-auto">
        <table className="w-full text-left">
           <thead>
            <tr className="border-b border-gray-600">
              <th className="p-3 text-sm font-semibold text-gray-400">Job ID</th>
              <th className="p-3 text-sm font-semibold text-gray-400">Part</th>
              <th className="p-3 text-sm font-semibold text-gray-400">Employee</th>
              <th className="p-3 text-sm font-semibold text-gray-400">Actions</th>
            </tr>
          </thead>
          <tbody>
            {(qcJobs || []).map(job => (
              <tr key={job.id} className="border-b border-gray-700 hover:bg-gray-700/50">
                <td className="p-3 text-gray-400 text-xs font-mono">{job.jobId}</td>
                <td className="p-3 text-gray-300">{job.partName}</td>
                <td className="p-3 text-gray-300">{job.employeeName}</td>
                <td className="p-3 flex space-x-2">
                  <Button onClick={() => handleApprove(job)} variant="primary" className="bg-green-600 hover:bg-green-700 py-1 px-3 text-sm">Approve</Button>
                  <Button onClick={() => handleReject(job)} variant="danger" className="py-1 px-3 text-sm">Reject</Button>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
        {qcJobs.length === 0 && !loading && <p className="text-center p-8 text-gray-400">The QC queue is empty.</p>}
      </div>
    </div>
  );
};

export default QcQueue;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\features\scanner\Scanner.jsx
==================================================
import React, { useState } from 'react';
import { getJobByJobId, updateJobStatus } from '../../../api/firestore';
import Input from '../../ui/Input';
import Button from '../../ui/Button';

const Scanner = () => {
  const [jobIdInput, setJobIdInput] = useState('');
  const [foundJob, setFoundJob] = useState(null);
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  const handleFindJob = async (e) => {
    e.preventDefault();
    if (!jobIdInput.trim()) return;
    setLoading(true);
    setError('');
    setFoundJob(null);
    try {
      const job = await getJobByJobId(jobIdInput);
      setFoundJob(job);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  const handleUpdateStatus = async (newStatus) => {
    if (!foundJob) return;
    try {
      await updateJobStatus(foundJob.id, newStatus);
      alert(`Job status for ${foundJob.jobId} updated to "${newStatus}"!`);
      // Reset the scanner for the next job
      setFoundJob(null);
      setJobIdInput('');
      setError('');
    } catch (err) {
      setError("Failed to update status. Please try again.");
      console.error(err);
    }
  };

  return (
    <div className="bg-gray-800 p-6 rounded-xl border border-gray-700 max-w-2xl mx-auto">
      <form onSubmit={handleFindJob} className="flex items-center space-x-4">
        <Input
          name="jobId"
          value={jobIdInput}
          onChange={(e) => setJobIdInput(e.target.value)}
          placeholder="Scan or type Job ID..."
          className="flex-grow"
        />
        <Button type="submit" variant="primary" disabled={loading}>
          {loading ? 'Finding...' : 'Find Job'}
        </Button>
      </form>

      {error && <p className="mt-4 text-center text-red-400">{error}</p>}

      {foundJob && (
        <div className="mt-6 border-t border-gray-700 pt-6">
          <h3 className="text-xl font-bold text-white">{foundJob.partName}</h3>
          <p className="text-gray-400">Assigned to: {foundJob.employeeName}</p>
          <p className="text-gray-400">Current Status: <span className="font-semibold text-yellow-300">{foundJob.status}</span></p>

          <div className="mt-6 grid grid-cols-2 gap-4">
            {/* We can add more logic here later to show/hide buttons based on current status */}
            <Button onClick={() => handleUpdateStatus('In Progress')}>Start Job</Button>
            <Button onClick={() => handleUpdateStatus('Paused')} variant="secondary">Pause</Button>
            <Button onClick={() => handleUpdateStatus('Awaiting QC')} >Complete Job</Button>
          </div>
        </div>
      )}
    </div>
  );
};

export default Scanner;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\features\settings\DatabaseEditor.jsx
==================================================
import React, { useState, useEffect } from 'react';
import Button from '../../ui/Button';
import Input from '../../ui/Input';
import { getDocumentsPaginated, updateDocument, deleteDocument } from '../../../api/firestore';
import { X, Edit, Trash2 } from 'lucide-react';

const PAGE_SIZE = 15;

const collections = [
    'createdJobCards', 'parts', 'models', 'makes', 'manufacturers',
    'employees', 'departments', 'suppliers', 'tools', 'toolAccessories',
    'components', 'rawMaterials', 'workshopSupplies',
    'purchaseQueue', 'jobStepDetails'
].sort();

const CellRenderer = ({ value }) => {
    if (value instanceof Date) { return value.toLocaleDateString(); }
    if (typeof value === 'boolean') { return value ? 'âœ…' : 'âŒ'; }
    if (typeof value === 'object' && value !== null) {
        if (value.toDate instanceof Function) { return value.toDate().toLocaleString(); }
        // Truncate long strings/objects for display in the table
        const jsonString = JSON.stringify(value);
        return <pre className="text-xs bg-gray-900 p-1 rounded max-w-xs overflow-x-auto" title={jsonString}>{jsonString.length > 50 ? `${jsonString.substring(0, 50)}...` : jsonString}</pre>;
    }
    const stringValue = String(value);
    return <span title={stringValue}>{stringValue.length > 50 ? `${stringValue.substring(0, 50)}...` : stringValue}</span>;
};

const EditModal = ({ doc, collectionName, onClose, onSave }) => {
    const [formData, setFormData] = useState({ ...doc });

    const handleInputChange = (e, key) => {
        const { value, type, checked } = e.target;
        // Convert number inputs back to numbers
        const finalValue = type === 'checkbox' ? checked : type === 'number' ? Number(value) : value;
        setFormData(prev => ({ ...prev, [key]: finalValue }));
    };

    const renderInput = (key, value) => {
        if (key === 'id' || (typeof value === 'object' && value !== null)) {
            return <Input value={key === 'id' ? value : JSON.stringify(value)} disabled className="bg-gray-900"/>;
        }
        if (typeof value === 'boolean') {
            return <input type="checkbox" checked={formData[key]} onChange={(e) => handleInputChange(e, key)} className="h-5 w-5 rounded bg-gray-700 text-blue-600 focus:ring-blue-500"/>;
        }
        if (typeof value === 'number') {
            return <Input type="number" value={formData[key]} onChange={(e) => handleInputChange(e, key)} />;
        }
        return <Input value={formData[key]} onChange={(e) => handleInputChange(e, key)} />;
    };

    return (
        <div onClick={onClose} className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 animate-fade-in">
            <div onClick={(e) => e.stopPropagation()} className="bg-gray-800 rounded-xl border border-gray-700 w-full max-w-2xl max-h-[90vh] flex flex-col">
                <div className="flex justify-between items-center p-4 border-b border-gray-700">
                    <h2 className="text-xl font-bold text-white">Edit Document: <span className="text-blue-400">{doc.id}</span></h2>
                    <Button onClick={onClose} variant="secondary" className="p-2"><X size={20} /></Button>
                </div>
                <div className="p-6 overflow-y-auto space-y-4">
                    {Object.keys(formData).map((key) => (
                        <div key={key}>
                            <label className="block text-sm font-medium text-gray-400 mb-1">{key}</label>
                            {renderInput(key, formData[key])}
                        </div>
                    ))}
                </div>
                <div className="p-4 bg-gray-900/50 border-t border-gray-700 flex justify-end">
                    <Button onClick={() => onSave(collectionName, doc.id, formData)} variant="primary">Save Changes</Button>
                </div>
            </div>
        </div>
    );
};


const DatabaseEditor = () => {
    const [selectedCollection, setSelectedCollection] = useState(null);
    const [documents, setDocuments] = useState([]);
    const [headers, setHeaders] = useState([]);
    const [loading, setLoading] = useState(false);
    const [page, setPage] = useState(0);
    const [pageCursors, setPageCursors] = useState([null]);
    const [hasNextPage, setHasNextPage] = useState(false);
    const [editingDoc, setEditingDoc] = useState(null);

    const fetchDocuments = async (collectionName, pageIndex, cursor) => {
        setLoading(true);
        try {
            const { docs, lastVisible } = await getDocumentsPaginated(collectionName, PAGE_SIZE, cursor);
            setDocuments(docs);

            if (docs.length > 0) {
                const allKeys = docs.reduce((acc, doc) => {
                    Object.keys(doc).forEach(key => key !== 'id' && acc.add(key));
                    return acc;
                }, new Set());
                setHeaders(['id', ...Array.from(allKeys).sort()]);
            } else {
                setHeaders([]);
            }

            if (lastVisible) {
                const newCursors = [...pageCursors.slice(0, pageIndex + 1)];
                newCursors[pageIndex + 1] = lastVisible;
                setPageCursors(newCursors);
            }
            setHasNextPage(docs.length === PAGE_SIZE);

        } catch (error) {
            console.error(`Failed to fetch from ${collectionName}:`, error);
            alert(`Could not fetch data from ${collectionName}. See console for details.`);
        } finally {
            setLoading(false);
        }
    };
    
    const handleCollectionSelect = (collectionName) => {
        setSelectedCollection(collectionName);
        setPage(0);
        setPageCursors([null]);
        setDocuments([]);
        setHeaders([]);
        fetchDocuments(collectionName, 0, null);
    };

    const handleNextPage = () => {
        if (!hasNextPage || loading) return;
        const nextPage = page + 1;
        fetchDocuments(selectedCollection, nextPage, pageCursors[nextPage]);
        setPage(nextPage);
    };

    const handlePrevPage = () => {
        if (page === 0 || loading) return;
        const prevPage = page - 1;
        fetchDocuments(selectedCollection, prevPage, pageCursors[prevPage]);
        setPage(prevPage);
    };

    const handleSave = async (collectionName, docId, data) => {
        try {
            await updateDocument(collectionName, docId, data);
            alert("Document updated successfully!");
            setEditingDoc(null);
            fetchDocuments(selectedCollection, page, pageCursors[page]);
        } catch (error) {
            console.error("Failed to update document:", error);
            alert("Error: Could not update document.");
        }
    };

    const handleDelete = async (collectionName, docId) => {
        if (window.confirm("Are you sure you want to PERMANENTLY delete this document? This action cannot be undone.")) {
            try {
                await deleteDocument(collectionName, docId);
                alert("Document deleted successfully!");
                handleCollectionSelect(collectionName); // Refetch the first page
            } catch (error) {
                console.error("Failed to delete document:", error);
                alert("Error: Could not delete document.");
            }
        }
    };

    return (
        <>
            <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
                <div className="lg:col-span-1 bg-gray-800 p-4 rounded-xl border border-gray-700 self-start">
                    <h3 className="text-lg font-bold text-white mb-4">Collections</h3>
                    <div className="space-y-2">
                        {collections.map(name => (
                            <button key={name} onClick={() => handleCollectionSelect(name)} className={`w-full text-left p-2 rounded-md text-sm transition-colors ${selectedCollection === name ? 'bg-blue-600 text-white' : 'bg-gray-700 hover:bg-gray-600'}`}>
                                {name}
                            </button>
                        ))}
                    </div>
                </div>

                <div className="lg:col-span-3 bg-gray-800 p-4 rounded-xl border border-gray-700">
                    <h3 className="text-lg font-bold text-white mb-4">
                        Documents in <span className="text-blue-400">{selectedCollection || '...'}</span>
                    </h3>
                    
                    <div className="overflow-x-auto">
                        <table className="w-full text-left text-sm">
                            <thead>
                                <tr className="bg-gray-900/50">
                                    <th className="p-2 font-semibold sticky left-0 bg-gray-900/50 z-10">Actions</th>
                                    {headers.map(header => <th key={header} className="p-2 font-semibold">{header}</th>)}
                                </tr>
                            </thead>
                            <tbody>
                                {loading ? (
                                    <tr><td colSpan={headers.length + 1} className="text-center p-8 text-gray-400">Loading...</td></tr>
                                ) : documents.length === 0 ? (
                                    <tr><td colSpan={headers.length || 2} className="text-center p-8 text-gray-400">No documents found.</td></tr>
                                ) : (
                                    documents.map(doc => (
                                        <tr key={doc.id} className="border-b border-gray-700 hover:bg-gray-700/50">
                                            <td className="p-2 align-top sticky left-0 bg-gray-800 hover:bg-gray-700/50 flex gap-2">
                                                <Button onClick={() => setEditingDoc(doc)} variant="secondary" className="p-1" title="Edit"><Edit size={14} /></Button>
                                                <Button onClick={() => handleDelete(selectedCollection, doc.id)} variant="danger" className="p-1" title="Delete"><Trash2 size={14} /></Button>
                                            </td>
                                            {headers.map(header => (
                                                <td key={header} className="p-2 align-top"><CellRenderer value={doc[header]}/></td>
                                            ))}
                                        </tr>
                                    ))
                                )}
                            </tbody>
                        </table>
                    </div>

                    <div className="flex justify-between items-center mt-4">
                        <Button onClick={handlePrevPage} disabled={page === 0 || loading}>Previous</Button>
                        <span className="text-gray-400">Page {page + 1}</span>
                        <Button onClick={handleNextPage} disabled={!hasNextPage || loading}>Next</Button>
                    </div>
                </div>
            </div>

            {editingDoc && (
                <EditModal 
                    doc={editingDoc}
                    collectionName={selectedCollection}
                    onClose={() => setEditingDoc(null)}
                    onSave={handleSave}
                />
            )}
        </>
    );
};

export default DatabaseEditor;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\features\settings\DepartmentsManager.jsx
==================================================
import React, { useState, useEffect } from 'react';
import { getDepartments, addDepartment, deleteDepartment, updateDocument } from '../../../api/firestore'; // updateDocument imported
import Input from '../../ui/Input';
import Button from '../../ui/Button';

const DepartmentsManager = () => {
    const [departments, setDepartments] = useState([]);
    const [newDepartmentName, setNewDepartmentName] = useState('');
    const [loading, setLoading] = useState(true);
    const [editingDeptId, setEditingDeptId] = useState(null); // State to track which department is being edited

    const fetchDepartments = async () => {
        setLoading(true);
        const depts = await getDepartments(); // Fetches departments from Firestore 
        setDepartments(depts);
        setLoading(false);
    };

    useEffect(() => {
        fetchDepartments();
    }, []);

    const handleAddOrUpdate = async (e) => {
        e.preventDefault();
        if (!newDepartmentName.trim()) return;

        try {
            if (editingDeptId) {
                // If editingDeptId is set, update the existing department
                await updateDocument('departments', editingDeptId, { name: newDepartmentName }); // Uses updateDocument for generic update 
                alert("Department updated successfully!");
            } else {
                // Otherwise, add a new department
                await addDepartment(newDepartmentName); // Adds new department 
                alert("Department added successfully!");
            }
            setNewDepartmentName(''); // Clear input field
            setEditingDeptId(null); // Exit editing mode
            fetchDepartments(); // Refresh the list of departments
        } catch (error) {
            console.error("Error saving department:", error);
            alert(`Failed to ${editingDeptId ? 'update' : 'add'} department.`);
        }
    };

    const handleEdit = (dept) => {
        setNewDepartmentName(dept.name); // Pre-fill form with department's current name
        setEditingDeptId(dept.id); // Set the ID of the department being edited
    };

    const handleCancelEdit = () => {
        setNewDepartmentName(''); // Clear input field
        setEditingDeptId(null); // Exit editing mode
    };

    const handleDelete = async (id) => {
        if (window.confirm("Are you sure you want to delete this department?")) {
            try {
                await deleteDepartment(id); // Deletes department 
                alert("Department deleted successfully!");
                fetchDepartments(); // Refresh the list
            } catch (error) {
                console.error("Error deleting department:", error);
                alert("Failed to delete department.");
            }
        }
    };

    return (
        <div className="bg-gray-800 p-6 rounded-xl border border-gray-700">
            <h3 className="text-xl font-bold text-white mb-4">Manage Departments</h3>
            <form onSubmit={handleAddOrUpdate} className="flex items-center space-x-4 mb-6">
                <Input
                    name="departmentName"
                    value={newDepartmentName}
                    onChange={(e) => setNewDepartmentName(e.target.value)}
                    placeholder={editingDeptId ? "Edit department name..." : "New department name..."} // Dynamic placeholder
                    className="flex-grow"
                />
                {editingDeptId && ( // Show Cancel button only when in editing mode
                    <Button type="button" variant="secondary" onClick={handleCancelEdit}>
                        Cancel
                    </Button>
                )}
                <Button type="submit" variant="primary">
                    {editingDeptId ? "Update Department" : "Add Department"} {/* Dynamic button text */}
                </Button>
            </form>
            <div className="space-y-3">
                {loading ? (
                    <p>Loading departments...</p>
                ) : (
                    (departments || []).map(dept => (
                        <div key={dept.id} className="flex items-center justify-between bg-gray-700 p-3 rounded-lg">
                            <p className="text-gray-200">{dept.name}</p>
                            <div className="flex space-x-2"> {/* Container for action buttons */}
                                <Button onClick={() => handleEdit(dept)} variant="secondary" className="py-1 px-3 text-xs">
                                    Edit
                                </Button>
                                <Button onClick={() => handleDelete(dept.id)} variant="danger" className="py-1 px-3 text-xs">
                                    Delete
                                </Button>
                            </div>
                        </div>
                    ))
                )}
            </div>
        </div>
    );
};

export default DepartmentsManager;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\features\settings\EmployeeSkillsModal.jsx
==================================================
import React, { useState, useEffect } from 'react';
// 1. IMPORT THE CORRECT, NEW FUNCTION NAME
import { getSkills, getEmployeeSkills, updateEmployeeSkillsAndLogHistory } from '../../../api/firestore';
import Button from '../../ui/Button';
import { X } from 'lucide-react';

const EmployeeSkillsModal = ({ employee, onClose }) => {
    const [allSkills, setAllSkills] = useState([]);
    const [employeeSkills, setEmployeeSkills] = useState({});
    const [loading, setLoading] = useState(true);

    const proficiencyLevels = ['Not Acquired', 'Beginner', 'Intermediate', 'Expert'];

    useEffect(() => {
        const fetchAllData = async () => {
            setLoading(true);
            try {
                const [fetchedSkills, currentSkills] = await Promise.all([
                    getSkills(),
                    getEmployeeSkills(employee.id)
                ]);
                setAllSkills(fetchedSkills);
                setEmployeeSkills(currentSkills || {});
            } catch (error) {
                console.error("Error fetching skills data:", error);
                alert("Failed to load skills data for this employee.");
            }
            setLoading(false);
        };

        if (employee) {
            fetchAllData();
        }
    }, [employee]);

    const handleProficiencyChange = (skillId, newProficiency) => {
        setEmployeeSkills(prevSkills => {
            const updatedSkills = { ...prevSkills };
            if (newProficiency === 'Not Acquired') {
                delete updatedSkills[skillId];
            } else {
                updatedSkills[skillId] = newProficiency;
            }
            return updatedSkills;
        });
    };

    const handleSaveChanges = async () => {
        try {
            // 2. CALL THE NEW FUNCTION WITH THE CORRECT ARGUMENTS
            await updateEmployeeSkillsAndLogHistory(employee, employeeSkills, allSkills);
            alert(`Successfully updated skills for ${employee.name}.`);
            onClose();
        } catch (error) {
            console.error("Error saving employee skills:", error);
            alert("Failed to save skills. Please try again.");
        }
    };

    return (
        <div 
            className="fixed inset-0 bg-black/60 z-50 flex justify-center items-center"
            onClick={onClose}
        >
            <div 
                className="bg-gray-800 w-full max-w-lg rounded-xl shadow-lg border border-gray-700 flex flex-col"
                onClick={e => e.stopPropagation()}
            >
                <div className="flex justify-between items-center p-4 border-b border-gray-600">
                    <h3 className="text-xl font-bold text-white">Manage Skills for {employee.name}</h3>
                    <Button onClick={onClose} variant="icon" className="text-gray-400 hover:text-white">
                        <X size={24} />
                    </Button>
                </div>

                <div className="p-6 space-y-4 overflow-y-auto max-h-[60vh]">
                    {loading ? (
                        <p className="text-gray-300">Loading skills...</p>
                    ) : (
                        allSkills.map(skill => (
                            <div key={skill.id} className="grid grid-cols-2 items-center gap-4">
                                <label className="text-gray-200" htmlFor={`skill-${skill.id}`}>{skill.name}</label>
                                <select
                                    id={`skill-${skill.id}`}
                                    value={employeeSkills[skill.id] || 'Not Acquired'}
                                    onChange={(e) => handleProficiencyChange(skill.id, e.target.value)}
                                    className="bg-gray-900 border border-gray-600 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5"
                                >
                                    {proficiencyLevels.map(level => (
                                        <option key={level} value={level}>{level}</option>
                                    ))}
                                </select>
                            </div>
                        ))
                    )}
                </div>

                <div className="flex justify-end items-center p-4 border-t border-gray-600 bg-gray-800/50 rounded-b-xl">
                    <Button onClick={onClose} variant="secondary" className="mr-2">Cancel</Button>
                    <Button onClick={handleSaveChanges} variant="primary">Save Changes</Button>
                </div>
            </div>
        </div>
    );
};

export default EmployeeSkillsModal;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\features\settings\EmployeesManager.jsx
==================================================
import React, { useState, useEffect } from 'react';
// updateDocument is already imported which is great
import { getEmployees, addEmployee, deleteEmployee, getDepartments, updateDocument } from '../../../api/firestore'; 
import Input from '../../ui/Input';
import Button from '../../ui/Button';
import Dropdown from '../../ui/Dropdown';
import { Award } from 'lucide-react'; // 1. Import an icon for the new button

// 2. Import the (soon to be created) modal component
import EmployeeSkillsModal from './EmployeeSkillsModal'; 

const EmployeesManager = () => {
    const [employees, setEmployees] = useState([]);
    const [departments, setDepartments] = useState([]);
    const [newEmployee, setNewEmployee] = useState({ name: '', departmentId: '', hourlyRate: '' });
    const [loading, setLoading] = useState(true);
    const [editingEmployeeId, setEditingEmployeeId] = useState(null);

    // 3. Add state for the skills modal
    const [isSkillsModalOpen, setIsSkillsModalOpen] = useState(false);
    const [selectedEmployee, setSelectedEmployee] = useState(null);

    const fetchData = async () => {
        setLoading(true);
        const [fetchedEmployees, fetchedDepartments] = await Promise.all([
            getEmployees(),
            getDepartments()
        ]);
        setEmployees(fetchedEmployees);
        setDepartments(fetchedDepartments);
        setLoading(false);
    };

    useEffect(() => { fetchData(); }, []);

    const handleInputChange = (e) => {
        const { name, value } = e.target;
        setNewEmployee(prev => ({ ...prev, [name]: value }));
    };

    const handleAddOrUpdate = async (e) => {
        e.preventDefault();
        if (!newEmployee.name.trim() || !newEmployee.departmentId) {
            alert("Please enter an employee name and select a department.");
            return;
        }

        try {
            const dataToSave = { 
                ...newEmployee, 
                hourlyRate: Number(newEmployee.hourlyRate) || 0 
            };

            if (editingEmployeeId) {
                await updateDocument('employees', editingEmployeeId, dataToSave);
                alert("Employee updated successfully!");
            } else {
                await addEmployee(dataToSave);
                alert("Employee added successfully!");
            }
            setNewEmployee({ name: '', departmentId: '', hourlyRate: '' });
            setEditingEmployeeId(null);
            fetchData();
        } catch (error) {
            console.error("Error saving employee:", error);
            alert(`Failed to ${editingEmployeeId ? 'update' : 'add'} employee.`);
        }
    };

    const handleEdit = (employee) => {
        setNewEmployee({ 
            name: employee.name, 
            departmentId: employee.departmentId, 
            hourlyRate: employee.hourlyRate || ''
        });
        setEditingEmployeeId(employee.id);
    };

    const handleCancelEdit = () => {
        setNewEmployee({ name: '', departmentId: '', hourlyRate: '' });
        setEditingEmployeeId(null);
    };

    const handleDelete = async (id) => {
        if (window.confirm("Are you sure?")) {
            await deleteEmployee(id);
            fetchData();
        }
    };

    // 4. Create a handler to open the skills modal
    const handleManageSkillsClick = (employee) => {
        setSelectedEmployee(employee);
        setIsSkillsModalOpen(true);
    };

    const getDepartmentName = (deptId) => departments.find(d => d.id === deptId)?.name || 'Unknown';

    return (
        <div className="bg-gray-800/50 p-6 rounded-lg border border-gray-700">
            <h3 className="text-xl font-bold text-white mb-4">Manage Employees</h3>
            <form onSubmit={handleAddOrUpdate} className="grid grid-cols-1 md:grid-cols-4 gap-4 items-end mb-6">
                <Input
                    label="Employee Name"
                    name="name"
                    value={newEmployee.name}
                    onChange={handleInputChange}
                    placeholder={editingEmployeeId ? "Edit employee name..." : "New employee name..."}
                />
                <Dropdown
                    label="Department"
                    name="departmentId"
                    value={newEmployee.departmentId}
                    onChange={handleInputChange}
                    options={departments || []}
                    placeholder="Select a department..."
                />
                <Input
                    label="Hourly Rate (R)"
                    name="hourlyRate"
                    type="number"
                    value={newEmployee.hourlyRate}
                    onChange={handleInputChange}
                    placeholder="e.g., 150.50"
                />
                <div className="flex items-center gap-2">
                    {editingEmployeeId && (
                        <Button type="button" variant="secondary" onClick={handleCancelEdit}>
                            Cancel
                        </Button>
                    )}
                    <Button type="submit" variant="primary" className="flex-grow">
                        {editingEmployeeId ? "Update Employee" : "Add Employee"}
                    </Button>
                </div>
            </form>

            <div className="space-y-3">
                {loading ? (
                    <p className="text-gray-400">Loading...</p>
                ) : (employees || []).map(emp => (
                    <div key={emp.id} className="flex items-center justify-between bg-gray-900/50 p-3 rounded-md">
                        <div>
                            <p className="text-gray-200">
                                {emp.name} - <span className="text-gray-400 text-sm">{getDepartmentName(emp.departmentId)}</span>
                                <span className="text-blue-400 font-mono text-sm ml-4">R{(emp.hourlyRate || 0).toFixed(2)}/hr</span>
                            </p>
                        </div>
                        <div className="flex items-center gap-2">
                            {/* 5. Add the new "Manage Skills" button */}
                            <Button onClick={() => handleManageSkillsClick(emp)} variant="secondary" size="sm">
                                <Award size={16} className="mr-1" /> Manage Skills
                            </Button>
                            <Button onClick={() => handleEdit(emp)} variant="secondary" size="sm">
                                Edit
                            </Button>
                            <Button onClick={() => handleDelete(emp.id)} variant="danger" size="sm">Delete</Button>
                        </div>
                    </div>
                ))}
            </div>

            {/* 6. Add the modal component, which will only appear when isSkillsModalOpen is true */}
            {isSkillsModalOpen && selectedEmployee && (
                <EmployeeSkillsModal
                    employee={selectedEmployee}
                    onClose={() => setIsSkillsModalOpen(false)}
                />
            )}
        </div>
    );
};

export default EmployeesManager;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\features\settings\InventoryManager.jsx
==================================================
import React, { useState, useEffect, useMemo } from 'react';
import { getComponents, addComponent, updateComponent, deleteComponent, getRawMaterials, addRawMaterial, updateRawMaterial, deleteRawMaterial, getWorkshopSupplies, addWorkshopSupply, updateWorkshopSupply, deleteWorkshopSupply, getSuppliers } from '../../../api/firestore';
import { useInventoryManager } from '../../../hooks/useInventoryManager';
import Input from '../../ui/Input';
import Button from '../../ui/Button';
import Dropdown from '../../ui/Dropdown';
import { Search, Scale, Hash } from 'lucide-react'; // Import new icons

const StockLevelIndicator = ({ currentStock, reorderLevel, standardStockLevel }) => {
    const stock = Number(currentStock);
    const reorder = Number(reorderLevel);
    const standard = Number(standardStockLevel);
    if (isNaN(stock) || isNaN(reorder) || isNaN(standard) || standard <= reorder) return <div className="text-xs text-gray-500 italic">Not tracked</div>;
    const isLowStock = stock < reorder;
    const range = standard - reorder;
    const stockInRange = stock - reorder;
    const percentage = Math.max(0, Math.min((stockInRange / range) * 100, 100));
    return (
        <div className="w-full">
            <div className="flex justify-between text-xs mb-1">
                <span className="font-semibold text-gray-300">{stock} / {standard}</span>
                <span className={`font-bold ${isLowStock ? 'text-red-400' : 'text-green-400'}`}>{isLowStock ? `Low (Reorder @ ${reorder})` : 'In Stock'}</span>
            </div>
            <div className="w-full bg-gray-600 rounded-full h-2"><div className={`h-2 rounded-full ${isLowStock ? 'bg-red-500' : 'bg-green-500'}`} style={{ width: `${percentage}%` }}></div></div>
        </div>
    );
};

const InventoryManager = () => {
  const [suppliers, setSuppliers] = useState([]);
  const [category, setCategory] = useState('components');

  useEffect(() => {
    const fetchSuppliersData = async () => {
      const fetchedSuppliers = await getSuppliers();
      setSuppliers(fetchedSuppliers);
    };
    fetchSuppliersData();
  }, []);
  
  const apiMap = useMemo(() => ({
    components: { get: getComponents, add: addComponent, update: updateComponent, delete: deleteComponent, categoryName: 'Component' },
    rawMaterials: { get: getRawMaterials, add: addRawMaterial, update: updateRawMaterial, delete: deleteRawMaterial, categoryName: 'Raw Material' },
    workshopSupplies: { get: getWorkshopSupplies, add: addWorkshopSupply, update: updateWorkshopSupply, delete: deleteWorkshopSupply, categoryName: 'Workshop Supply' },
  }), []);

  const manager = useInventoryManager(apiMap[category], suppliers);

  const categoryInfo = {
    components: { desc: 'Discrete parts that go into the final product (e.g., bolts, screws, brackets).', placeholder: 'e.g., 8mm Bolt' },
    rawMaterials: { desc: 'Bulk materials transformed into the product (e.g., resin, paint).', placeholder: 'e.g., Polyester Resin' },
    workshopSupplies: { desc: 'Items used during production but not part of the product (e.g., sandpaper).', placeholder: 'e.g., Sanding Disc' },
  };

  return (
    <div className="bg-gray-800 p-6 rounded-xl border border-gray-700">
      <div className="flex flex-wrap justify-between items-center mb-4 gap-4">
        <h3 className="text-xl font-bold text-white">Manage Inventory Items</h3>
        <select value={category} onChange={e => setCategory(e.target.value)} className="p-2 bg-gray-700 border border-gray-600 rounded-lg text-white">
          <option value="components">Components</option>
          <option value="rawMaterials">Raw Materials</option>
          <option value="workshopSupplies">Workshop Supplies</option>
        </select>
      </div>
      <p className="text-sm text-gray-400 mb-6">{categoryInfo[category].desc}</p>
      
      <form onSubmit={manager.handleSubmit} className="space-y-4 mb-6">
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 items-end">
            <div className="lg:col-span-2"><Input label="Item Name" name="name" value={manager.newItem.name} onChange={manager.handleInputChange} placeholder={categoryInfo[category].placeholder} /></div>
            <div className="lg:col-span-2"><Dropdown label="Supplier" name="supplierId" value={manager.newItem.supplierId} onChange={manager.handleInputChange} options={suppliers} placeholder="Select..." /></div>
            <Input label="Item Code" name="itemCode" value={manager.newItem.itemCode} onChange={manager.handleInputChange} placeholder="Optional" />
            <Input label="Price" name="price" type="number" value={manager.newItem.price} onChange={manager.handleInputChange} placeholder="e.g., 12.50" />
            <Input label="Unit" name="unit" value={manager.newItem.unit} onChange={manager.handleInputChange} placeholder="e.g., each, kg" />
            <div className="grid grid-cols-3 gap-2">
                <Input label="In Stock" name="currentStock" type="number" value={manager.newItem.currentStock} onChange={manager.handleInputChange} placeholder="50" />
                <Input label="Reorder" name="reorderLevel" type="number" value={manager.newItem.reorderLevel} onChange={manager.handleInputChange} placeholder="20" />
                <Input label="Standard" name="standardStockLevel" type="number" value={manager.newItem.standardStockLevel} onChange={manager.handleInputChange} placeholder="200" />
            </div>
        </div>

        <div className="grid grid-cols-1 lg:grid-cols-4 gap-4 items-end p-4 bg-gray-900/50 rounded-lg">
            <div className="lg:col-span-1">
                <label className="block text-sm font-medium text-gray-400 mb-1">Stock Take Method</label>
                <select name="stockTakeMethod" value={manager.newItem.stockTakeMethod || 'quantity'} onChange={manager.handleInputChange} className="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-white">
                    <option value="quantity">By Quantity</option>
                    <option value="weight">By Weight</option>
                </select>
            </div>
            
            {manager.newItem.stockTakeMethod === 'weight' && (
                <>
                    <Input label="Weight per Unit (g)" name="unitWeight" type="number" step="0.01" value={manager.newItem.unitWeight} onChange={manager.handleInputChange} placeholder="e.g., 2.5" />
                    <Input label="Container Tare Weight (g)" name="tareWeight" type="number" step="0.1" value={manager.newItem.tareWeight} onChange={manager.handleInputChange} placeholder="e.g., 36" />
                </>
            )}

            {category === 'rawMaterials' && (
                <div className="flex items-center justify-center h-full pt-6">
                    <label className="flex items-center gap-2 text-sm font-medium text-gray-300">
                        <input type="checkbox" name="requiresCatalyst" checked={manager.newItem.requiresCatalyst || false} onChange={manager.handleInputChange} className="h-5 w-5 rounded bg-gray-700 text-blue-600 focus:ring-blue-500" />
                        Requires Catalyst
                    </label>
                </div>
            )}
        </div>

        <div className="flex justify-end gap-2">
          {manager.editingItemId && <Button type="button" variant="secondary" onClick={manager.cancelEdit}>Cancel</Button>}
          <Button type="submit" variant="primary">{manager.editingItemId ? 'Update Item' : 'Add Item'}</Button>
        </div>
      </form>

      <div className="flex flex-wrap gap-4 items-center mb-4 p-4 bg-gray-900/50 rounded-lg">
        <div className="relative flex-grow">
          <Input name="search-inventory" placeholder="Search by name..." value={manager.searchTerm} onChange={e => manager.setSearchTerm(e.target.value)} />
          <Search className="absolute right-3 top-1/2 -translate-y-1/2 text-gray-400" size={20} />
        </div>
        <div>
          <select name="sort-inventory" value={manager.sortBy} onChange={e => manager.setSortBy(e.target.value)} className="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-white">
            <option value="name-asc">Sort by Name (A-Z)</option>
            <option value="name-desc">Sort by Name (Z-A)</option>
            <option value="supplier">Sort by Supplier</option>
            <option value="stock-low-high">Sort by Stock Level</option>
          </select>
        </div>
        <div className="flex items-center space-x-2 text-white">
          <input type="checkbox" id="lowStockToggle" checked={manager.showLowStock} onChange={e => manager.setShowLowStock(e.target.checked)} className="h-5 w-5 rounded bg-gray-700 text-blue-600 focus:ring-blue-500" />
          <label htmlFor="lowStockToggle" className="text-sm font-medium">Show only low stock</label>
        </div>
      </div>

      <div className="hidden md:grid grid-cols-6 gap-4 px-3 py-2 text-sm font-semibold text-gray-400 border-b border-gray-700">
        <div className="col-span-2">Name</div>
        <div>Supplier</div>
        <div className="col-span-2">Stock Level</div>
        <div>Actions</div>
      </div>
      <div className="space-y-3 mt-2">
        {manager.loading ? <p className="text-center p-4">Loading...</p> : (manager.displayedItems || []).map(item => (
          <div key={item.id} className="grid grid-cols-1 md:grid-cols-6 gap-4 items-center bg-gray-700 p-3 rounded-lg">
            <p className="font-semibold col-span-2 flex items-center gap-2">
                {item.stockTakeMethod === 'weight' ? <Scale size={14} className="text-gray-400" title="Counted by Weight"/> : <Hash size={14} className="text-gray-400" title="Counted by Quantity"/>}
                {item.name}
                {item.requiresCatalyst && <span className="text-xs bg-blue-500/50 text-blue-300 px-2 py-0.5 rounded-full" title="Requires Catalyst">C</span>}
            </p>
            <p>{manager.getSupplierName(item.supplierId)}</p>
            <div className="col-span-2"><StockLevelIndicator {...item} /></div>
            <div className="flex items-center justify-end gap-2">
              <Button onClick={() => manager.handleEdit(item)} variant="secondary" className="py-1 px-3 text-xs">Edit</Button>
              <Button onClick={() => manager.handleDelete(item.id)} variant="danger" className="py-1 px-3 text-xs">Delete</Button>
            </div>
          </div>
        ))}
         {(manager.displayedItems || []).length === 0 && !manager.loading && <p className="text-center p-4 text-gray-500">No items found.</p>}
      </div>
    </div>
  );
};

export default InventoryManager;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\features\settings\MasterProductManager.jsx
==================================================
// src/components/features/settings/MasterProductManager.jsx (New File)

import React, { useState, useEffect, useMemo } from 'react';
import { 
    getMasterProducts, addMasterProduct, deleteMasterProduct, updateMasterProduct,
    getLinkedRecipesForMasterProduct, linkRecipeToMasterProduct, unlinkRecipeFromMasterProduct,
    getParts, getDepartments 
} from '../../../api/firestore';
import Button from '../../ui/Button';
import Input from '../../ui/Input';
import Dropdown from '../../ui/Dropdown';
import { Trash2, Link as LinkIcon, X } from 'lucide-react';

const MasterProductManager = () => {
    // State for data from Firestore
    const [masterProducts, setMasterProducts] = useState([]);
    const [parts, setParts] = useState([]);
    const [departments, setDepartments] = useState([]);
    const [linkedRecipes, setLinkedRecipes] = useState([]);
    const [loading, setLoading] = useState(true);

    // State for UI control
    const [selectedProductId, setSelectedProductId] = useState(null);
    const [newProductName, setNewProductName] = useState('');
    const [newProductDescription, setNewProductDescription] = useState('');

    // State for linking form
    const [partToLinkId, setPartToLinkId] = useState('');
    const [departmentToLinkId, setDepartmentToLinkId] = useState('');

    // Fetch initial data
    const fetchData = async () => {
        setLoading(true);
        const [products, fetchedParts, fetchedDepartments] = await Promise.all([
            getMasterProducts(),
            getParts(),
            getDepartments()
        ]);
        setMasterProducts(products);
        setParts(fetchedParts);
        setDepartments(fetchedDepartments);
        setLoading(false);
    };

    useEffect(() => {
        fetchData();
    }, []);

    // Fetch linked recipes whenever a master product is selected
    useEffect(() => {
        if (selectedProductId) {
            const fetchLinks = async () => {
                const links = await getLinkedRecipesForMasterProduct(selectedProductId);
                setLinkedRecipes(links);
            };
            fetchLinks();
        } else {
            setLinkedRecipes([]);
        }
    }, [selectedProductId]);

    const selectedMasterProduct = useMemo(() => {
        return masterProducts.find(p => p.id === selectedProductId);
    }, [selectedProductId, masterProducts]);

    // Handlers
    const handleAddMasterProduct = async (e) => {
        e.preventDefault();
        if (!newProductName.trim()) return alert('Product name is required.');
        await addMasterProduct({ name: newProductName, description: newProductDescription });
        setNewProductName('');
        setNewProductDescription('');
        fetchData();
    };

    const handleDeleteMasterProduct = async (productId) => {
        if (window.confirm("Are you sure you want to delete this master product and all its links? This cannot be undone.")) {
            await deleteMasterProduct(productId);
            setSelectedProductId(null);
            fetchData();
        }
    };

    const handleLinkRecipe = async (e) => {
        e.preventDefault();
        if (!partToLinkId || !departmentToLinkId) return alert('Please select a part and a department.');
        
        const partName = parts.find(p => p.id === partToLinkId)?.name || 'Unknown Part';
        const departmentName = departments.find(d => d.id === departmentToLinkId)?.name || 'Unknown Dept';
        const jobStepDetailId = `${partToLinkId}_${departmentToLinkId}`;

        await linkRecipeToMasterProduct({
            masterProductId: selectedProductId,
            jobStepDetailId,
            partId: partToLinkId,
            departmentId: departmentToLinkId,
            partName,
            departmentName
        });
        
        const links = await getLinkedRecipesForMasterProduct(selectedProductId);
        setLinkedRecipes(links);
        setPartToLinkId('');
        setDepartmentToLinkId('');
    };

    const handleUnlinkRecipe = async (linkId) => {
        await unlinkRecipeFromMasterProduct(linkId);
        const links = await getLinkedRecipesForMasterProduct(selectedProductId);
        setLinkedRecipes(links);
    };

    if (loading) return <p className="text-gray-400">Loading Master Product Manager...</p>;

    return (
        <div className="bg-gray-800 p-6 rounded-xl border border-gray-700">
            <h3 className="text-2xl font-bold text-white mb-6">Master Product Manager</h3>
            <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
                {/* Left Column: List and Add Form */}
                <div className="lg:col-span-1 space-y-6">
                    <div>
                        <h4 className="font-bold text-lg text-white mb-2">Master Product List</h4>
                        <div className="space-y-2 max-h-96 overflow-y-auto pr-2">
                            {masterProducts.map(product => (
                                <div 
                                    key={product.id}
                                    onClick={() => setSelectedProductId(product.id)}
                                    className={`p-3 rounded-md cursor-pointer transition-colors ${selectedProductId === product.id ? 'bg-blue-600 text-white' : 'bg-gray-700 hover:bg-gray-600'}`}
                                >
                                    <p className="font-semibold">{product.name}</p>
                                    <p className="text-xs opacity-70">{product.description}</p>
                                </div>
                            ))}
                        </div>
                    </div>
                    <form onSubmit={handleAddMasterProduct} className="space-y-4 border-t border-gray-700 pt-6">
                        <h4 className="font-bold text-lg text-white">Add New Master Product</h4>
                        <Input label="Product Name" value={newProductName} onChange={e => setNewProductName(e.target.value)} placeholder="e.g., Volvo Cab Extender"/>
                        <Input label="Description" value={newProductDescription} onChange={e => setNewProductDescription(e.target.value)} placeholder="A brief description"/>
                        <Button type="submit" variant="primary" className="w-full">Create Product</Button>
                    </form>
                </div>

                {/* Right Column: Editor */}
                <div className="lg:col-span-2">
                    {selectedMasterProduct ? (
                        <div className="space-y-6">
                            <div>
                                <h4 className="text-xl font-bold text-blue-400">{selectedMasterProduct.name}</h4>
                                <p className="text-gray-400">{selectedMasterProduct.description}</p>
                            </div>

                            {/* Linked Recipes List */}
                            <div className="space-y-3">
                                <h5 className="font-semibold text-white">Linked Recipes ({linkedRecipes.length})</h5>
                                {linkedRecipes.length > 0 ? (
                                    linkedRecipes.map(link => (
                                        <div key={link.id} className="flex items-center justify-between bg-gray-700/50 p-3 rounded-lg">
                                            <div>
                                                <p className="font-semibold text-gray-200">{link.partName}</p>
                                                <p className="text-xs text-gray-400">{link.departmentName} Department</p>
                                            </div>
                                            <Button onClick={() => handleUnlinkRecipe(link.id)} variant="danger" size="sm" className="p-2">
                                                <X size={16}/>
                                            </Button>
                                        </div>
                                    ))
                                ) : (
                                    <p className="text-sm text-gray-500">No recipes linked yet.</p>
                                )}
                            </div>

                            {/* Link New Recipe Form */}
                            <form onSubmit={handleLinkRecipe} className="space-y-3 border-t border-gray-700 pt-6">
                                <h5 className="font-semibold text-white">Link New Recipe</h5>
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    <Dropdown label="Select Part" value={partToLinkId} onChange={e => setPartToLinkId(e.target.value)} options={parts} placeholder="Choose a part..."/>
                                    <Dropdown label="Select Department" value={departmentToLinkId} onChange={e => setDepartmentToLinkId(e.target.value)} options={departments} placeholder="Choose a department..."/>
                                </div>
                                <Button type="submit" variant="secondary" className="w-full"><LinkIcon size={16} className="mr-2"/>Link Recipe to Master Product</Button>
                            </form>

                             <div className="text-right border-t border-gray-700 pt-6">
                                <Button onClick={() => handleDeleteMasterProduct(selectedProductId)} variant="danger">
                                    <Trash2 size={16} className="mr-2"/> Delete Master Product
                                </Button>
                            </div>
                        </div>
                    ) : (
                        <div className="flex items-center justify-center h-full bg-gray-900/50 p-6 rounded-xl border-2 border-dashed border-gray-700 text-gray-500">
                           <p>Select a Master Product from the list on the left to manage its recipes.</p>
                       </div>
                    )}
                </div>
            </div>
        </div>
    );
};

export default MasterProductManager;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\features\settings\OverheadsManager.jsx
==================================================
import React, { useState, useEffect } from 'react';
import { 
    getOverheadCategories, addOverheadCategory, updateOverheadCategory, deleteOverheadCategory,
    getOverheadExpenses, addOverheadExpense, updateOverheadExpense, deleteOverheadExpense 
} from '../../../api/firestore'; 
import Input from '../../ui/Input';
import Button from '../../ui/Button';
import { ChevronDown, ChevronRight, FilePlus } from 'lucide-react'; 


const OverheadsManager = () => {
    // State for Categories
    const [overheadCategories, setOverheadCategories] = useState([]);
    const [newCategoryName, setNewCategoryName] = useState('');
    const [editingCategoryId, setEditingCategoryId] = useState(null);

    // State for Expenses within a selected category
    const [selectedCategoryId, setSelectedCategoryId] = useState(null);
    const [selectedCategoryName, setSelectedCategoryName] = useState(''); // To display name of selected category
    const [overheadExpenses, setOverheadExpenses] = useState([]);
    const [newExpense, setNewExpense] = useState({ name: '', amount: '' });
    const [editingExpenseId, setEditingExpenseId] = useState(null);

    const [loadingCategories, setLoadingCategories] = useState(true);
    const [loadingExpenses, setLoadingExpenses] = useState(false); 

    // --- Category Input Change Handler ---
    const handleCategoryInputChange = (e) => { // Renamed for clarity
        setNewCategoryName(e.target.value);
    };

    // --- Category Management ---
    const fetchOverheadCategories = async () => {
        setLoadingCategories(true);
        try {
            const fetchedCategories = await getOverheadCategories();
            setOverheadCategories(fetchedCategories);
        } catch (error) {
            console.error("Error fetching overhead categories:", error);
            alert("Failed to load overhead categories.");
        } finally {
            setLoadingCategories(false);
        }
    };

    useEffect(() => {
        fetchOverheadCategories();
    }, []);

    const handleAddOrUpdateCategory = async (e) => {
        e.preventDefault();
        if (!newCategoryName.trim()) {
            alert("Category name is required.");
            return;
        }

        try {
            const dataToSave = { name: newCategoryName.trim() };
            if (editingCategoryId) {
                await updateOverheadCategory(editingCategoryId, dataToSave);
                alert("Category updated successfully!");
            } else {
                await addOverheadCategory(dataToSave);
                alert("Category added successfully!");
            }
            setNewCategoryName('');
            setEditingCategoryId(null);
            fetchOverheadCategories(); 
        } catch (error) {
            console.error("Error saving category:", error);
            alert(`Failed to ${editingCategoryId ? 'update' : 'add'} category.`);
        }
    };

    const handleEditCategory = (category) => {
        setNewCategoryName(category.name);
        setEditingCategoryId(category.id);
    };

    const handleCancelEditCategory = () => {
        setNewCategoryName('');
        setEditingCategoryId(null);
    };

    const handleDeleteCategory = async (categoryId) => {
        if (window.confirm("Are you sure you want to delete this category and ALL its associated expenses? This action cannot be undone.")) {
            try {
                await deleteOverheadCategory(categoryId);
                alert("Category and its expenses deleted successfully!");
                fetchOverheadCategories(); 
                if (selectedCategoryId === categoryId) {
                    setSelectedCategoryId(null);
                    setSelectedCategoryName('');
                    setOverheadExpenses([]);
                }
            } catch (error) {
                console.error("Error deleting category:", error);
                alert("Failed to delete category.");
            }
        }
    };

    const handleSelectCategory = (categoryId, categoryName) => {
        // Toggle selection: if already selected, deselect. Otherwise, select.
        if (selectedCategoryId === categoryId) {
            setSelectedCategoryId(null);
            setSelectedCategoryName('');
            setOverheadExpenses([]);
        } else {
            setSelectedCategoryId(categoryId);
            setSelectedCategoryName(categoryName);
            // Also reset expense form state when new category is selected
            setNewExpense({ name: '', amount: '' });
            setEditingExpenseId(null);
        }
    };

    // --- Expense Input Change Handler (NEW) ---
    const handleExpenseInputChange = (e) => {
        const { name, value } = e.target;
        setNewExpense(prev => ({ ...prev, [name]: value }));
    };

    // --- Expense Management (within selected category) ---
    const fetchOverheadExpenses = async () => {
        if (!selectedCategoryId) return;
        setLoadingExpenses(true);
        try {
            const fetchedExpenses = await getOverheadExpenses(selectedCategoryId);
            setOverheadExpenses(fetchedExpenses);
        } catch (error) {
            console.error("Error fetching overhead expenses:", error);
            alert("Failed to load expenses for this category.");
        } finally {
            setLoadingExpenses(false);
        }
    };

    // Fetch expenses whenever selectedCategoryId changes
    useEffect(() => {
        fetchOverheadExpenses();
    }, [selectedCategoryId]); 

    const handleAddOrUpdateExpense = async (e) => {
        e.preventDefault();
        if (!selectedCategoryId) {
            alert("Please select an overhead category first.");
            return;
        }
        if (!newExpense.name.trim() || newExpense.amount === '' || parseFloat(newExpense.amount) < 0) {
            alert("Please enter a valid expense name and a positive amount.");
            return;
        }

        try {
            const dataToSave = {
                name: newExpense.name.trim(),
                amount: parseFloat(newExpense.amount)
            };

            if (editingExpenseId) {
                await updateOverheadExpense(selectedCategoryId, editingExpenseId, dataToSave);
                alert("Expense updated successfully!");
            } else {
                await addOverheadExpense(selectedCategoryId, dataToSave);
                alert("Expense added successfully!");
            }
            setNewExpense({ name: '', amount: '' }); // Reset form
            setEditingExpenseId(null); // Clear editing state
            fetchOverheadExpenses(); // Refresh expenses list
        } catch (error) {
            console.error("Error saving expense:", error);
            alert(`Failed to ${editingExpenseId ? 'update' : 'add'} expense.`);
        }
    };

    const handleEditExpense = (expense) => {
        setNewExpense({
            name: expense.name,
            amount: expense.amount || ''
        });
        setEditingExpenseId(expense.id);
    };

    const handleCancelEditExpense = () => {
        setNewExpense({ name: '', amount: '' });
        setEditingExpenseId(null);
    };

    const handleDeleteExpense = async (expenseId) => {
        if (window.confirm("Are you sure you want to delete this expense?")) {
            try {
                await deleteOverheadExpense(selectedCategoryId, expenseId);
                alert("Expense deleted successfully!");
                fetchOverheadExpenses(); 
            } catch (error) {
                console.error("Error deleting expense:", error);
                alert("Failed to delete expense.");
            }
        }
    };

    // Calculate total for selected category for display
    const totalSelectedCategoryCost = overheadExpenses.reduce((sum, exp) => sum + (exp.amount || 0), 0);
    

    return (
        <div className="bg-gray-800 p-6 rounded-xl border border-gray-700">
            <h3 className="text-xl font-bold text-white mb-4">Manage Overheads & Fixed Costs</h3>

            {/* --- Overhead Categories Section --- */}
            <h4 className="text-lg font-semibold text-white mb-3 flex items-center">
                <FilePlus size={18} className="mr-2 text-blue-400"/>
                Overhead Categories
            </h4>
            <form onSubmit={handleAddOrUpdateCategory} className="flex items-center space-x-4 mb-6 p-4 bg-gray-900/50 rounded-lg">
                <Input
                    label="Category Name" // Changed label for clarity
                    name="categoryName"
                    value={newCategoryName}
                    onChange={handleCategoryInputChange} // Use specific handler
                    placeholder={editingCategoryId ? "Edit category name..." : "New category name (e.g., Rent & Utilities)"}
                    className="flex-grow"
                />
                {editingCategoryId && (
                    <Button type="button" variant="secondary" onClick={handleCancelEditCategory}>
                        Cancel
                    </Button>
                )}
                <Button type="submit" variant="primary">
                    {editingCategoryId ? "Update Category" : "Add Category"}
                </Button>
            </form>

            <div className="space-y-3 mb-8">
                {loadingCategories ? (
                    <p>Loading categories...</p>
                ) : (overheadCategories || []).length === 0 ? (
                    <p className="text-center p-4 text-gray-500">No overhead categories added yet.</p>
                ) : (
                    (overheadCategories || []).map(category => (
                        <div key={category.id} className="bg-gray-700 p-3 rounded-lg">
                            <div className="flex items-center justify-between">
                                <button 
                                    onClick={() => handleSelectCategory(category.id, category.name)} 
                                    className="flex-grow text-left text-gray-200 font-semibold flex items-center py-1"
                                >
                                    {selectedCategoryId === category.id ? <ChevronDown size={18} className="mr-2"/> : <ChevronRight size={18} className="mr-2"/>}
                                    {category.name}
                                </button>
                                <div className="flex space-x-2">
                                    <Button onClick={() => handleEditCategory(category)} variant="secondary" className="py-1 px-3 text-xs">Edit</Button>
                                    <Button onClick={() => handleDeleteCategory(category.id)} variant="danger" className="py-1 px-3 text-xs">Delete</Button>
                                </div>
                            </div>

                            {/* --- Individual Expenses Section (Conditional) --- */}
                            {selectedCategoryId === category.id && (
                                <div className="mt-4 p-4 bg-gray-800 rounded-lg animate-fade-in border border-gray-700">
                                    <h5 className="font-semibold text-gray-200 mb-3 border-b border-gray-700 pb-2">
                                        Expenses for {selectedCategoryName} (Total: R{totalSelectedCategoryCost.toFixed(2)})
                                    </h5>

                                    {/* Form to add/edit expenses */}
                                    <form onSubmit={handleAddOrUpdateExpense} className="grid grid-cols-1 md:grid-cols-3 gap-3 items-end mb-4">
                                        <Input
                                            label="Expense Name"
                                            name="name"
                                            value={newExpense.name}
                                            onChange={handleExpenseInputChange} // Use specific handler for expenses
                                            placeholder={editingExpenseId ? "Edit expense name..." : "e.g., Ranos Rent"}
                                        />
                                        <Input
                                            label="Amount (R)"
                                            name="amount"
                                            type="number"
                                            value={newExpense.amount}
                                            onChange={handleExpenseInputChange} // Use specific handler for expenses
                                            placeholder="e.g., 2000.00"
                                        />
                                        {editingExpenseId && (
                                            <Button type="button" variant="secondary" onClick={handleCancelEditExpense}>
                                                Cancel
                                            </Button>
                                        )}
                                        <Button type="submit" variant="primary">
                                            {editingExpenseId ? "Update Expense" : "Add Expense"}
                                        </Button>
                                    </form>

                                    {/* List of expenses */}
                                    <div className="space-y-2 max-h-48 overflow-y-auto mt-4 pt-4 border-t border-gray-700">
                                        {loadingExpenses ? (
                                            <p>Loading expenses...</p>
                                        ) : (overheadExpenses || []).length === 0 ? (
                                            <p className="text-gray-400 text-sm">No expenses in this category yet.</p>
                                        ) : (
                                            (overheadExpenses || []).map(expense => (
                                                <div key={expense.id} className="flex items-center justify-between bg-gray-700 p-2 rounded-md">
                                                    <p className="text-gray-200">{expense.name}</p>
                                                    <p className="text-gray-400 text-right">R {(expense.amount || 0).toFixed(2)}</p>
                                                    <div className="flex space-x-2">
                                                        <Button onClick={() => handleEditExpense(expense)} variant="secondary" className="py-0.5 px-2 text-xs">Edit</Button>
                                                        <Button onClick={() => handleDeleteExpense(expense.id)} variant="danger" className="py-0.5 px-2 text-xs">Delete</Button>
                                                    </div>
                                                </div>
                                            ))
                                        )}
                                    </div>
                                </div>
                            )}
                        </div>
                    ))
                )}
            </div>
        </div>
    );
};

export default OverheadsManager;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\features\settings\ProductRecipeManager.jsx
==================================================
// src/components/features/settings/ProductRecipeManager.jsx (Fully Updated)

import React, { useState, useEffect, useMemo } from 'react';
import { getManufacturers, addManufacturer, getMakes, addMake, getModels, addModel, getParts, addPart, updatePart, getDepartments, getTools, getToolAccessories, getAllInventoryItems, getJobStepDetails, setJobStepDetail } from '../../../api/firestore';
import Button from '../../ui/Button';
import Dropdown from '../../ui/Dropdown';
import Input from '../../ui/Input';
import Textarea from '../../ui/Textarea';
import { FilePlus, Copy } from 'lucide-react';

const ConsumableEditor = ({ consumables, selectedConsumables, onAdd, onRemove }) => {
    const [consumableType, setConsumableType] = useState('fixed');
    const [fixedId, setFixedId] = useState('');
    const [fixedQty, setFixedQty] = useState('');
    const [dimId, setDimId] = useState('');
    const [cuts, setCuts] = useState([]);
    const [cutRule, setCutRule] = useState({ dimensions: '', notes: '' });
    const handleAddConsumable = () => {
        let newConsumable;
        switch (consumableType) {
            case 'fixed':
                if (!fixedId || !fixedQty) return alert("Please select an item and enter a quantity.");
                newConsumable = { type: 'fixed', itemId: fixedId, quantity: Number(fixedQty) };
                break;
            case 'dimensional':
                if (!dimId || cuts.length === 0) return alert("Please select a material and add at least one cutting instruction.");
                newConsumable = { type: 'dimensional', itemId: dimId, cuts };
                break;
            default: return;
        }

        if (!selectedConsumables.find(c => c.itemId === newConsumable.itemId)) {
            onAdd(newConsumable);
            setFixedId(''); setFixedQty('');
            setDimId(''); setCuts([]); setCutRule({ dimensions: '', notes: '' });
        } else {
            alert("This consumable has already been added to the recipe.");
        }
    };

    const getConsumableName = (id) => consumables.find(c => c.id === id)?.name || 'Unknown Item';
    return (
        <div>
            <h4 className="font-semibold mb-2">Required Consumables</h4>
            <div className="p-4 bg-gray-900/50 rounded-lg space-y-4">
                <div className="flex gap-2 bg-gray-800 p-1 rounded-md">
                    <button type="button" onClick={() => setConsumableType('fixed')} className={`flex-1 p-2 text-sm rounded transition-colors ${consumableType === 'fixed' ? 'bg-blue-600 text-white' : 'hover:bg-blue-500/20'}`}>Fixed Quantity</button>
                    <button type="button" onClick={() => setConsumableType('dimensional')} className={`flex-1 p-2 text-sm rounded transition-colors ${consumableType === 'dimensional' ? 'bg-blue-600 text-white' : 'hover:bg-blue-500/20'}`}>Dimensional Cuts</button>
                </div>

                {consumableType === 'fixed' && (
                    <div className="flex items-end gap-2 animate-fade-in">
                        <div className="flex-grow"><Dropdown label="Item" value={fixedId} onChange={e => setFixedId(e.target.value)} options={consumables} placeholder="Select..."/></div>
                        <div className="w-24"><Input label="Qty" type="number" value={fixedQty} onChange={e => setFixedQty(e.target.value)} placeholder="e.g., 5"/></div>
                        <Button type="button" onClick={handleAddConsumable}>Add</Button>
                    </div>
                )}
                
                {consumableType === 'dimensional' && (
                     <div className="space-y-3 animate-fade-in">
                        <Dropdown label="Material to Cut" value={dimId} onChange={e => setDimId(e.target.value)} options={consumables.filter(c => c.name.toLowerCase().includes('mat'))} placeholder="Select mat..."/>
                        <div className="p-2 border border-gray-700 rounded-md">
                             <p className="text-xs text-gray-400 mb-2">Cutting Instructions</p>
                            <div className="flex items-end gap-2">
                                <Input label="Dimensions (e.g., 120cm x 80cm)" value={cutRule.dimensions} onChange={e => setCutRule({...cutRule, dimensions: e.target.value})} />
                                <Input label="Notes" value={cutRule.notes} onChange={e => setCutRule({...cutRule, notes: e.target.value})} />
                                <Button type="button" onClick={() => { if(cutRule.dimensions) { setCuts([...cuts, cutRule]); setCutRule({ dimensions: '', notes: '' }); }}}>Add Cut</Button>
                            </div>
                            <ul className="text-xs mt-2 space-y-1">{cuts.map((c, i) => <li key={i}>{c.dimensions} ({c.notes})</li>)}</ul>
                        </div>
                        <Button type="button" onClick={handleAddConsumable} className="w-full">Add Dimensional Consumable</Button>
                    </div>
                )}

                <h5 className="text-sm font-bold pt-2 border-t border-gray-700">Recipe Consumables</h5>
                <ul className="space-y-2 max-h-40 overflow-y-auto">
                    {selectedConsumables.map((c, i) => (
                        <li key={i} className="flex justify-between items-center bg-gray-700 p-2 rounded text-sm">
                            <div>
                                <p className="font-semibold">{getConsumableName(c.itemId)}</p>
                                {c.type === 'fixed' && <p className="text-xs text-gray-400">Qty: {c.quantity}</p>}
                                {c.type === 'dimensional' && <p className="text-xs text-gray-400">{c.cuts.length} cut(s) required</p>}
                            </div>
                            <Button type="button" onClick={() => onRemove(c.itemId)} variant="danger" className="py-0.5 px-2 text-xs">X</Button>
                        </li>
                    ))}
                </ul>
            </div>
        </div>
    );
};

const PartEditor = ({ part, departments, tools, toolAccessories, consumables, allJobSteps, onSaveRecipe, onPartUpdate, recipeToClone, onCloneComplete }) => {
  const [activeTab, setActiveTab] = useState('details');
  const [selectedDepartmentId, setSelectedDepartmentId] = useState('');
  const [description, setDescription] = useState('');
  const [estimatedTime, setEstimatedTime] = useState('');
  const [steps, setSteps] = useState('');
  const [selectedTools, setSelectedTools] = useState(new Set());
  const [selectedAccessories, setSelectedAccessories] = useState(new Set());
  const [selectedConsumables, setSelectedConsumables] = useState([]);
  const [partName, setPartName] = useState(part.name);
  const [partPhotoUrl, setPartPhotoUrl] = useState(part.photoUrl || '');

  useEffect(() => {
    setPartName(part.name);
    setPartPhotoUrl(part.photoUrl || '');
    setActiveTab('details');
    setSelectedDepartmentId('');
  }, [part]);

  useEffect(() => {
    if (selectedDepartmentId) {
      // If a recipe is being cloned, use its data to pre-fill the form
      if (recipeToClone) {
        setDescription(recipeToClone.description || '');
        setEstimatedTime(recipeToClone.estimatedTime || '');
        setSteps((recipeToClone.steps || []).join('\n'));
        setSelectedTools(new Set(recipeToClone.tools || []));
        setSelectedAccessories(new Set(recipeToClone.accessories || []));
        setSelectedConsumables(recipeToClone.consumables || []);
        onCloneComplete(); // Important: signal that the clone data has been used
      } else {
        // Otherwise, load existing recipe for the selected part and department
        const existingStep = allJobSteps.find(step => step.partId === part.id && step.departmentId === selectedDepartmentId);
        if (existingStep) {
            setDescription(existingStep.description || '');
            setEstimatedTime(existingStep.estimatedTime || '');
            setSteps((existingStep.steps || []).join('\n'));
            setSelectedTools(new Set(existingStep.tools || []));
            setSelectedAccessories(new Set(existingStep.accessories || []));
            setSelectedConsumables(existingStep.consumables || []);
        } else {
            setDescription(''); setEstimatedTime(''); setSteps('');
            setSelectedTools(new Set()); setSelectedAccessories(new Set()); setSelectedConsumables([]);
        }
      }
    }
  }, [selectedDepartmentId, part.id, allJobSteps, recipeToClone]);

  const handleSavePartDetails = () => onPartUpdate(part.id, { name: partName, photoUrl: partPhotoUrl });
  const handleSaveRecipeDetails = () => {
    const recipeData = { description, estimatedTime: Number(estimatedTime), steps: steps.split('\n').filter(s => s.trim() !== ''), tools: Array.from(selectedTools), accessories: Array.from(selectedAccessories), consumables: selectedConsumables };
    onSaveRecipe(part.id, selectedDepartmentId, recipeData);
  };
  
  const handleToolToggle = (toolId) => {
    const newTools = new Set(selectedTools);
    if (newTools.has(toolId)) {
        newTools.delete(toolId);
        const accessoriesOfTool = toolAccessories.filter(a => a.toolId === toolId).map(a => a.id);
        const newAccessories = new Set(selectedAccessories);
        accessoriesOfTool.forEach(accId => newAccessories.delete(accId));
        setSelectedAccessories(newAccessories);
    } else { newTools.add(toolId); }
    setSelectedTools(newTools);
  };

  const handleAccessoryToggle = (accId) => {
      const newAccessories = new Set(selectedAccessories);
      newAccessories.has(accId) ? newAccessories.delete(accId) : newAccessories.add(accId);
      setSelectedAccessories(newAccessories);
  };

  const handleAddConsumableToList = (consumable) => setSelectedConsumables([...selectedConsumables, consumable]);
  const handleRemoveConsumableFromList = (itemId) => setSelectedConsumables(selectedConsumables.filter(c => c.itemId !== itemId));

  return (
    <div className="bg-gray-800 p-6 rounded-xl border border-gray-700">
        <h3 className="text-2xl font-bold text-white mb-4">Dossier: <span className="text-blue-400">{part.name}</span></h3>
        <div className="flex border-b border-gray-600 mb-6">
            <button onClick={() => setActiveTab('details')} className={`px-4 py-2 text-sm font-medium ${activeTab === 'details' ? 'border-b-2 border-blue-500 text-white' : 'text-gray-400'}`}>Part Details</button>
            <button onClick={() => setActiveTab('recipe')} className={`px-4 py-2 text-sm font-medium ${activeTab === 'recipe' ? 'border-b-2 border-blue-500 text-white' : 'text-gray-400'}`}>Recipe Book</button>
        </div>

        {activeTab === 'details' && ( <div className="space-y-4 animate-fade-in"> <Input label="Part Name" value={partName} onChange={e => setPartName(e.target.value)} /> <Input label="Photo URL" value={partPhotoUrl} onChange={e => setPartPhotoUrl(e.target.value)} placeholder="https://example.com/image.png" /> <Button onClick={handleSavePartDetails} variant="primary">Save Part Details</Button> </div> )}
        {activeTab === 'recipe' && (
            <div className="space-y-6 animate-fade-in">
                <Dropdown label="Select a Department to Define its Recipe" value={selectedDepartmentId} onChange={e => setSelectedDepartmentId(e.target.value)} options={departments} placeholder="Choose department..."/>
                 {selectedDepartmentId && (
                     <div className="space-y-6 border-t border-gray-700 pt-6">
                        <Input label="Description" value={description} onChange={e => setDescription(e.target.value)} placeholder="e.g., Final assembly of side skirt" />
                        <Input label="Estimated Time (minutes)" type="number" value={estimatedTime} onChange={e => setEstimatedTime(e.target.value)} placeholder="e.g., 45" />
                        <Textarea label="Steps (one per line)" value={steps} onChange={e => setSteps(e.target.value)} rows={5} placeholder="1. Align panels..." />
                        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                           <div>
                                <h4 className="font-semibold mb-2">Required Tools & Accessories</h4>
                                <div className="max-h-60 overflow-y-auto space-y-3 p-4 bg-gray-900/50 rounded-lg">
                                {(tools || []).map(tool => ( <div key={tool.id}> <label className="flex items-center space-x-2 text-sm font-semibold"> <input type="checkbox" checked={selectedTools.has(tool.id)} onChange={() => handleToolToggle(tool.id)} /> <span>{tool.name}</span> </label> {selectedTools.has(tool.id) && ( <div className="pl-8 mt-2 space-y-2 border-l-2 border-gray-700"> {(toolAccessories.filter(acc => acc.toolId === tool.id)).map(accessory => ( <label key={accessory.id} className="flex items-center space-x-2 text-sm text-gray-300"> <input type="checkbox" checked={selectedAccessories.has(accessory.id)} onChange={() => handleAccessoryToggle(accessory.id)} /> <span>{accessory.name}</span> </label> ))} </div> )} </div> ))}
                                </div>
                            </div>
                           <ConsumableEditor consumables={consumables} selectedConsumables={selectedConsumables} onAdd={handleAddConsumableToList} onRemove={handleRemoveConsumableFromList} />
                        </div>
                        <div className="text-right"> <Button onClick={handleSaveRecipeDetails} variant="primary" className="bg-green-600 hover:bg-green-700">Save Recipe for this Department</Button> </div>
                    </div>
                 )}
            </div>
        )}
    </div>
  );
};

const ProductRecipeManager = () => {
    const [manufacturers, setManufacturers] = useState([]);
    const [makes, setMakes] = useState([]);
    const [models, setModels] = useState([]);
    const [parts, setParts] = useState([]);
    const [departments, setDepartments] = useState([]);
    const [tools, setTools] = useState([]);
    const [toolAccessories, setToolAccessories] = useState([]);
    const [consumables, setConsumables] = useState([]);
    const [allJobSteps, setAllJobSteps] = useState([]);
    const [selectedManufacturerId, setSelectedManufacturerId] = useState(null);
    const [selectedMakeId, setSelectedMakeId] = useState(null);
    const [selectedModelId, setSelectedModelId] = useState(null);
    const [selectedPartId, setSelectedPartId] = useState(null);
    const [recipeToClone, setRecipeToClone] = useState(null); // <-- NEW STATE

    const fetchData = async () => {
        const [man, mak, mod, par, dep, t, ta, inv, steps] = await Promise.all([ getManufacturers(), getMakes(), getModels(), getParts(), getDepartments(), getTools(), getToolAccessories(), getAllInventoryItems(), getJobStepDetails() ]);
        setManufacturers(man); setMakes(mak); setModels(mod); setParts(par); setDepartments(dep); setTools(t); setToolAccessories(ta); 
        const inventoryItems = inv.map(item => ({ id: item.id, name: item.name }));
        setConsumables(inventoryItems); 
        setAllJobSteps(steps);
    };

    useEffect(() => { fetchData(); }, []);

    const handleSelect = (level, id) => {
        if (level === 'manufacturer') { setSelectedManufacturerId(id); setSelectedMakeId(null); setSelectedModelId(null); setSelectedPartId(null); } 
        else if (level === 'make') { setSelectedMakeId(id); setSelectedModelId(null); setSelectedPartId(null); } 
        else if (level === 'model') { setSelectedModelId(id); setSelectedPartId(null); } 
        else if (level === 'part') { setSelectedPartId(id); }
    };
    
    // NEW FUNCTION to handle recipe duplication
    const handleCloneRecipe = (partToCloneId) => {
        const recipes = allJobSteps.filter(step => step.partId === partToCloneId);
        if (recipes.length === 0) {
            alert("This part has no recipes defined to duplicate.");
            return;
        }
        // For simplicity, we'll just clone the first recipe found for the part.
        // A more advanced version could let the user choose which department's recipe to clone.
        setRecipeToClone(recipes[0]);
        setSelectedPartId(null); // Deselect current part to force user to select a new target
        alert(`Recipe for ${parts.find(p=>p.id === partToCloneId).name} copied! Now select the NEW part you want to paste this recipe onto.`);
    };


    const handleAdd = async (level) => {
        let name;
        if (level === 'manufacturer') { name = prompt("Enter new manufacturer name:"); if (name) await addManufacturer(name); } 
        else if (level === 'make') { name = prompt(`Enter new make name for ${manufacturers.find(m=>m.id===selectedManufacturerId).name}:`); if (name) await addMake({ name, manufacturerId: selectedManufacturerId }); } 
        else if (level === 'model') { name = prompt(`Enter new model name for ${makes.find(m=>m.id===selectedMakeId).name}:`); if (name) await addModel({ name, makeId: selectedMakeId }); } 
        else if (level === 'part') { name = prompt(`Enter new part name for ${models.find(m=>m.id===selectedModelId).name}:`); if (name) await addPart({ name, modelId: selectedModelId, photoUrl: '' }); }
        fetchData();
    };

    const handleSaveRecipe = async (partId, departmentId, recipeData) => {
        try {
            await setJobStepDetail(partId, departmentId, recipeData);
            alert("Recipe saved successfully!");
            const steps = await getJobStepDetails();
            setAllJobSteps(steps);
        } catch (error) {
            console.error("Error saving recipe:", error);
            alert("Failed to save recipe.");
        }
    };

    const handlePartUpdate = async (partId, updatedData) => {
        try {
            await updatePart(partId, updatedData);
            alert("Part details updated!");
            fetchData();
        } catch(error) {
            console.error("Error updating part:", error);
            alert("Failed to update part.");
        }
    };


    const filteredMakes = useMemo(() => manufacturers.length > 0 ? makes.filter(m => m.manufacturerId === selectedManufacturerId) : [], [makes, selectedManufacturerId]);
    const filteredModels = useMemo(() => makes.length > 0 ? models.filter(m => m.makeId === selectedMakeId) : [], [models, selectedMakeId]);
    const filteredParts = useMemo(() => models.length > 0 ? parts.filter(p => p.modelId === selectedModelId) : [], [parts, selectedModelId]);
    
    const renderList = (items, selectedId, type) => (
        <ul className="space-y-1">
            {items.map(item => (
                // UPDATE the list item to include the duplicate button
                <li key={item.id} className={`flex items-center justify-between p-2 rounded-md text-sm transition-colors ${selectedId === item.id ? 'bg-blue-600 text-white' : 'hover:bg-gray-700'}`}>
                    <span onClick={() => handleSelect(type, item.id)} className="flex-grow cursor-pointer">{item.name}</span>
                    {type === 'part' && (
                        <Button onClick={(e) => { e.stopPropagation(); handleCloneRecipe(item.id); }} variant="secondary" className="p-1 h-6 w-6 ml-2" title="Duplicate Recipe">
                            <Copy size={14} />
                        </Button>
                    )}
                </li>
            ))}
        </ul>
    );

    return (
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <div className="lg:col-span-1 bg-gray-800 p-4 rounded-xl border border-gray-700 self-start space-y-4">
                <div>
                    <div className="flex justify-between items-center mb-2"><h4 className="font-bold text-lg text-white">Catalog</h4><Button onClick={() => handleAdd('manufacturer')} className="py-1 px-2 text-xs"><FilePlus size={14} className="mr-1"/>Manufacturer</Button></div>
                    {renderList(manufacturers, selectedManufacturerId, 'manufacturer')}
                </div>
                {selectedManufacturerId && (
                    <div className="border-t border-gray-700 pt-4">
                        <div className="flex justify-between items-center mb-2"><h4 className="font-bold text-md text-gray-300">Makes</h4><Button onClick={() => handleAdd('make')} className="py-1 px-2 text-xs"><FilePlus size={14} className="mr-1"/>Make</Button></div>
                        {renderList(filteredMakes, selectedMakeId, 'make')}
                    </div>
                )}
                {selectedMakeId && (
                    <div className="border-t border-gray-700 pt-4">
                         <div className="flex justify-between items-center mb-2"><h4 className="font-bold text-md text-gray-300">Models</h4><Button onClick={() => handleAdd('model')} className="py-1 px-2 text-xs"><FilePlus size={14} className="mr-1"/>Model</Button></div>
                        {renderList(filteredModels, selectedModelId, 'model')}
                    </div>
                )}
                 {selectedModelId && (
                    <div className="border-t border-gray-700 pt-4">
                         <div className="flex justify-between items-center mb-2"><h4 className="font-bold text-md text-gray-300">Parts</h4><Button onClick={() => handleAdd('part')} className="py-1 px-2 text-xs"><FilePlus size={14} className="mr-1"/>Part</Button></div>
                         {renderList(filteredParts, selectedPartId, 'part')}
                    </div>
                )}
            </div>
            <div className="lg:col-span-2">
                {selectedPartId && parts.find(p => p.id === selectedPartId) ? (
                    <PartEditor 
                        part={parts.find(p => p.id === selectedPartId)}
                        departments={departments}
                        tools={tools}
                        toolAccessories={toolAccessories}
                        consumables={consumables}
                        allJobSteps={allJobSteps}
                        onSaveRecipe={handleSaveRecipe}
                        onPartUpdate={handlePartUpdate}
                        recipeToClone={recipeToClone} // Pass the cloned recipe
                        onCloneComplete={() => setRecipeToClone(null)} // Function to clear the clone state
                    />
                ) : (
                    <div className="flex items-center justify-center h-full bg-gray-800 p-6 rounded-xl border-2 border-dashed border-gray-700 text-gray-500">
                         <p>{recipeToClone ? 'Select a new part to paste the recipe to.' : 'Select a part from the catalog to view its dossier.'}</p>
                    </div>
                )}
            </div>
        </div>
    );
};

export default ProductRecipeManager;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\features\settings\SkillsManager.jsx
==================================================
import React, { useState, useEffect } from 'react';
// Corrected firestore path
import { getSkills, addSkill, deleteSkill, updateSkill } from '../../../api/firestore'; 
// CORRECTED UI COMPONENT PATHS
import Input from '../../ui/Input';
import Button from '../../ui/Button';
import { Edit, Trash2, Check, X } from 'lucide-react';

const SkillsManager = () => {
    const [skills, setSkills] = useState([]);
    const [newSkillName, setNewSkillName] = useState('');
    const [loading, setLoading] = useState(true);
    const [editingSkillId, setEditingSkillId] = useState(null);
    const [editingSkillName, setEditingSkillName] = useState('');

    const fetchSkills = async () => {
        setLoading(true);
        try {
            const fetchedSkills = await getSkills();
            setSkills(fetchedSkills);
        } catch (error) {
            console.error("Error fetching skills:", error);
            alert("Could not fetch skills.");
        }
        setLoading(false);
    };

    useEffect(() => {
        fetchSkills();
    }, []);

    const handleAddSkill = async (e) => {
        e.preventDefault();
        if (!newSkillName.trim()) return;
        try {
            await addSkill(newSkillName.trim());
            setNewSkillName('');
            await fetchSkills(); // Refresh list
        } catch (error) {
            console.error("Error adding skill:", error);
            alert("Failed to add skill.");
        }
    };

    const handleDeleteSkill = async (skillId) => {
        if (window.confirm("Are you sure you want to delete this skill?")) {
            try {
                await deleteSkill(skillId);
                await fetchSkills(); // Refresh list
            } catch (error) {
                console.error("Error deleting skill:", error);
                alert("Failed to delete skill.");
            }
        }
    };

    const handleEditClick = (skill) => {
        setEditingSkillId(skill.id);
        setEditingSkillName(skill.name);
    };

    const handleCancelEdit = () => {
        setEditingSkillId(null);
        setEditingSkillName('');
    };

    const handleUpdateSkill = async (skillId) => {
        if (!editingSkillName.trim()) return;
        try {
            await updateSkill(skillId, { name: editingSkillName.trim() });
            setEditingSkillId(null);
            setEditingSkillName('');
            await fetchSkills(); // Refresh list
        } catch (error) {
            console.error("Error updating skill:", error);
            alert("Failed to update skill.");
        }
    };

    return (
        <div className="bg-gray-800/50 p-6 rounded-lg border border-gray-700">
            <h3 className="text-xl font-bold text-white mb-4">Manage Skills</h3>
            {/* Add Skill Form */}
            <form onSubmit={handleAddSkill} className="flex items-center gap-4 mb-6">
                <Input
                    type="text"
                    value={newSkillName}
                    onChange={(e) => setNewSkillName(e.target.value)}
                    placeholder="New skill name..."
                    className="flex-grow"
                />
                <Button type="submit" variant="primary">Add Skill</Button>
            </form>

            {/* Skills List */}
            <div className="space-y-3">
                {loading ? (
                    <p className="text-gray-400">Loading skills...</p>
                ) : (
                    skills.map((skill) => (
                        <div key={skill.id} className="flex items-center justify-between bg-gray-900/50 p-3 rounded-md">
                            {editingSkillId === skill.id ? (
                                <Input
                                    type="text"
                                    value={editingSkillName}
                                    onChange={(e) => setEditingSkillName(e.target.value)}
                                    className="flex-grow mr-2"
                                />
                            ) : (
                                <p className="text-gray-200">{skill.name}</p>
                            )}
                            <div className="flex items-center gap-2">
                                {editingSkillId === skill.id ? (
                                    <>
                                        <Button onClick={() => handleUpdateSkill(skill.id)} variant="icon" className="text-green-500 hover:text-green-400">
                                            <Check size={18} />
                                        </Button>
                                        <Button onClick={handleCancelEdit} variant="icon" className="text-red-500 hover:text-red-400">
                                            <X size={18} />
                                        </Button>
                                    </>
                                ) : (
                                    <>
                                        <Button onClick={() => handleEditClick(skill)} variant="secondary" size="sm">
                                            <Edit size={16} className="mr-1" /> Edit
                                        </Button>
                                        <Button onClick={() => handleDeleteSkill(skill.id)} variant="danger" size="sm">
                                            <Trash2 size={16} className="mr-1" /> Delete
                                        </Button>
                                    </>
                                )}
                            </div>
                        </div>
                    ))
                )}
            </div>
        </div>
    );
};

export default SkillsManager;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\features\settings\SuppliersManager.jsx
==================================================
import React, { useState, useEffect } from 'react';
import { getSuppliers, addSupplier, deleteSupplier, updateSupplier } from '../../../api/firestore'; // Import updateSupplier
import Input from '../../ui/Input';
import Button from '../../ui/Button';

const SuppliersManager = () => {
Â  const [suppliers, setSuppliers] = useState([]);
Â  const [newSupplier, setNewSupplier] = useState({ name: '', email: '', estimatedEtaDays: '', minOrderAmount: '' });
Â  const [loading, setLoading] = useState(true);
  const [editingSupplierId, setEditingSupplierId] = useState(null); // New state to track which supplier is being edited

Â  const fetchSuppliers = async () => {
Â  Â  setLoading(true);
Â  Â  const fetchedSuppliers = await getSuppliers();
Â  Â  setSuppliers(fetchedSuppliers);
Â  Â  setLoading(false);
Â  };

Â  useEffect(() => {
Â  Â  fetchSuppliers();
Â  }, []);

Â  const handleInputChange = (e) => {
Â  Â  const { name, value } = e.target;
Â  Â  setNewSupplier(prevState => ({ ...prevState, [name]: value }));
Â  };

Â  const handleAddOrUpdate = async (e) => { // Renamed handler to handle both add and update
Â  Â  e.preventDefault();
Â  Â  if (!newSupplier.name.trim()) {
Â  Â  Â  alert("Supplier name is required.");
Â  Â  Â  return;
Â  Â  }
Â  Â  try {
Â  Â  Â  const dataToSave = {
Â  Â  Â  Â  ...newSupplier,
Â  Â  Â  Â  estimatedEtaDays: parseInt(newSupplier.estimatedEtaDays, 10) || 0,
Â  Â  Â  Â  minOrderAmount: parseFloat(newSupplier.minOrderAmount) || 0,
Â  Â  Â  };

Â  Â  Â  if (editingSupplierId) {
Â  Â  Â  Â  // If editingSupplierId is set, update the existing supplier using updateSupplier
Â  Â  Â  Â  await updateSupplier(editingSupplierId, dataToSave); 
Â  Â  Â  Â  alert("Supplier updated successfully!");
Â  Â  Â  } else {
Â  Â  Â  Â  // Otherwise, add a new supplier
Â  Â  Â  Â  await addSupplier(dataToSave);
Â  Â  Â  Â  alert("Supplier added successfully!");
Â  Â  Â  }
Â  Â  Â  setNewSupplier({ name: '', email: '', estimatedEtaDays: '', minOrderAmount: '' }); // Reset form
Â  Â  Â  setEditingSupplierId(null); // Clear editing state
Â  Â  Â  fetchSuppliers(); // Refresh list
Â  Â  } catch (error) {
Â  Â  Â  console.error("Error saving supplier:", error);
Â  Â  Â  alert(`Failed to ${editingSupplierId ? 'update' : 'add'} supplier.`); // Dynamic error message
Â  Â  }
Â  };

  const handleEdit = (supplier) => { // Handler for edit button click
    setNewSupplier({
        name: supplier.name,
        email: supplier.email || '', // Ensure email is handled if it's null/undefined
        estimatedEtaDays: supplier.estimatedEtaDays || '', // Ensure numeric values are converted to string for input
        minOrderAmount: supplier.minOrderAmount || '' // Ensure numeric values are converted to string for input
    });
    setEditingSupplierId(supplier.id); // Set the ID of the supplier being edited
  };

  const handleCancelEdit = () => { // Handler to cancel editing
    setNewSupplier({ name: '', email: '', estimatedEtaDays: '', minOrderAmount: '' }); // Reset form
    setEditingSupplierId(null); // Exit editing mode
  };

Â  const handleDelete = async (id) => {
Â  Â  if (window.confirm("Are you sure you want to delete this supplier?")) {
Â  Â  Â  await deleteSupplier(id);
Â  Â  Â  fetchSuppliers();
Â  Â  }
Â  };

Â  return (
Â  Â  <div className="bg-gray-800 p-6 rounded-xl border border-gray-700">
Â  Â  Â  <h3 className="text-xl font-bold text-white mb-4">Manage Suppliers</h3>
Â  Â  Â  <form onSubmit={handleAddOrUpdate} className="grid grid-cols-1 md:grid-cols-5 gap-4 items-end mb-6"> {/* Use universal handler */}
Â  Â  Â  Â  <Input label="Supplier Name" name="name" value={newSupplier.name} onChange={handleInputChange} placeholder={editingSupplierId ? "Edit supplier name..." : "e.g., Bolt & Nut Centre"} /> {/* Dynamic placeholder */}
Â  Â  Â  Â  <Input label="Email Address" name="email" type="email" value={newSupplier.email} onChange={handleInputChange} placeholder={editingSupplierId ? "Edit email..." : "e.g., sales@bolts.co.za"} /> {/* Dynamic placeholder */}
Â  Â  Â  Â  <Input label="ETA (in days)" name="estimatedEtaDays" type="number" value={newSupplier.estimatedEtaDays} onChange={handleInputChange} placeholder={editingSupplierId ? "Edit ETA..." : "e.g., 3"} /> {/* Dynamic placeholder */}
Â  Â  Â  Â  <Input label="Min. Order (R)" name="minOrderAmount" type="number" value={newSupplier.minOrderAmount} onChange={handleInputChange} placeholder={editingSupplierId ? "Edit min order..." : "e.g., 500"} /> {/* Dynamic placeholder */}
        {editingSupplierId && ( // Show cancel button only when in editing mode
            <Button type="button" variant="secondary" onClick={handleCancelEdit}>Cancel</Button>
        )}
Â  Â  Â  Â  <Button type="submit" variant="primary">
            {editingSupplierId ? "Update Supplier" : "Add Supplier"} {/* Dynamic button text */}
        </Button>
Â  Â  Â  </form>

Â  Â  Â  <div className="hidden md:grid grid-cols-5 gap-4 px-3 py-2 text-sm font-semibold text-gray-400 border-b border-gray-700">
Â  Â  Â  Â  <div className="col-span-2">Supplier Name</div>
Â  Â  Â  Â  <div>Email</div>
Â  Â  Â  Â  <div>Lead Time</div>
Â  Â  Â  Â  <div className="text-right">Min. Order</div>
Â  Â  Â  </div>
Â  Â  Â  <div className="space-y-3 mt-2">
Â  Â  Â  Â  {loading ? <p>Loading...</p> : (suppliers || []).map(sup => (
Â  Â  Â  Â  Â  <div key={sup.id} className="grid grid-cols-1 md:grid-cols-5 gap-4 items-center bg-gray-700 p-3 rounded-lg">
Â  Â  Â  Â  Â  Â  <p className="text-gray-200 font-semibold col-span-2">{sup.name}</p>
Â  Â  Â  Â  Â  Â  <p className="text-gray-400">{sup.email}</p>
Â  Â  Â  Â  Â  Â  <p className="text-gray-400">{sup.estimatedEtaDays} days</p>
Â  Â  Â  Â  Â  Â  <p className="text-gray-400 text-right">R {(sup.minOrderAmount || 0).toFixed(2)}</p>
Â  Â  Â  Â  Â  Â  <div className="md:col-start-6 text-right flex space-x-2 justify-end"> {/* Added flex for buttons */}
                <Button onClick={() => handleEdit(sup)} variant="secondary" className="py-1 px-3 text-xs">Edit</Button> {/* Edit button */}
Â  Â  Â  Â  Â  Â  Â  Â  <Button onClick={() => handleDelete(sup.id)} variant="danger" className="py-1 px-3 text-xs">Delete</Button>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  ))}
Â  Â  Â  Â  Â {(suppliers.length === 0 && !loading && <p className="text-center p-4 text-gray-500">No suppliers added yet.</p>)}
Â  Â  Â  </div>
Â  Â  </div>
Â  );
};

export default SuppliersManager;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\features\settings\ToolAccessoriesManager.jsx
==================================================
import React, { useState, useEffect, useMemo } from 'react';
import { getTools, getToolAccessories, addToolAccessory, deleteToolAccessory, updateDocument } from '../../../api/firestore'; // updateDocument imported
import Input from '../../ui/Input';
import Button from '../../ui/Button';
import Dropdown from '../../ui/Dropdown';

const ToolAccessoriesManager = () => {
    const [tools, setTools] = useState([]);
    const [accessories, setAccessories] = useState([]);
    const [newAccessoryName, setNewAccessoryName] = useState('');
    const [selectedToolId, setSelectedToolId] = useState('');
    const [loading, setLoading] = useState(true);
    const [editingAccessoryId, setEditingAccessoryId] = useState(null); // State to track which accessory is being edited

    const fetchData = async () => {
        setLoading(true);
        const [fetchedTools, fetchedAccessories] = await Promise.all([getTools(), getToolAccessories()]); // Fetches tools  and accessories 
        setTools(fetchedTools);
        setAccessories(fetchedAccessories);
        setLoading(false);
    };

    useEffect(() => {
        fetchData();
    }, []);

    const handleAddOrUpdate = async (e) => {
        e.preventDefault();
        if (!newAccessoryName.trim() || !selectedToolId) {
            alert("Please select a parent tool and enter an accessory name.");
            return;
        }
        try {
            const dataToSave = { name: newAccessoryName, toolId: selectedToolId };

            if (editingAccessoryId) {
                // If editingAccessoryId is set, update the existing accessory
                await updateDocument('toolAccessories', editingAccessoryId, dataToSave); // Uses updateDocument for generic update 
                alert("Accessory updated successfully!");
            } else {
                // Otherwise, add a new accessory
                await addToolAccessory(dataToSave); // Adds new accessory 
                alert("Accessory added successfully!");
            }
            setNewAccessoryName(''); // Clear input field
            setSelectedToolId(''); // Clear selected tool
            setEditingAccessoryId(null); // Exit editing mode
            fetchData(); // Refresh the list
        } catch (error) {
            console.error("Error saving accessory:", error);
            alert(`Failed to ${editingAccessoryId ? 'update' : 'add'} accessory.`);
        }
    };

    const handleEdit = (accessory) => { // Handler for edit button click
        setNewAccessoryName(accessory.name); // Pre-fill form with accessory's current name
        setSelectedToolId(accessory.toolId); // Pre-fill with parent tool ID
        setEditingAccessoryId(accessory.id); // Set the ID of the accessory being edited
    };

    const handleCancelEdit = () => { // Handler to cancel editing
        setNewAccessoryName(''); // Clear input field
        setSelectedToolId(''); // Clear selected tool
        setEditingAccessoryId(null); // Exit editing mode
    };

    const handleDelete = async (id) => {
        if (window.confirm("Are you sure you want to delete this accessory?")) {
            await deleteToolAccessory(id); // Deletes tool accessory 
            fetchData(); // Refresh the list
        }
    };
    
    // Group accessories by their parent tool for a clean display
    const groupedAccessories = useMemo(() => {
        const groups = {};
        accessories.forEach(acc => {
            if (!groups[acc.toolId]) {
                const tool = tools.find(t => t.id === acc.toolId);
                groups[acc.toolId] = { toolName: tool ? tool.name : 'Unknown Tool', items: [] };
            }
            groups[acc.toolId].items.push(acc);
        });
        return Object.values(groups);
    }, [accessories, tools]);

    return (
        <div className="bg-gray-800 p-6 rounded-xl border border-gray-700">
            <h3 className="text-xl font-bold text-white mb-4">Manage Tool Accessories</h3>
            <form onSubmit={handleAddOrUpdate} className="grid grid-cols-1 md:grid-cols-3 gap-4 items-end mb-6">
                <Dropdown
                    label="Parent Tool"
                    name="toolId"
                    value={selectedToolId}
                    onChange={(e) => setSelectedToolId(e.target.value)}
                    options={tools}
                    placeholder="Select a tool..."
                />
                <Input
                    label="Accessory Name"
                    name="accessoryName"
                    value={newAccessoryName}
                    onChange={(e) => setNewAccessoryName(e.target.value)}
                    placeholder={editingAccessoryId ? "Edit accessory name..." : "New accessory name..."} // Dynamic placeholder
                />
                {editingAccessoryId && ( // Show Cancel button only when in editing mode
                    <Button type="button" variant="secondary" onClick={handleCancelEdit}>
                        Cancel
                    </Button>
                )}
                <Button type="submit" variant="primary">
                    {editingAccessoryId ? "Update Accessory" : "Add Accessory"} {/* Dynamic button text */}
                </Button>
            </form>
            <div className="space-y-4 mt-6">
                {loading ? (
                    <p>Loading...</p>
                ) : (groupedAccessories.map(group => (
                    <div key={group.toolName}>
                        <h4 className="font-semibold text-blue-400 border-b border-gray-700 pb-1 mb-2">{group.toolName} Accessories</h4>
                        <ul className="space-y-2">
                            {group.items.map(item => (
                                <li key={item.id} className="flex items-center justify-between bg-gray-700 p-3 rounded-lg text-sm">
                                    <p className="text-gray-200">{item.name}</p>
                                    <div className="flex space-x-2"> {/* Container for action buttons */}
                                        <Button onClick={() => handleEdit(item)} variant="secondary" className="py-0.5 px-2 text-xs">
                                            Edit
                                        </Button>
                                        <Button onClick={() => handleDelete(item.id)} variant="danger" className="py-0.5 px-2 text-xs">
                                            Delete
                                        </Button>
                                    </div>
                                </li>
                            ))}
                        </ul>
                    </div>
                )))}
            </div>
        </div>
    );
};

export default ToolAccessoriesManager;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\features\settings\ToolsManager.jsx
==================================================
import React, { useState, useEffect } from 'react';
import { getTools, addTool, deleteTool, updateDocument } from '../../../api/firestore'; // updateDocument imported
import Input from '../../ui/Input';
import Button from '../../ui/Button';

const ToolsManager = () => {
    const [tools, setTools] = useState([]);
    const [newToolName, setNewToolName] = useState('');
    const [loading, setLoading] = useState(true);
    const [editingToolId, setEditingToolId] = useState(null); // State to track which tool is being edited

    const fetchTools = async () => {
        setLoading(true);
        const fetchedTools = await getTools(); // Fetches tools from Firestore 
        setTools(fetchedTools);
        setLoading(false);
    };

    useEffect(() => {
        fetchTools();
    }, []);

    const handleAddOrUpdate = async (e) => {
        e.preventDefault();
        if (!newToolName.trim()) return;

        try {
            if (editingToolId) {
                // If editingToolId is set, update the existing tool
                await updateDocument('tools', editingToolId, { name: newToolName }); // Uses updateDocument for generic update 
                alert("Tool updated successfully!");
            } else {
                // Otherwise, add a new tool
                await addTool(newToolName); // Adds new tool 
                alert("Tool added successfully!");
            }
            setNewToolName(''); // Clear input field
            setEditingToolId(null); // Exit editing mode
            fetchTools(); // Refresh the list of tools
        } catch (error) {
            console.error("Error saving tool:", error);
            alert(`Failed to ${editingToolId ? 'update' : 'add'} tool.`);
        }
    };

    const handleEdit = (tool) => {
        setNewToolName(tool.name); // Pre-fill form with tool's current name
        setEditingToolId(tool.id); // Set the ID of the tool being edited
    };

    const handleCancelEdit = () => {
        setNewToolName(''); // Clear input field
        setEditingToolId(null); // Exit editing mode
    };

    const handleDelete = async (id) => {
        if (window.confirm("Are you sure you want to delete this tool?")) {
            try {
                await deleteTool(id); // Deletes tool 
                alert("Tool deleted successfully!");
                fetchTools(); // Refresh the list
            } catch (error) {
                console.error("Error deleting tool:", error);
                alert("Failed to delete tool.");
            }
        }
    };

    return (
        <div className="bg-gray-800 p-6 rounded-xl border border-gray-700">
            <h3 className="text-xl font-bold text-white mb-4">Manage Tools</h3>
            <form onSubmit={handleAddOrUpdate} className="flex items-center space-x-4 mb-6">
                <Input
                    name="toolName"
                    value={newToolName}
                    onChange={(e) => setNewToolName(e.target.value)}
                    placeholder={editingToolId ? "Edit tool name..." : "New tool name..."} // Dynamic placeholder
                    className="flex-grow"
                />
                {editingToolId && ( // Show Cancel button only when in editing mode
                    <Button type="button" variant="secondary" onClick={handleCancelEdit}>
                        Cancel
                    </Button>
                )}
                <Button type="submit" variant="primary">
                    {editingToolId ? "Update Tool" : "Add Tool"} {/* Dynamic button text */}
                </Button>
            </form>
            <div className="space-y-3">
                {loading ? (
                    <p>Loading tools...</p>
                ) : (
                    (tools || []).map(tool => (
                        <div key={tool.id} className="flex items-center justify-between bg-gray-700 p-3 rounded-lg">
                            <p className="text-gray-200">{tool.name}</p>
                            <div className="flex space-x-2"> {/* Container for action buttons */}
                                <Button onClick={() => handleEdit(tool)} variant="secondary" className="py-1 px-3 text-xs">
                                    Edit
                                </Button>
                                <Button onClick={() => handleDelete(tool.id)} variant="danger" className="py-1 px-3 text-xs">
                                    Delete
                                </Button>
                            </div>
                        </div>
                    ))
                )}
            </div>
        </div>
    );
};

export default ToolsManager;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\features\settings\UnifiedProductManager.jsx
==================================================
// src/components/features/settings/UnifiedProductManager.jsx (Fixed & Expanded)

import React, { useState, useEffect, useMemo } from 'react';
import {
    getProducts, addProduct, updateProduct, deleteProduct,
    getProductCategories, addProductCategory,
    getManufacturers, getMakes, getModels,
    getFitmentForProduct, addFitment, removeFitment,
    getJobStepDetails, setJobStepDetail, getDepartments,
    getTools, getToolAccessories, getAllInventoryItems,
    linkRecipeToProduct, getLinkedRecipesForProduct, unlinkRecipeFromProduct
} from '../../../api/firestore';
import Button from '../../ui/Button';
import Input from '../../ui/Input';
import Dropdown from '../../ui/Dropdown';
import Textarea from '../../ui/Textarea';
import { X, Save, Link as LinkIcon, Package, Wrench, Settings2, Search, Trash2, ChevronDown, ChevronRight, PackagePlus, FolderPlus } from 'lucide-react';

const ConsumableEditor = ({ consumables, selectedConsumables, onAdd, onRemove }) => {
    const [consumableType, setConsumableType] = useState('fixed');
    const [fixedId, setFixedId] = useState('');
    const [fixedQty, setFixedQty] = useState('');
    const [dimId, setDimId] = useState('');
    const [cuts, setCuts] = useState([]);
    const [cutRule, setCutRule] = useState({ dimensions: '', notes: '' });

    const handleAddConsumable = () => {
        let newConsumable;
        switch (consumableType) {
            case 'fixed':
                if (!fixedId || !fixedQty) return alert("Please select an item and enter a quantity.");
                newConsumable = { type: 'fixed', itemId: fixedId, quantity: Number(fixedQty) };
                break;
            case 'dimensional':
                if (!dimId || cuts.length === 0) return alert("Please select a material and add at least one cutting instruction.");
                newConsumable = { type: 'dimensional', itemId: dimId, cuts };
                break;
            default: return;
        }

        if (!selectedConsumables.find(c => c.itemId === newConsumable.itemId)) {
            onAdd(newConsumable);
            setFixedId(''); setFixedQty('');
            setDimId(''); setCuts([]); setCutRule({ dimensions: '', notes: '' });
        } else {
            alert("This consumable has already been added to the recipe.");
        }
    };

    const getConsumableName = (id) => consumables.find(c => c.id === id)?.name || 'Unknown Item';
    return (
        <div>
            <h4 className="font-semibold mb-2 text-white">Required Consumables</h4>
            <div className="p-4 bg-gray-800 rounded-lg space-y-4">
                <div className="flex gap-2 bg-gray-700 p-1 rounded-md">
                    <button type="button" onClick={() => setConsumableType('fixed')} className={`flex-1 p-2 text-sm rounded transition-colors ${consumableType === 'fixed' ? 'bg-blue-600 text-white' : 'hover:bg-blue-500/20'}`}>Fixed Quantity</button>
                    <button type="button" onClick={() => setConsumableType('dimensional')} className={`flex-1 p-2 text-sm rounded transition-colors ${consumableType === 'dimensional' ? 'bg-blue-600 text-white' : 'hover:bg-blue-500/20'}`}>Dimensional Cuts</button>
                </div>

                {consumableType === 'fixed' && (
                    <div className="flex items-end gap-2 animate-fade-in">
                         <div className="flex-grow"><Dropdown label="Item" value={fixedId} onChange={e => setFixedId(e.target.value)} options={consumables} placeholder="Select..."/></div>
                        <div className="w-24"><Input label="Qty" type="number" value={fixedQty} onChange={e => setFixedQty(e.target.value)} placeholder="e.g., 5"/></div>
                        <Button type="button" onClick={handleAddConsumable}>Add</Button>
                    </div>
                )}
                
                {consumableType === 'dimensional' && (
                     <div className="space-y-3 animate-fade-in">
                        <Dropdown label="Material to Cut" value={dimId} onChange={e => setDimId(e.target.value)} options={consumables} placeholder="Select mat..."/>
                        <div className="p-2 border border-gray-700 rounded-md">
                             <p className="text-xs text-gray-400 mb-2">Cutting Instructions</p>
                            <div className="flex items-end gap-2">
                                <Input label="Dimensions" value={cutRule.dimensions} onChange={e => setCutRule({...cutRule, dimensions: e.target.value})} />
                                <Input label="Notes" value={cutRule.notes} onChange={e => setCutRule({...cutRule, notes: e.target.value})} />
                                 <Button type="button" onClick={() => { if(cutRule.dimensions) { setCuts([...cuts, cutRule]); setCutRule({ dimensions: '', notes: '' }); }}}>Add Cut</Button>
                            </div>
                            <ul className="text-xs mt-2 space-y-1">{cuts.map((c, i) => <li key={i}>{c.dimensions} ({c.notes})</li>)}</ul>
                        </div>
                         <Button type="button" onClick={handleAddConsumable} className="w-full">Add Dimensional Consumable</Button>
                    </div>
                )}

                <h5 className="text-sm font-bold pt-2 border-t border-gray-700 text-gray-200">Recipe Consumables</h5>
                <ul className="space-y-2 max-h-40 overflow-y-auto">
                    {selectedConsumables.map((c, i) => (
                        <li key={i} className="flex justify-between items-center bg-gray-700 p-2 rounded text-sm text-gray-200">
                            <div>
                                 <p className="font-semibold">{getConsumableName(c.itemId)}</p>
                                {c.type === 'fixed' && <p className="text-xs text-gray-400">Qty: {c.quantity}</p>}
                                {c.type === 'dimensional' && <p className="text-xs text-gray-400">{c.cuts.length} cut(s) required</p>}
                            </div>
                            <Button type="button" onClick={() => onRemove(c.itemId)} variant="danger" className="py-0.5 px-2 text-xs">X</Button>
                        </li>
                    ))}
                </ul>
            </div>
        </div>
    );
};

const UnifiedProductManager = () => {
    // Data states
    const [products, setProducts] = useState([]);
    const [categories, setCategories] = useState([]);
    const [manufacturers, setManufacturers] = useState([]);
    const [makes, setMakes] = useState([]);
    const [models, setModels] = useState([]);
    const [allRecipes, setAllRecipes] = useState([]);
    const [departments, setDepartments] = useState([]);
    const [tools, setTools] = useState([]);
    const [toolAccessories, setToolAccessories] = useState([]);
    const [consumables, setConsumables] = useState([]);
    
    // UI Control states
    const [loading, setLoading] = useState(true);
    const [selectedProductId, setSelectedProductId] = useState(null);
    const [searchTerm, setSearchTerm] = useState('');
    const [activeTab, setActiveTab] = useState('details');
    const [expandedCategories, setExpandedCategories] = useState({});
    // Form states
    const [newProduct, setNewProduct] = useState({ name: '', partNumber: '', sellingPrice: '', categoryId: '' });
    const [newCategoryName, setNewCategoryName] = useState('');
    const [editProductData, setEditProductData] = useState(null);
    // Fitment states
    const [fitmentLinks, setFitmentLinks] = useState([]);
    const [mfgToLink, setMfgToLink] = useState('');
    const [makeToLink, setMakeToLink] = useState('');
    const [modelToLink, setModelToLink] = useState('');
    // Recipe Editor states
    const [recipeDepartmentId, setRecipeDepartmentId] = useState('');
    const [recipeData, setRecipeData] = useState({ description: '', estimatedTime: '', steps: '', tools: new Set(), accessories: new Set(), consumables: [] });

    const fetchData = async () => {
        setLoading(true);
        try {
            const [prods, cats, m, mk, mo, recipes, depts, t, ta, inv] = await Promise.all([
                getProducts(), getProductCategories(), getManufacturers(), getMakes(), getModels(), getJobStepDetails(), getDepartments(), getTools(), getToolAccessories(), getAllInventoryItems()
            ]);
            setProducts(prods);
            setCategories(cats);
            setManufacturers(m);
            setMakes(mk);
            setModels(mo);
            setAllRecipes(recipes);
            setDepartments(depts);
            setTools(t);
            setToolAccessories(ta);
            setConsumables(inv);
        } catch (error) {
            console.error("Failed to fetch initial data:", error);
            alert("Error fetching data. Check the console.");
        }
        setLoading(false);
    };
    useEffect(() => { fetchData(); }, []);

    useEffect(() => {
        if (selectedProductId) {
            const product = products.find(p => p.id === selectedProductId);
            setEditProductData(product);
            setActiveTab('details');
            setRecipeDepartmentId('');
            const fetchLinks = async () => setFitmentLinks(await getFitmentForProduct(selectedProductId));
            fetchLinks();
        } else {
            setEditProductData(null);
        }
    }, [selectedProductId, products]);

    useEffect(() => {
        if (selectedProductId && recipeDepartmentId) {
            const recipeId = `${selectedProductId}_${recipeDepartmentId}`;
            const existingRecipe = allRecipes.find(r => r.id === recipeId);
            if (existingRecipe) {
                setRecipeData({
                    description: existingRecipe.description || '',
                    estimatedTime: existingRecipe.estimatedTime || '',
                    steps: (existingRecipe.steps || []).join('\n'),
                    tools: new Set(existingRecipe.tools || []),
                    accessories: new Set(existingRecipe.accessories || []),
                    consumables: existingRecipe.consumables || []
                });
            } else {
                 setRecipeData({ description: '', estimatedTime: '', steps: '', tools: new Set(), accessories: new Set(), consumables: [] });
            }
        }
    }, [selectedProductId, recipeDepartmentId, allRecipes]);

    const productsByCategory = useMemo(() => {
        const filtered = searchTerm 
            ? products.filter(p => p.name.toLowerCase().includes(searchTerm.toLowerCase()) || p.partNumber?.toLowerCase().includes(searchTerm.toLowerCase()))
            : products;

        const categorized = categories.reduce((acc, category) => {
            acc[category.id] = filtered.filter(p => p.categoryId === category.id);
            return acc;
        }, {});

        categorized['uncategorized'] = filtered.filter(p => !p.categoryId);

        return categorized;
    }, [products, categories, searchTerm]);
    const handleAddNewCategory = async () => {
        if (!newCategoryName.trim()) return;
        await addProductCategory(newCategoryName);
        setNewCategoryName('');
        fetchData();
    };
    
    const handleAddNewProduct = async (e) => {
        e.preventDefault();
        if (!newProduct.name || !newProduct.partNumber || !newProduct.categoryId) {
            return alert('Category, Product Name, and Part Number are required.');
        }
        try {
            await addProduct(newProduct);
            setNewProduct({ name: '', partNumber: '', sellingPrice: '', categoryId: '' });
            fetchData();
        } catch (error) {
            alert(error.message);
        }
    };

    const handleUpdateProduct = async () => {
        if (!editProductData.name || !editProductData.partNumber) return alert('Product Name and Part Number are required.');
        await updateProduct(selectedProductId, {
            name: editProductData.name,
            partNumber: editProductData.partNumber,
            sellingPrice: Number(editProductData.sellingPrice) || 0,
            photoUrl: editProductData.photoUrl || '',
            categoryId: editProductData.categoryId || ''
        });
        alert('Product updated successfully!');
        fetchData();
    };

    const handleDeleteProduct = async (productId) => {
        if (window.confirm("Are you sure you want to PERMANENTLY delete this product? This cannot be undone.")) {
            await deleteProduct(productId);
            setSelectedProductId(null);
            fetchData();
        }
    };
    
    const handleAddFitment = async () => {
        if(!modelToLink) return alert('Please select a model to link.');
        const model = models.find(m => m.id === modelToLink);
        const make = makes.find(m => m.id === model.makeId);
        const manufacturer = manufacturers.find(m => m.id === make.manufacturerId);
        await addFitment(selectedProductId, model.id, model.name, make.name, manufacturer.name);
        const links = await getFitmentForProduct(selectedProductId);
        setFitmentLinks(links);
    };
    
    const handleRemoveFitment = async (fitmentId) => {
        await removeFitment(fitmentId);
        const links = await getFitmentForProduct(selectedProductId);
        setFitmentLinks(links);
    };

    const handleSaveRecipe = async () => {
        if (!selectedProductId || !recipeDepartmentId) return alert('A product and department must be selected.');
        const dataToSave = {
            description: recipeData.description,
            estimatedTime: Number(recipeData.estimatedTime),
            steps: recipeData.steps.split('\n').filter(s => s.trim() !== ''),
            tools: Array.from(recipeData.tools),
            accessories: Array.from(recipeData.accessories),
            consumables: recipeData.consumables,
        };
        try {
            await setJobStepDetail(selectedProductId, recipeDepartmentId, dataToSave);

            const product = products.find(p => p.id === selectedProductId);
            const department = departments.find(d => d.id === recipeDepartmentId);
            
            const existingLinks = await getLinkedRecipesForProduct(selectedProductId);
            const linkExists = existingLinks.some(link => link.departmentId === recipeDepartmentId);

            if (!linkExists && product && department) {
                await linkRecipeToProduct({
                    productId: selectedProductId,
                    productName: product.name,
                    jobStepDetailId: `${selectedProductId}_${recipeDepartmentId}`,
                    departmentId: recipeDepartmentId,
                    departmentName: department.name
                });
            }

            alert('Recipe saved successfully!');
            fetchData();
        } catch (error) {
            console.error("Error saving recipe:", error);
            alert("Failed to save recipe.");
        }
    };
    
    const handleRecipeInputChange = (e) => setRecipeData({...recipeData, [e.target.name]: e.target.value});
    const handleToolToggle = (toolId) => {
        const newTools = new Set(recipeData.tools);
        newTools.has(toolId) ? newTools.delete(toolId) : newTools.add(toolId);
        setRecipeData({...recipeData, tools: newTools});
    };
    const handleAccessoryToggle = (accId) => {
        const newAccessories = new Set(recipeData.accessories);
        newAccessories.has(accId) ? newAccessories.delete(accId) : newAccessories.add(accId);
        setRecipeData({...recipeData, accessories: newAccessories});
    };
    const handleAddConsumable = (c) => setRecipeData({...recipeData, consumables: [...recipeData.consumables, c]});
    const handleRemoveConsumable = (itemId) => setRecipeData({...recipeData, consumables: recipeData.consumables.filter(c => c.itemId !== itemId)});
    const filteredMakes = useMemo(() => makes.filter(m => m.manufacturerId === mfgToLink), [mfgToLink, makes]);
    const filteredModels = useMemo(() => models.filter(m => m.makeId === makeToLink), [makeToLink, models]);
    
    if (loading) return <p className="text-gray-400">Loading Product Catalog...</p>;
    return (
        <div className="bg-gray-800 p-6 rounded-xl border border-gray-700">
            <h3 className="text-2xl font-bold text-white mb-6">Unified Product Catalog</h3>
            <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
                {/* Left Panel */}
                <div className="lg:col-span-1 space-y-6">
                     <div>
                        <Input placeholder="Search all products..." value={searchTerm} onChange={e => setSearchTerm(e.target.value)} className="mb-4" />
                        <div className="space-y-1 max-h-[30rem] overflow-y-auto pr-2">
                            {categories.map(category => (
                                 <div key={category.id}>
                                    <div onClick={() => setExpandedCategories(p => ({...p, [category.id]: !p[category.id]}))} className="flex items-center justify-between p-3 rounded-lg bg-gray-700 cursor-pointer hover:bg-gray-600">
                                     <span className="font-semibold text-white">{category.name}</span>
                                        {expandedCategories[category.id] ? <ChevronDown/> : <ChevronRight/>}
                                    </div>
                                    {expandedCategories[category.id] && (
                                         <div className="pl-4 mt-1 space-y-1">
                                            {(productsByCategory[category.id] || []).length > 0 ? (
                                                 (productsByCategory[category.id] || []).map(p => (
                                                    <div key={p.id} onClick={() => setSelectedProductId(p.id)} className={`p-2 rounded-md cursor-pointer ${selectedProductId === p.id ? 'bg-blue-600 text-white' : 'hover:bg-gray-900/50'}`}>
                                                         <p className="font-semibold">{p.name}</p>
                                                         <p className="text-xs opacity-70">Part #: {p.partNumber}</p>
                                                    </div>
                                                 ))
                                            ) : (
                                                <p className="text-xs text-gray-500 p-2 italic">No products in this category.</p>
                                            )}
                                        </div>
                                     )}
                                </div>
                            ))}
                              {(productsByCategory['uncategorized']?.length > 0) && (
                                 <div key="uncategorized">
                                    <div onClick={() => setExpandedCategories(p => ({...p, uncategorized: !p.uncategorized}))} className="flex items-center justify-between p-3 rounded-lg bg-gray-700 cursor-pointer hover:bg-gray-600 mt-4">
                                        <span className="font-semibold text-white italic">Uncategorized</span>
                                        {expandedCategories['uncategorized'] ? <ChevronDown/> : <ChevronRight/>}
                                    </div>
                                    {expandedCategories['uncategorized'] && (
                                         <div className="pl-4 mt-1 space-y-1">
                                            {productsByCategory['uncategorized'].map(p => (
                                                 <div key={p.id} onClick={() => setSelectedProductId(p.id)} className={`p-2 rounded-md cursor-pointer ${selectedProductId === p.id ? 'bg-blue-600 text-white' : 'hover:bg-gray-900/50'}`}>
                                                    <p className="font-semibold">{p.name}</p>
                                                     <p className="text-xs opacity-70">Part #: {p.partNumber}</p>
                                                </div>
                                             ))}
                                        </div>
                                     )}
                                </div>
                            )}
                        </div>
                     </div>
                    <div className="space-y-4 border-t border-gray-700 pt-6">
                        <h4 className="font-bold text-lg text-white">Add New Category</h4>
                        <div className="flex gap-2">
                             <Input placeholder="e.g., Fiberglass Panels" value={newCategoryName} onChange={e => setNewCategoryName(e.target.value)} />
                            <Button onClick={handleAddNewCategory}><FolderPlus size={16} /></Button>
                        </div>
                    </div>
                     <form onSubmit={handleAddNewProduct} className="space-y-4 border-t border-gray-700 pt-6">
                         <h4 className="font-bold text-lg text-white">Add New Product</h4>
                         <Dropdown label="Category" value={newProduct.categoryId} onChange={e => setNewProduct({...newProduct, categoryId: e.target.value})} options={categories} required/>
                          <Input label="Product Name" value={newProduct.name} onChange={e => setNewProduct({...newProduct, name: e.target.value})} required/>
                         <Input label="Part Number" value={newProduct.partNumber} onChange={e => setNewProduct({...newProduct, partNumber: e.target.value})} required/>
                         <Input label="Selling Price (R)" type="number" value={newProduct.sellingPrice} onChange={e => setNewProduct({...newProduct, sellingPrice: e.target.value})} />
                          <Button type="submit" variant="primary" className="w-full"><PackagePlus size={16} className="mr-2"/>Create New Product</Button>
                    </form>
                </div>

                {/* Right Panel */}
                <div className="lg:col-span-2">
                     {!selectedProductId ? (
                        <div className="flex items-center justify-center h-full bg-gray-900/50 p-6 rounded-xl border-2 border-dashed border-gray-700 text-gray-500">
                            <p>Select a product from the list to view its details.</p>
                        </div>
                     ) : (
                        <div className="bg-gray-900/50 p-6 rounded-xl">
                             <div className="flex justify-between items-center">
                                <div className="flex border-b border-gray-600">
                                    <button onClick={() => setActiveTab('details')} className={`px-4 py-2 flex items-center gap-2 text-sm font-medium ${activeTab === 'details' ? 'border-b-2 border-blue-500 text-white' : 'text-gray-400'}`}><Package size={16}/> Details</button>
                                     <button onClick={() => setActiveTab('fitment')} className={`px-4 py-2 flex items-center gap-2 text-sm font-medium ${activeTab === 'fitment' ? 'border-b-2 border-blue-500 text-white' : 'text-gray-400'}`}><Settings2 size={16}/> Fitment</button>
                                    <button onClick={() => setActiveTab('recipe')} className={`px-4 py-2 flex items-center gap-2 text-sm font-medium ${activeTab === 'recipe' ? 'border-b-2 border-blue-500 text-white' : 'text-gray-400'}`}><Wrench size={16}/> Recipe</button>
                                </div>
                                <Button onClick={() => handleDeleteProduct(selectedProductId)} variant="danger" size="sm" className="p-2"><Trash2 size={16}/></Button>
                             </div>
                            <div className="pt-6">
                                {activeTab === 'details' && (
                                     <div className="space-y-4 animate-fade-in">
                                        <Dropdown label="Category" value={editProductData?.categoryId || ''} onChange={e => setEditProductData({...editProductData, categoryId: e.target.value})} options={categories} placeholder="Choose a category..."/>
                                         <Input label="Product Name" value={editProductData?.name || ''} onChange={e => setEditProductData({...editProductData, name: e.target.value})} />
                                        <Input label="Part Number" value={editProductData?.partNumber || ''} disabled />
                                        <Input label="Selling Price (R)" type="number" value={editProductData?.sellingPrice || ''} onChange={e => setEditProductData({...editProductData, sellingPrice: e.target.value})} />
                                        <Input label="Photo URL" value={editProductData?.photoUrl || ''} onChange={e => setEditProductData({...editProductData, photoUrl: e.target.value})} placeholder="Paste Dropbox link here..."/>
                                        {editProductData?.photoUrl && <img src={editProductData.photoUrl.replace("www.dropbox.com", "dl.dropboxusercontent.com")} alt="Product Preview" className="w-48 h-48 rounded-lg object-cover border-2 border-gray-600" />}
                                         <Button onClick={handleUpdateProduct}><Save size={16} className="mr-2"/> Save Details</Button>
                                    </div>
                                )}
                                 {activeTab === 'fitment' && (
                                    <div className="space-y-4 animate-fade-in">
                                         <h4 className="font-semibold text-white">Linked Models ({fitmentLinks.length})</h4>
                                           <div className="space-y-2 max-h-48 overflow-y-auto pr-2">
                                            {fitmentLinks.map(link => (
                                                 <div key={link.id} className="flex justify-between items-center bg-gray-700 p-2 rounded">
                                                    <p className="text-sm text-gray-300">{link.manufacturerName} &gt; {link.makeName} &gt; {link.modelName}</p>
                                                    <Button onClick={() => handleRemoveFitment(link.id)} variant="danger" className="p-1 h-6 w-6"><X size={14}/></Button>
                                                 </div>
                                            ))}
                                        </div>
                                           <div className="border-t border-gray-600 pt-4 space-y-3">
                                            <h5 className="font-semibold text-white">Add New Fitment</h5>
                                               <Dropdown label="Manufacturer" value={mfgToLink} onChange={e => setMfgToLink(e.target.value)} options={manufacturers} placeholder="Select..."/>
                                            <Dropdown label="Make" value={makeToLink} onChange={e => setMakeToLink(e.target.value)} options={filteredMakes} placeholder="Select..." disabled={!mfgToLink}/>
                                             <Dropdown label="Model" value={modelToLink} onChange={e => setModelToLink(e.target.value)} options={filteredModels} placeholder="Select..." disabled={!makeToLink}/>
                                            <Button onClick={handleAddFitment} className="w-full"><LinkIcon size={16} className="mr-2"/> Link to Model</Button>
                                         </div>
                                    </div>
                                 )}
                                {activeTab === 'recipe' && (
                                    <div className="space-y-6 animate-fade-in">
                                         <Dropdown label="Select a Department to Define its Recipe" value={recipeDepartmentId} onChange={e => setRecipeDepartmentId(e.target.value)} options={departments} placeholder="Choose department..."/>
                                        {recipeDepartmentId && (
                                             <div className="space-y-6 border-t border-gray-700 pt-6">
                                                <Input label="Description" name="description" value={recipeData.description} onChange={handleRecipeInputChange} />
                                                     <Input label="Estimated Time (minutes)" name="estimatedTime" type="number" value={recipeData.estimatedTime} onChange={handleRecipeInputChange} />
                                                <Textarea label="Steps (one per line)" name="steps" value={recipeData.steps} onChange={handleRecipeInputChange} rows={5} />
                                                 <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                                                    <div>
                                                             <h4 className="font-semibold mb-2 text-white">Required Tools & Accessories</h4>
                                                         <div className="max-h-60 overflow-y-auto space-y-3 p-4 bg-gray-800 rounded-lg">
                                                            {(tools || []).map(tool => ( <div key={tool.id}> <label className="flex items-center space-x-2 text-sm font-semibold text-gray-200"> <input type="checkbox" checked={recipeData.tools.has(tool.id)} onChange={() => handleToolToggle(tool.id)} /> <span>{tool.name}</span> </label> {recipeData.tools.has(tool.id) && ( <div className="pl-6 mt-2 space-y-2 border-l-2 border-gray-700"> {(toolAccessories.filter(acc => acc.toolId === tool.id)).map(accessory => ( <label key={accessory.id} className="flex items-center space-x-2 text-sm text-gray-300"> <input type="checkbox" checked={recipeData.accessories.has(accessory.id)} onChange={() => handleAccessoryToggle(accessory.id)} /> <span>{accessory.name}</span> </label> ))} </div> )} </div> ))}
                                                         </div>
                                                    </div>
                                                     <ConsumableEditor consumables={consumables} selectedConsumables={recipeData.consumables} onAdd={handleAddConsumable} onRemove={handleRemoveConsumable} />
                                                </div>
                                                 <div className="text-right">
                                                    <Button onClick={handleSaveRecipe} variant="primary" className="bg-green-600 hover:bg-green-700"><Save size={16} className="mr-2"/>Save Recipe for this Department</Button>
                                                 </div>
                                            </div>
                                         )}
                                    </div>
                                )}
                             </div>
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
};

export default UnifiedProductManager;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\features\sidebar\CalculatorApplet.jsx
==================================================
import React, { useState } from 'react';

// Reusable button component for our calculator
const CalcButton = ({ onClick, children, className = '' }) => (
  <button 
    onClick={() => onClick(children)}
    className={`bg-gray-600 hover:bg-gray-500 text-white font-bold py-4 rounded-lg text-xl transition-colors ${className}`}
  >
    {children}
  </button>
);

const CalculatorApplet = () => {
  const [display, setDisplay] = useState('0');
  const [firstOperand, setFirstOperand] = useState(null);
  const [operator, setOperator] = useState(null);
  const [waitingForSecondOperand, setWaitingForSecondOperand] = useState(false);

  const handleDigitClick = (digit) => {
    if (waitingForSecondOperand) {
      setDisplay(String(digit));
      setWaitingForSecondOperand(false);
    } else {
      setDisplay(display === '0' ? String(digit) : display + digit);
    }
  };

  const handleDecimalClick = () => {
    if (!display.includes('.')) {
      setDisplay(display + '.');
    }
  };

  const handleOperatorClick = (nextOperator) => {
    const inputValue = parseFloat(display);

    if (operator && !waitingForSecondOperand) {
      const result = calculate(firstOperand, inputValue, operator);
      setDisplay(String(result));
      setFirstOperand(result);
    } else {
      setFirstOperand(inputValue);
    }

    setWaitingForSecondOperand(true);
    setOperator(nextOperator);
  };

  const calculate = (op1, op2, op) => {
    switch (op) {
      case '+': return op1 + op2;
      case '-': return op1 - op2;
      case 'Ã—': return op1 * op2;
      case 'Ã·': return op1 / op2;
      default: return op2;
    }
  };

  const handleEqualsClick = () => {
    const inputValue = parseFloat(display);
    if (operator && !waitingForSecondOperand) {
      const result = calculate(firstOperand, inputValue, operator);
      setDisplay(String(result));
      setFirstOperand(null);
      setOperator(null);
    }
  };

  const handleClearClick = () => {
    setDisplay('0');
    setFirstOperand(null);
    setOperator(null);
    setWaitingForSecondOperand(false);
  };

  return (
    <div className="p-2">
      {/* Display Screen */}
      <div className="bg-gray-900 text-white text-4xl text-right font-mono p-4 rounded-lg mb-2 overflow-x-auto">
        {display}
      </div>
      {/* Calculator Buttons */}
      <div className="grid grid-cols-4 gap-2">
        <CalcButton onClick={handleClearClick} className="col-span-2 bg-red-600 hover:bg-red-500">C</CalcButton>
        <CalcButton onClick={handleOperatorClick}>Ã·</CalcButton>
        <CalcButton onClick={handleOperatorClick}>Ã—</CalcButton>
        <CalcButton onClick={handleDigitClick}>7</CalcButton>
        <CalcButton onClick={handleDigitClick}>8</CalcButton>
        <CalcButton onClick={handleDigitClick}>9</CalcButton>
        <CalcButton onClick={handleOperatorClick}>-</CalcButton>
        <CalcButton onClick={handleDigitClick}>4</CalcButton>
        <CalcButton onClick={handleDigitClick}>5</CalcButton>
        <CalcButton onClick={handleDigitClick}>6</CalcButton>
        <CalcButton onClick={handleOperatorClick}>+</CalcButton>
        <CalcButton onClick={handleDigitClick}>1</CalcButton>
        <CalcButton onClick={handleDigitClick}>2</CalcButton>
        <CalcButton onClick={handleDigitClick}>3</CalcButton>
        <CalcButton onClick={handleEqualsClick} className="row-span-2 bg-blue-600 hover:bg-blue-500">=</CalcButton>
        <CalcButton onClick={handleDigitClick} className="col-span-2">0</CalcButton>
        <CalcButton onClick={handleDecimalClick}>.</CalcButton>
      </div>
    </div>
  );
};

export default CalculatorApplet;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\features\sidebar\CalendarApplet.jsx
==================================================
import React, { useState } from 'react';
import Calendar from 'react-calendar';
import 'react-calendar/dist/Calendar.css';

const CalendarApplet = () => {
  const [date, setDate] = useState(new Date());

  return (
    <div className="p-2 text-white">
        {/* This style block helps the calendar theme match our dark mode app */}
        <style>{`
            .react-calendar { background: transparent; border: none; }
            .react-calendar__tile:enabled:hover, .react-calendar__tile:enabled:focus { background-color: #374151; }
            .react-calendar__tile--now { background-color: #3b82f6 !important; color: white !important; }
            .react-calendar__tile--active { background-color: #1d4ed8 !important; color: white !important; }
            .react-calendar__month-view__days__day--neighboringMonth { color: #6b7280 !important; }
        `}</style>
        <Calendar 
            onChange={setDate} 
            value={date} 
            className="bg-transparent border-none"
        />
    </div>
  );
};

export default CalendarApplet;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\features\sidebar\NotesApplet.jsx
==================================================
import React, { useState, useEffect } from 'react';

const NotesApplet = () => {
  // Load saved notes from localStorage or default to empty
  const [notes, setNotes] = useState(() => {
    const savedNotes = localStorage.getItem('tojemos-sidebar-notes');
    return savedNotes || '';
  });

  // This useEffect hook saves the notes to localStorage whenever they change
  useEffect(() => {
    localStorage.setItem('tojemos-sidebar-notes', notes);
  }, [notes]);

  return (
    <div className="p-2">
      <h4 className="font-bold text-gray-300 text-sm mb-2">Scratchpad</h4>
      <textarea
        value={notes}
        onChange={(e) => setNotes(e.target.value)}
        placeholder="Type your notes here..."
        className="w-full h-48 p-2 bg-gray-900 border border-gray-600 rounded-md text-sm text-gray-200 focus:outline-none focus:ring-2 focus:ring-blue-500 resize-none"
      />
    </div>
  );
};

export default NotesApplet;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\features\sidebar\WeatherApplet.jsx
==================================================
import React, { useState, useEffect } from 'react';
import { Sun, Cloud, CloudRain, Wind, Thermometer, ArrowDown, ArrowUp } from 'lucide-react';
import Button from '../../ui/Button';

// A small component to display a single weather detail
const WeatherDetail = ({ icon, value, unit }) => (
    <div className="flex items-center text-sm text-gray-300">
        {icon}
        <span className="ml-2">{value}{unit}</span>
    </div>
);

const WeatherApplet = () => {
    const [weather, setWeather] = useState(null);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const fetchWeather = async () => {
            // API URL for Cape Town's coordinates with the specific data we want
            const apiUrl = "https://api.open-meteo.com/v1/forecast?latitude=-33.92&longitude=18.42&daily=temperature_2m_max,temperature_2m_min,precipitation_probability_max,windspeed_10m_max&timezone=auto";
            
            try {
                const response = await fetch(apiUrl);
                const data = await response.json();
                // We only need today's data, which is the first item in the arrays
                setWeather({
                    maxTemp: Math.round(data.daily.temperature_2m_max[0]),
                    minTemp: Math.round(data.daily.temperature_2m_min[0]),
                    rainProb: data.daily.precipitation_probability_max[0],
                    windSpeed: Math.round(data.daily.windspeed_10m_max[0]),
                });
            } catch (error) {
                console.error("Failed to fetch weather data:", error);
            } finally {
                setLoading(false);
            }
        };

        fetchWeather();
    }, []);

    if (loading) {
        return <div className="p-2 text-sm text-gray-400">Loading Weather...</div>;
    }

    if (!weather) {
        return <div className="p-2 text-sm text-red-400">Could not load weather.</div>;
    }

    return (
        <div className="p-2 space-y-3">
            <div className="flex items-center justify-between">
                <div className="flex items-center">
                    <CloudRain size={32} className="text-blue-400" />
                    <div className="ml-3">
                        <p className="font-bold text-white">Cape Town</p>
                        <p className="text-xs text-gray-400">Today's Forecast</p>
                    </div>
                </div>
            </div>

            <div className="grid grid-cols-2 gap-3">
                <WeatherDetail icon={<ArrowUp size={16} className="text-red-400"/>} value={weather.maxTemp} unit="Â°C" />
                <WeatherDetail icon={<ArrowDown size={16} className="text-blue-400"/>} value={weather.minTemp} unit="Â°C" />
                <WeatherDetail icon={<CloudRain size={16} className="text-sky-300"/>} value={weather.rainProb} unit="%" />
                <WeatherDetail icon={<Wind size={16} className="text-gray-300"/>} value={weather.windSpeed} unit=" km/h" />
            </div>

            <a href="https://www.google.com/search?q=weather+cape+town" target="_blank" rel="noopener noreferrer">
                 <Button variant="secondary" className="w-full text-xs py-1">
                    View 7-Day Forecast
                 </Button>
            </a>
        </div>
    );
};

export default WeatherApplet;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\features\stock\InTransitOrders.jsx
==================================================
import React, { useState } from 'react';
import { receiveStockAndUpdateInventory, requeueOrDeleteItem } from '../../../api/firestore';
import Button from '../../ui/Button';

const InTransitOrders = ({ items, suppliers, onStockReceived }) => {
  const [receivedQuantities, setReceivedQuantities] = useState({});

  const getSupplierName = (supplierId) => (suppliers || []).find(s => s.id === supplierId)?.name || 'N/A';
  
  const handleQuantityChange = (itemId, qty) => {
    setReceivedQuantities(prev => ({ ...prev, [itemId]: qty }));
  };

  const handleReceiveStock = async (item) => {
    const qtyReceived = receivedQuantities[item.id] || item.orderedQty;
    if (!qtyReceived || qtyReceived <= 0) {
      return alert("Please enter a valid quantity received.");
    }
    if (!window.confirm(`Are you sure you want to add ${qtyReceived} of ${item.itemName} to your stock?`)) {
      return;
    }
    try {
      await receiveStockAndUpdateInventory(item, qtyReceived);
      alert("Stock updated successfully!");
      if (onStockReceived) onStockReceived();
    } catch (error) {
      console.error("Error receiving stock: ", error);
      alert("Failed to update stock. Please check the console for details.");
    }
  };

  const handleCancelOrder = async (item) => {
    if (window.confirm(`Are you sure you want to cancel this in-transit order for "${item.itemName}"? This may add it back to the purchase queue.`)) {
        try {
            await requeueOrDeleteItem(item);
            alert("Order cancelled successfully.");
            if (onStockReceived) onStockReceived();
        } catch (error) {
            console.error("Error cancelling order:", error);
            alert("Failed to cancel order.");
        }
    }
  };
  
  const calculateEta = (etaTimestamp) => {
    if (!etaTimestamp?.seconds) return { text: 'N/A', color: 'text-gray-400' };
    const etaDate = new Date(etaTimestamp.seconds * 1000);
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const diffTime = etaDate.getTime() - today.getTime();
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    if (diffDays < 0) return { text: `Overdue by ${Math.abs(diffDays)} day(s)`, color: 'text-red-500 font-bold' };
    if (diffDays === 0) return { text: 'Arriving Today', color: 'text-yellow-400 font-bold' };
    if (diffDays === 1) return { text: 'Arriving Tomorrow', color: 'text-blue-400' };
    return { text: `Arriving in ${diffDays} days`, color: 'text-gray-300' };
  };

  return (
    <div className="bg-gray-800 p-6 rounded-xl border border-gray-700">
        <h3 className="text-xl font-bold text-white mb-4">In-Transit Orders</h3>
        <div className="overflow-x-auto">
            <table className="w-full text-left">
              <thead>
                <tr className="border-b border-gray-600">
                  <th className="p-2 text-sm font-semibold text-gray-400">Item</th>
                  <th className="p-2 text-sm font-semibold text-gray-400">Supplier</th>
                  <th className="p-2 text-sm font-semibold text-gray-400 text-center">Qty Ordered</th>
                  <th className="p-2 text-sm font-semibold text-gray-400">ETA</th>
                  <th className="p-2 text-sm font-semibold text-gray-400 w-32">Qty Received</th>
                  <th className="p-2 text-sm font-semibold text-gray-400">Actions</th>
                </tr>
              </thead>
              <tbody>
                {(items || []).map(item => {
                    const eta = calculateEta(item.expectedArrivalDate);
                    return(
                        <tr key={item.id} className="border-b border-gray-700">
                          <td className="p-2 text-gray-200">{item.itemName}</td>
                          <td className="p-2 text-gray-400">{getSupplierName(item.supplierId)}</td>
                          <td className="p-2 text-gray-300 font-bold text-center">{item.orderedQty}</td>
                          <td className={`p-2 text-sm ${eta.color}`}>{eta.text}</td>
                          <td className="p-2">
                            {/* --- THIS IS THE CORRECTED PART --- */}
                            <input 
                                type="number" 
                                value={receivedQuantities[item.id] || item.orderedQty}
                                onChange={(e) => handleQuantityChange(item.id, e.target.value)}
                                className="w-full p-2 bg-gray-700 border border-gray-600 rounded-lg text-white text-center focus:outline-none focus:ring-2 focus:ring-blue-500"
                            />
                          </td>
                          <td className="p-2 flex gap-2">
                            <Button variant="success" className="text-xs py-1 px-2" onClick={() => handleReceiveStock(item)}>Receive</Button>
                            <Button variant="danger" className="text-xs py-1 px-2" onClick={() => handleCancelOrder(item)}>Cancel</Button>
                          </td>
                        </tr>
                    )
                })}
              </tbody>
            </table>
            {items.length === 0 && <p className="text-center p-8 text-gray-400">No items are currently on order.</p>}
        </div>
    </div>
  );
};

export default InTransitOrders;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\features\stock\PurchaseQueue.jsx
==================================================
import React, { useState, useEffect, useMemo } from 'react';
import { getPurchaseQueue, getSuppliers, markItemsAsOrdered } from '../../../api/firestore';
import Button from '../../ui/Button';

const PurchaseQueue = ({ onOrderPlaced }) => {
  const [queuedItems, setQueuedItems] = useState([]);
  const [suppliers, setSuppliers] = useState([]);
  const [orderQuantities, setOrderQuantities] = useState({});
  const [loading, setLoading] = useState(true);

  const fetchData = async () => {
    setLoading(true);
    const [queue, supplierList] = await Promise.all([getPurchaseQueue(), getSuppliers()]);
    const pendingItems = queue.filter(item => item.status === 'pending');
    setQueuedItems(pendingItems);
    setSuppliers(supplierList);
    setLoading(false);
  };

  useEffect(() => {
    fetchData();
  }, []);

  const handleQuantityChange = (itemId, qty) => {
    setOrderQuantities(prev => ({ ...prev, [itemId]: qty }));
  };

  const groupedBySupplier = useMemo(() => {
    const groups = {};
    queuedItems.forEach(item => {
      const supplier = suppliers.find(s => s.id === item.supplierId);
      if (!supplier) return;
      if (!groups[supplier.id]) {
        groups[supplier.id] = { supplierDetails: supplier, items: [] };
      }
      groups[supplier.id].items.push(item);
    });
    return Object.values(groups).sort((a, b) => a.supplierDetails.name.localeCompare(b.supplierDetails.name));
  }, [queuedItems, suppliers]);

  const handleGenerateEmail = (group) => {
    const supplierEmail = group.supplierDetails.email || '';
    const subject = encodeURIComponent(`Purchase Order - TOJEM`);
    let body = `Hi ${group.supplierDetails.contactPerson || group.supplierDetails.name},\n\nPlease supply the following items:\n\n`;
    
    group.items.forEach(item => {
      const recommendedQty = Math.max(0, (item.standardStockLevel || 0) - (item.currentStock || 0));
      const orderQty = orderQuantities[item.id] || recommendedQty;
      if (orderQty > 0) {
        body += `- ${item.itemName} (Code: ${item.itemCode || 'N/A'}) --- Qty: ${orderQty}\n`;
      }
    });

    body += `\nThank you,\nTojem`;
    const encodedBody = encodeURIComponent(body);
    window.location.href = `mailto:${supplierEmail}?subject=${subject}&body=${encodedBody}`;

    const itemIdsToUpdate = group.items.map(item => item.id);
    markItemsAsOrdered(group.supplierDetails, group.items, orderQuantities).then(() => {
        alert("Items have been marked as ordered and removed from the queue.");
        fetchData();
        if(onOrderPlaced) onOrderPlaced();
    });
  };

  if (loading) return <p className="text-center text-gray-400">Loading purchase queue...</p>;

  return (
    <div className="space-y-6">
      {groupedBySupplier.length === 0 && <div className="bg-gray-800 p-8 rounded-xl border border-gray-700 text-center text-gray-400">Your purchase queue is empty.</div>}
      {groupedBySupplier.map(({ supplierDetails, items }) => (
        <div key={supplierDetails.id} className="bg-gray-800 p-6 rounded-xl border border-gray-700">
          <div className="flex justify-between items-center mb-4">
            <div>
              <h3 className="text-xl font-bold text-white">{supplierDetails.name}</h3>
              <p className="text-sm text-gray-400">{supplierDetails.email}</p>
            </div>
            <Button onClick={() => handleGenerateEmail({ supplierDetails, items })}>Generate Email Order</Button>
          </div>
          <div className="overflow-x-auto">
            <table className="w-full text-left">
              <thead>
                <tr className="border-b border-gray-600">
                  <th className="p-2 text-sm font-semibold text-gray-400">Item</th>
                  <th className="p-2 text-sm font-semibold text-gray-400 text-center">Current / Reorder</th>
                  <th className="p-2 text-sm font-semibold text-gray-400 text-center">Recommended Qty</th>
                  <th className="p-2 text-sm font-semibold text-gray-400 w-32">Order Qty</th>
                </tr>
              </thead>
              <tbody>
                {items.map(item => {
                  const recommendedQty = Math.max(0, (item.standardStockLevel || 0) - (item.currentStock || 0));
                  return (
                    <tr key={item.id} className="border-b border-gray-700">
                      <td className="p-2 text-gray-200">{item.itemName}</td>
                      <td className="p-2 text-gray-400 text-center">{item.currentStock} / {item.reorderLevel}</td>
                      <td className="p-2 text-green-400 font-bold text-center">{recommendedQty}</td>
                      <td className="p-2">
                        {/* --- THIS IS THE CORRECTED PART --- */}
                        <input 
                          type="number" 
                          value={orderQuantities[item.id] || recommendedQty} 
                          onChange={(e) => handleQuantityChange(item.id, e.target.value)}
                          className="w-full p-2 bg-gray-700 border border-gray-600 rounded-lg text-white text-center focus:outline-none focus:ring-2 focus:ring-blue-500"
                        />
                      </td>
                    </tr>
                  )
                })}
              </tbody>
            </table>
          </div>
        </div>
      ))}
    </div>
  );
};

export default PurchaseQueue;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\features\stock\StockControlDashboard.jsx
==================================================
import React, { useState, useEffect, useMemo } from 'react';
import { getAllInventoryItems, getSuppliers, getPurchaseQueue, addToPurchaseQueue } from '../../../api/firestore';
import Input from '../../ui/Input';
import Button from '../../ui/Button';
import { Search } from 'lucide-react';

const StockLevelIndicator = ({ currentStock, reorderLevel, standardStockLevel }) => {
    const stock = Number(currentStock);
    const reorder = Number(reorderLevel);
    const standard = Number(standardStockLevel);
    if (isNaN(stock) || isNaN(reorder) || isNaN(standard) || standard <= reorder) return <div className="text-xs text-gray-500 italic">Not tracked</div>;
    const isLowStock = stock < reorder;
    const range = standard - reorder;
    const stockInRange = stock - reorder;
    const percentage = Math.max(0, Math.min((stockInRange / range) * 100, 100));
    return (
        <div className="w-full">
            <div className="flex justify-between text-xs mb-1">
                <span className="font-semibold text-gray-300">{stock} / {standard}</span>
                <span className={`font-bold ${isLowStock ? 'text-red-400' : 'text-green-400'}`}>{isLowStock ? `Low (Reorder at ${reorder})` : 'In Stock'}</span>
            </div>
            <div className="w-full bg-gray-600 rounded-full h-2"><div className={`h-2 rounded-full ${isLowStock ? 'bg-red-500' : 'bg-green-500'}`} style={{ width: `${percentage}%` }}></div></div>
        </div>
    );
};

const StockControlDashboard = () => {
  const [allItems, setAllItems] = useState([]);
  const [suppliers, setSuppliers] = useState([]);
  const [queuedItemIds, setQueuedItemIds] = useState(new Set());
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState('');
  const [sortBy, setSortBy] = useState('name-asc');
  const [showLowStock, setShowLowStock] = useState(false);

  const fetchData = async () => {
    setLoading(true);
    const [inventory, supplierList, queue] = await Promise.all([getAllInventoryItems(), getSuppliers(), getPurchaseQueue()]);
    setAllItems(inventory);
    setSuppliers(supplierList);
    setQueuedItemIds(new Set(queue.map(item => item.itemId)));
    setLoading(false);
  };

  useEffect(() => { fetchData(); }, []);

  const getSupplierName = (supplierId) => (suppliers || []).find(s => s.id === supplierId)?.name || 'N/A';

  const displayedItems = useMemo(() => {
    let filtered = [...(allItems || [])];
    if (showLowStock) { filtered = filtered.filter(item => Number(item.currentStock) < Number(item.reorderLevel)); }
    if (searchTerm) { filtered = filtered.filter(item => item.name.toLowerCase().includes(searchTerm.toLowerCase())); }
    filtered.sort((a, b) => {
      switch (sortBy) {
        case 'name-asc': return a.name.localeCompare(b.name);
        case 'supplier': return getSupplierName(a.supplierId).localeCompare(getSupplierName(b.supplierId));
        case 'stock-low-high': return (a.currentStock / a.reorderLevel) - (b.currentStock / b.reorderLevel);
        default: return 0;
      }
    });
    return filtered;
  }, [allItems, searchTerm, sortBy, showLowStock, suppliers]);

  const handleAddToQueue = async (item) => {
    try {
      await addToPurchaseQueue({
        itemId: item.id,
        itemName: item.name,
        supplierId: item.supplierId,
        itemCode: item.itemCode || '',
        category: item.category,
        currentStock: item.currentStock,
        reorderLevel: item.reorderLevel,
        standardStockLevel: item.standardStockLevel,
        price: item.price,
        unit: item.unit
      });
      setQueuedItemIds(prev => new Set(prev).add(item.id));
    } catch (error) {
      console.error("Error adding to queue:", error);
      alert("Failed to add to reorder list.");
    }
  };

  if (loading) return <p className="text-center text-gray-400">Loading all inventory...</p>;

  return (
    <div className="bg-gray-800 p-6 rounded-xl border border-gray-700">
      <div className="flex flex-wrap gap-4 items-center mb-4 p-4 bg-gray-900/50 rounded-lg">
          <div className="relative flex-grow">
            <Input placeholder="Search all inventory..." value={searchTerm} onChange={e => setSearchTerm(e.target.value)} />
            <Search className="absolute right-3 top-1/2 -translate-y-1/2 text-gray-400" size={20} />
          </div>
          <div>
            <select value={sortBy} onChange={e => setSortBy(e.target.value)} className="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-white">
              <option value="name-asc">Sort by Name</option>
              <option value="supplier">Sort by Supplier</option>
              <option value="stock-low-high">Sort by Stock Level</option>
            </select>
          </div>
          <div className="flex items-center space-x-2 text-white">
            <input type="checkbox" id="lowStockToggle" checked={showLowStock} onChange={e => setShowLowStock(e.target.checked)} className="h-5 w-5 rounded bg-gray-700 text-blue-600 focus:ring-blue-500" />
            <label htmlFor="lowStockToggle" className="text-sm font-medium">Show only low stock</label>
          </div>
      </div>
      <div className="overflow-x-auto">
        <table className="w-full text-left">
          <thead>
            <tr className="border-b border-gray-600">
              <th className="p-3 text-sm font-semibold text-gray-400">Item Name</th>
              <th className="p-3 text-sm font-semibold text-gray-400">Category</th>
              <th className="p-3 text-sm font-semibold text-gray-400">Supplier</th>
              <th className="p-3 text-sm font-semibold text-gray-400 w-1/4">Stock Level</th>
              <th className="p-3 text-sm font-semibold text-gray-400">Actions</th>
            </tr>
          </thead>
          <tbody>
            {(displayedItems).map(item => {
              const isQueued = queuedItemIds.has(item.id);
              return (
                // --- THIS IS THE CORRECTED LINE ---
                <tr key={`${item.id}-${item.category}`} className="border-b border-gray-700 hover:bg-gray-700/50">
                  <td className="p-3 text-gray-200 font-semibold">{item.name}</td>
                  <td className="p-3 text-gray-400">{item.category}</td>
                  <td className="p-3 text-gray-400">{getSupplierName(item.supplierId)}</td>
                  <td className="p-3">
                    <StockLevelIndicator 
                        currentStock={item.currentStock} 
                        reorderLevel={item.reorderLevel} 
                        standardStockLevel={item.standardStockLevel} 
                    />
                  </td>
                  <td className="p-3">
                    {isQueued ? (
                      <Button variant="success" disabled={true} className="text-xs">Queued</Button>
                    ) : (
                      <Button variant="primary" onClick={() => handleAddToQueue(item)} className="text-xs">Add to Queue</Button>
                    )}
                  </td>
                </tr>
              )
            })}
          </tbody>
        </table>
        {displayedItems.length === 0 && !loading && <p className="text-center p-8 text-gray-400">No inventory items found.</p>}
      </div>
    </div>
  );
};

export default StockControlDashboard;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\features\tracking\JobDetailsModal.jsx
==================================================
import React, { useState, useEffect, useMemo, useRef } from 'react'; // Added useMemo
import Button from '../../ui/Button';
import Input from '../../ui/Input';
import Textarea from '../../ui/Textarea';
import Dropdown from '../../ui/Dropdown';
import { Search, X, CheckCircle2, DollarSign, Clock, Zap, Edit, Trash2, Save, XCircle } from 'lucide-react';

// Utility to process consumables (copied from JobCardCreator for consistency within this modal)
// It's important to keep this utility here if you want to display processed consumables in the modal
// or recalculate them if estimatedTime changes (though not implemented here for brevity of first edit)
const processConsumablesForModal = (consumablesFromRecipe, allConsumablesList, temp) => {
    if (!consumablesFromRecipe) return [];

    const processedList = [];
    const CATALYST_RULES = [
        { temp_max: 18, percentage: 3.0 },
        { temp_max: 28, percentage: 2.0 },
        { temp_max: 100, percentage: 1.0 }
    ];

    const catalystItem = allConsumablesList.find(c => c.name.toLowerCase().includes('catalyst') || c.name.toLowerCase().includes('hardener'));

    for (const consumable of consumablesFromRecipe) {
        const masterItem = allConsumablesList.find(c => c.id === consumable.itemId);
        const itemDetails = masterItem || consumable; // Fallback to consumable itself if not found in master list
        if (!itemDetails) continue;

        if (consumable.type === 'fixed') {
            processedList.push({ ...itemDetails, quantity: consumable.quantity, notes: '' });
            if (itemDetails.requiresCatalyst && catalystItem) {
                let percentage = 0;
                for(const rule of CATALYST_RULES) {
                    if (temp <= rule.temp_max) {
                        percentage = rule.percentage;
                        break;
                    }
                }
                if (percentage > 0) {
                    const calculatedQty = consumable.quantity * (percentage / 100);
                    processedList.push({ ...catalystItem, quantity: calculatedQty, notes: `(Auto-added at ${percentage}% for ${temp}Â°C)` });
                }
            }
        } else if (consumable.type === 'dimensional') {
            processedList.push({ ...itemDetails, cuts: consumable.cuts, notes: `See ${consumable.cuts.length} cutting instruction(s)` });
        }
    }
    return processedList;
};


// Helper component for Consumable editing within the modal
const ConsumableEditorInModal = ({ allConsumables, selectedConsumables, onAdd, onRemove }) => {
    const [consumableType, setConsumableType] = useState('fixed');
    const [fixedSearchTerm, setFixedSearchTerm] = useState('');
    const [fixedQty, setFixedQty] = useState('');
    const [filteredFixedOptions, setFilteredFixedOptions] = useState([]);
    const [selectedFixedItemDetails, setSelectedFixedItemDetails] = useState(null);

    const [dimSearchTerm, setDimSearchTerm] = useState('');
    const [cuts, setCuts] = useState([]);
    const [cutRule, setCutRule] = useState({ dimensions: '', notes: '' });
    const [filteredDimOptions, setFilteredDimOptions] = useState([]);
    const [selectedDimItemDetails, setSelectedDimItemDetails] = useState(null);

    const searchRefFixed = useRef(null);
    const searchRefDim = useRef(null);

    // Search filtering effects
    useEffect(() => {
        if (fixedSearchTerm.length > 0) {
            const lowerCaseSearchTerm = fixedSearchTerm.toLowerCase();
            const filtered = allConsumables.filter(item =>
                item.name.toLowerCase().includes(lowerCaseSearchTerm) ||
                (item.itemCode && item.itemCode.toLowerCase().includes(lowerCaseSearchTerm))
            ).slice(0, 10);
            setFilteredFixedOptions(filtered);
        } else {
            setFilteredFixedOptions([]);
        }
    }, [fixedSearchTerm, allConsumables]);

    useEffect(() => {
        if (dimSearchTerm.length > 0) {
            const lowerCaseSearchTerm = dimSearchTerm.toLowerCase();
            const filtered = allConsumables.filter(item =>
                (item.category === 'Raw Material' || item.name.toLowerCase().includes('mat')) && // Filter for materials
                (item.name.toLowerCase().includes(lowerCaseSearchTerm) ||
                (item.itemCode && item.itemCode.toLowerCase().includes(lowerCaseSearchTerm)))
            ).slice(0, 10);
            setFilteredDimOptions(filtered);
        } else {
            setFilteredDimOptions([]);
        }
    }, [dimSearchTerm, allConsumables]);

    // Click outside handlers
    useEffect(() => {
        const handleClickOutside = (event) => {
            if (searchRefFixed.current && !searchRefFixed.current.contains(event.target)) {
                setFilteredFixedOptions([]);
            }
            if (searchRefDim.current && !searchRefDim.current.contains(event.target)) {
                setFilteredDimOptions([]);
            }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
    }, []);

    const handleAddConsumable = () => {
        let newConsumable;
        let itemToAddDetails;

        if (consumableType === 'fixed') {
            if (!selectedFixedItemDetails || !fixedQty || parseFloat(fixedQty) <= 0) return alert("Please select an item and enter a valid quantity.");
            itemToAddDetails = selectedFixedItemDetails;
            newConsumable = { type: 'fixed', itemId: itemToAddDetails.id, quantity: Number(fixedQty) };
        } else if (consumableType === 'dimensional') {
            if (!selectedDimItemDetails || cuts.length === 0) return alert("Please select a material and add at least one cutting instruction.");
            itemToAddDetails = selectedDimItemDetails;
            newConsumable = { type: 'dimensional', itemId: itemToAddDetails.id, cuts };
        } else {
            return;
        }

        // Add display properties directly from itemToAddDetails
        const consumableWithDetails = {
            ...newConsumable,
            name: itemToAddDetails.name,
            unit: itemToAddDetails.unit || 'units',
            price: itemToAddDetails.price || 0,
            itemCode: itemToAddDetails.itemCode || '',
            category: itemToAddDetails.category || '', // Crucial for stock deduction later
            requiresCatalyst: itemToAddDetails.requiresCatalyst || false,
        };

        if (!selectedConsumables.find(c => c.itemId === consumableWithDetails.itemId)) {
            onAdd(consumableWithDetails);
            setFixedSearchTerm('');
            setFixedQty('');
            setSelectedFixedItemDetails(null);

            setDimSearchTerm('');
            setCuts([]);
            setCutRule({ dimensions: '', notes: '' });
            setSelectedDimItemDetails(null);
        } else {
            alert("This consumable has already been added to the recipe.");
        }
    };

    const getConsumableName = (id) => allConsumables.find(c => c.id === id)?.name || 'Unknown Item';

    return (
        <div>
            <h5 className="font-semibold mb-2 text-gray-200">Required Consumables</h5>
            <div className="p-4 bg-gray-900/50 rounded-lg space-y-4">
                <div className="flex gap-2 bg-gray-800 p-1 rounded-md">
                    <button type="button" onClick={() => setConsumableType('fixed')} className={`flex-1 p-2 text-sm rounded transition-colors ${consumableType === 'fixed' ? 'bg-blue-600 text-white' : 'hover:bg-blue-500/20'}`}>Fixed Quantity</button>
                    <button type="button" onClick={() => setConsumableType('dimensional')} className={`flex-1 p-2 text-sm rounded transition-colors ${consumableType === 'dimensional' ? 'bg-blue-600 text-white' : 'hover:bg-blue-500/20'}`}>Dimensional Cuts</button>
                </div>
                {consumableType === 'fixed' && (
                    <div className="flex items-end gap-2 animate-fade-in" ref={searchRefFixed}>
                        <div className="flex-grow relative">
                            <Input
                                label="Item"
                                value={fixedSearchTerm}
                                onChange={e => {
                                    setFixedSearchTerm(e.target.value);
                                    setSelectedFixedItemDetails(null);
                                }}
                                placeholder="Search by name or code..."
                            />
                            <Search className="absolute right-3 top-1/2 -translate-y-1/2 text-gray-400" size={20} />
                            {fixedSearchTerm.length > 0 && filteredFixedOptions.length > 0 && (
                                <ul className="absolute z-10 bg-gray-700 border border-gray-600 rounded-md w-full mt-1 max-h-48 overflow-y-auto shadow-lg">
                                    {filteredFixedOptions.map(item => (
                                        <li
                                            key={item.id}
                                            className="p-2 text-sm text-gray-200 hover:bg-blue-600 hover:text-white cursor-pointer"
                                            onClick={() => {
                                                setSelectedFixedItemDetails(item);
                                                setFixedSearchTerm(item.name);
                                                setFilteredFixedOptions([]);
                                            }}
                                        >
                                            {item.name} ({item.itemCode || 'N/A'}) - {item.unit || 'units'} (R{item.price?.toFixed(2) || '0.00'})
                                        </li>
                                    ))}
                                </ul>
                            )}
                        </div>
                        <div className="w-24">
                            <Input
                                label="Qty"
                                type="number"
                                value={fixedQty}
                                onChange={e => setFixedQty(e.target.value)}
                                placeholder="e.g., 5"
                            />
                        </div>
                        <Button
                            type="button"
                            onClick={handleAddConsumable}
                            disabled={!selectedFixedItemDetails || parseFloat(fixedQty) <= 0 || isNaN(parseFloat(fixedQty))}
                        >
                            Add
                        </Button>
                    </div>
                )}

                {consumableType === 'dimensional' && (
                    <div className="space-y-3 animate-fade-in" ref={searchRefDim}>
                         <div className="flex-grow relative">
                            <Input
                                label="Material to Cut"
                                value={dimSearchTerm}
                                onChange={e => {
                                    setDimSearchTerm(e.target.value);
                                    setSelectedDimItemDetails(null);
                                }}
                                placeholder="Search by name or code..."
                            />
                            <Search className="absolute right-3 top-1/2 -translate-y-1/2 text-gray-400" size={20} />
                            {dimSearchTerm.length > 0 && filteredDimOptions.length > 0 && (
                                <ul className="absolute z-10 bg-gray-700 border border-gray-600 rounded-md w-full mt-1 max-h-48 overflow-y-auto shadow-lg">
                                    {filteredDimOptions.map(item => (
                                        <li
                                            key={item.id}
                                            className="p-2 text-sm text-gray-200 hover:bg-blue-600 hover:text-white cursor-pointer"
                                            onClick={() => {
                                                setSelectedDimItemDetails(item);
                                                setDimSearchTerm(item.name);
                                                setFilteredDimOptions([]);
                                            }}
                                        >
                                            {item.name} ({item.itemCode || 'N/A'}) - {item.unit || 'units'} (R{item.price?.toFixed(2) || '0.00'})
                                        </li>
                                    ))}
                                </ul>
                            )}
                        </div>
                        <div className="p-2 border border-gray-700 rounded-md">
                            <p className="text-xs text-gray-400 mb-2">Cutting Instructions</p>
                            <div className="flex items-end gap-2">
                                <Input label="Dimensions (e.g., 120cm x 80cm)" value={cutRule.dimensions} onChange={e => setCutRule({...cutRule, dimensions: e.target.value})} />
                                <Input label="Notes" value={cutRule.notes} onChange={e => setCutRule({...cutRule, notes: e.target.value})} />
                                <Button type="button" onClick={() => { if(cutRule.dimensions) { setCuts([...cuts, cutRule]); setCutRule({ dimensions: '', notes: '' }); }}}>Add Cut</Button>
                            </div>
                            <ul className="text-xs mt-2 space-y-1">{cuts.map((c, i) => <li key={i}>{c.dimensions} ({c.notes})</li>)}</ul>
                        </div>
                        <Button
                            type="button"
                            onClick={handleAddConsumable}
                            className="w-full"
                            disabled={!selectedDimItemDetails || cuts.length === 0}
                        >
                            Add Dimensional Consumable
                        </Button>
                    </div>
                )}

                <h6 className="text-sm font-bold pt-2 border-t border-gray-700 text-gray-200">Recipe Consumables</h6>
                <ul className="space-y-2 max-h-40 overflow-y-auto">
                    {selectedConsumables.map((c, i) => (
                        <li key={i} className="flex justify-between items-center bg-gray-700 p-2 rounded text-sm text-gray-200">
                            <div>
                                <p className="font-semibold">{c.name}</p>
                                {c.quantity && <span>: {c.quantity.toFixed(3)} {c.unit}</span>}
                                {c.notes && <span className="text-xs italic text-gray-500 ml-1">{c.notes}</span>}
                                {c.cuts && (
                                    <ul className="list-square list-inside ml-4 mt-1">
                                        {c.cuts.map((cut, j) => <li key={j}>{cut.dimensions} <span className="text-xs italic text-gray-500">{cut.notes}</span></li>)}
                                    </ul>
                                )}
                            </div>
                            <Button type="button" onClick={() => onRemove(c.itemId)} variant="danger" className="py-0.5 px-2 text-xs">X</Button>
                        </li>
                    ))}
                </ul>
            </div>
        </div>
    );
};

// Helper component for displaying details rows
const DetailRow = ({ label, value, className = 'text-gray-300' }) => (
    <div className="flex justify-between items-center py-2 border-b border-gray-700/50">
        <p className="text-sm text-gray-400">{label}</p>
        <p className={`text-sm font-semibold ${className}`}>{value}</p>
    </div>
);

// JobDetailsModal component
const JobDetailsModal = ({ job, onClose, currentTime, employeeHourlyRates, allEmployees, onUpdateJob, onDeleteJob, allInventoryItems, allTools, allToolAccessories }) => {
    // State to manage edit mode
    const [isEditing, setIsEditing] = useState(false);
    // State to hold editable data for the form
    const [editableJobData, setEditableJobData] = useState(() => ({
        partName: job.partName,
        description: job.description || '',
        estimatedTime: job.estimatedTime || 0,
        employeeId: job.employeeId,
        employeeName: job.employeeName,
        steps: Array.isArray(job.steps) ? job.steps.join('\n') : '',
        selectedTools: new Set(job.tools?.map(t => t.id) || []),
        selectedAccessories: new Set(job.accessories?.map(a => a.id) || []),
        selectedConsumables: job.consumables || [], // Assume job.consumables is the raw recipe consumable format
    }));

    // Effect to reset editableJobData when job prop changes (e.g., modal opens for a new job)
    useEffect(() => {
        setEditableJobData({
            partName: job.partName,
            description: job.description || '',
            estimatedTime: job.estimatedTime || 0,
            employeeId: job.employeeId,
            employeeName: job.employeeName,
            steps: Array.isArray(job.steps) ? job.steps.join('\n') : '',
            selectedTools: new Set(job.tools?.map(t => t.id) || []),
            selectedAccessories: new Set(job.accessories?.map(a => a.id) || []),
            selectedConsumables: job.consumables || [],
        });
        setIsEditing(false); // Always start in view mode
    }, [job]);


    // Recalculate processed consumables for display in view mode, or when needed in edit mode
    const processedConsumablesForDisplay = useMemo(() => {
        // We pass a dummy temperature (20) for consistent calculation in the modal,
        // unless you need actual live temperature to affect already created jobs' consumables display.
        return processConsumablesForModal(job.consumables, allInventoryItems, 20);
    }, [job.consumables, allInventoryItems]);


    // Utility functions for formatting (already present)
    const formatDate = (timestamp) => {
        if (!timestamp) return 'N/A';
        return new Date(timestamp.seconds * 1000).toLocaleString();
    };

    const formatDuration = (j, cTime) => {
        if (!j.startedAt) return 'N/A';
        let durationSeconds;
        const startTime = j.startedAt.seconds * 1000;
        const pausedMilliseconds = j.totalPausedMilliseconds || 0;
        if (j.status === 'Complete' || j.status === 'Awaiting QC' || j.status === 'Issue' || j.status === 'Archived - Issue') {
            if (!j.completedAt) return 'N/A';
            durationSeconds = (j.completedAt.seconds * 1000 - startTime - pausedMilliseconds) / 1000;
        } else if (j.status === 'In Progress') {
            durationSeconds = (cTime - startTime - pausedMilliseconds) / 1000;
        } else if (j.status === 'Paused' && j.pausedAt) {
            durationSeconds = (j.pausedAt.seconds * 1000 - startTime - pausedMilliseconds) / 1000;
        } else {
            return 'N/A';
        }
        
        if (durationSeconds < 0) return 'N/A';
        const minutes = Math.floor(durationSeconds / 60);
        const seconds = Math.floor(durationSeconds % 60);
        return `${minutes}m ${seconds}s`;
    };

    const formatEfficiency = (j, cTime) => {
        if (!j.estimatedTime || !j.startedAt) return 'N/A';
        let actualSeconds;
        const startTime = j.startedAt.seconds * 1000;
        const pausedMilliseconds = j.totalPausedMilliseconds || 0;
        if (j.status === 'Complete' || j.status === 'Awaiting QC' || j.status === 'Issue' || j.status === 'Archived - Issue') {
            if (!j.completedAt) return 'N/A';
            actualSeconds = (j.completedAt.seconds * 1000 - startTime - pausedMilliseconds) / 1000;
        } else if (j.status === 'In Progress') {
            actualSeconds = (cTime - startTime - pausedMilliseconds) / 1000;
        } else if (j.status === 'Paused' && j.pausedAt) {
            actualSeconds = (j.pausedAt.seconds * 1000 - startTime - pausedMilliseconds) / 1000;
        } else {
            return 'N/A';
        }
        actualSeconds = Math.max(0, actualSeconds);
        if (actualSeconds === 0) return 'N/A';
        const estimatedMinutes = j.estimatedTime;
        const actualMinutes = actualSeconds / 60;
        return `${Math.round((estimatedMinutes / actualMinutes) * 100)}%`;
    };

    const calculateLiveTotalCost = (j, cTime, rates) => {
        if (j.totalCost !== undefined && j.totalCost !== null) {
            return `R${j.totalCost.toFixed(2)}`;
        }
        if (!j.employeeId || !rates[j.employeeId]) {
            return 'N/A';
        }
        const hourlyRate = rates[j.employeeId];
        let activeSeconds = 0;
        const startTime = j.startedAt ?
        j.startedAt.seconds * 1000 : null;
        const pausedMilliseconds = j.totalPausedMilliseconds || 0;
        if (j.status === 'In Progress') {
            if (startTime) {
                activeSeconds = (cTime - startTime - pausedMilliseconds) / 1000;
            }
        } else if (j.status === 'Paused' && j.pausedAt && startTime) {
            activeSeconds = (j.pausedAt.seconds * 1000 - startTime - pausedMilliseconds) / 1000;
        } else {
            return 'N/A';
        }
        activeSeconds = Math.max(0, activeSeconds);
        const activeHours = activeSeconds / 3600;
        const liveLaborCost = activeHours * hourlyRate;
        
        const currentMaterialCost = j.materialCost || 0;
        const totalLiveCost = liveLaborCost + currentMaterialCost;
        return `R${totalLiveCost.toFixed(2)}`;
    };

    const liveDurationFormatted = formatDuration(job, currentTime);
    const liveEfficiencyFormatted = formatEfficiency(job, currentTime);
    const liveTotalCostFormatted = calculateLiveTotalCost(job, currentTime, employeeHourlyRates);

    // Determine if job is editable/deletable
    const isJobActive = ['In Progress', 'Awaiting QC'].includes(job.status);
    // Can edit if Pending, Paused, Complete, Issue, Archived-Issue. NOT In Progress or Awaiting QC.
    const canEdit = !isJobActive && ['Pending', 'Paused', 'Complete', 'Issue', 'Archived - Issue'].includes(job.status);
    // Can delete if Pending, Paused, Complete, Issue, Archived-Issue. NOT In Progress or Awaiting QC.
    const canDelete = !isJobActive && ['Pending', 'Paused', 'Complete', 'Issue', 'Archived - Issue'].includes(job.status);


    // Handlers for editing features
    const handleInputChange = (e) => {
        const { name, value } = e.target;
        setEditableJobData(prev => ({ ...prev, [name]: value }));
    };

    const handleEmployeeChange = (e) => {
        const newEmployeeId = e.target.value;
        const selectedEmployee = allEmployees.find(emp => emp.id === newEmployeeId);
        setEditableJobData(prev => ({
            ...prev,
            employeeId: newEmployeeId,
            employeeName: selectedEmployee ? selectedEmployee.name : 'Unassigned'
        }));
    };

    const handleToolToggle = (toolId) => {
        setEditableJobData(prev => {
            const newTools = new Set(prev.selectedTools);
            if (newTools.has(toolId)) {
                newTools.delete(toolId);
                // Also remove accessories of this tool
                // Filter allToolAccessories directly from props
                const accessoriesOfTool = allToolAccessories.filter(item => item.toolId === toolId).map(a => a.id);
                const newAccessories = new Set(prev.selectedAccessories);
                accessoriesOfTool.forEach(accId => newAccessories.delete(accId));
                return { ...prev, selectedTools: newTools, selectedAccessories: newAccessories };
            } else {
                newTools.add(toolId);
                return { ...prev, selectedTools: newTools };
            }
        });
    };

    const handleAccessoryToggle = (accId) => {
        setEditableJobData(prev => {
            const newAccessories = new Set(prev.selectedAccessories);
            newAccessories.has(accId) ? newAccessories.delete(accId) : newAccessories.add(accId);
            return { ...prev, selectedAccessories: newAccessories };
        });
    };

    const handleAddConsumableToList = (consumable) => {
        setEditableJobData(prev => ({ ...prev, selectedConsumables: [...prev.selectedConsumables, consumable] }));
    };

    const handleRemoveConsumableFromList = (itemId) => {
        setEditableJobData(prev => ({ ...prev, selectedConsumables: prev.selectedConsumables.filter(c => c.itemId !== itemId) }));
    };


    const handleSave = async () => {
        // Basic validation
        if (!editableJobData.partName.trim()) {
            alert("Part Name cannot be empty.");
            return;
        }
        if (editableJobData.estimatedTime < 0) {
            alert("Estimated time cannot be negative.");
            return;
        }
        if (!editableJobData.steps.trim()) {
            alert("Steps cannot be empty.");
            return;
        }

        const updatedData = {
            partName: editableJobData.partName.trim(),
            description: editableJobData.description.trim(),
            estimatedTime: Number(editableJobData.estimatedTime),
            employeeId: editableJobData.employeeId || 'unassigned',
            employeeName: editableJobData.employeeName,
            steps: editableJobData.steps.split('\n').filter(s => s.trim() !== ''),
            // Save the updated tools, accessories, and consumables for this job instance
            tools: Array.from(editableJobData.selectedTools),
            accessories: Array.from(editableJobData.selectedAccessories),
            consumables: editableJobData.selectedConsumables, // Raw consumable objects as they are stored
            // Note: departmentId and photoUrl are generally not editable here as they're part of the recipe or initial job creation.
        };

        try {
            await onUpdateJob(job.id, updatedData);
            alert("Job updated successfully!");
            setIsEditing(false); // Exit edit mode
            // onClose(); // Optionally close modal, or let user review changes
        } catch (error) {
            console.error("Error updating job:", error);
            alert("Failed to update job.");
        }
    };

    const handleDelete = async () => {
        if (window.confirm(`Are you sure you want to permanently delete job "${job.jobId}"? This action cannot be undone.`)) {
            try {
                await onDeleteJob(job.id);
                alert("Job deleted successfully!");
                onClose(); // Close modal after deletion
            } catch (error) {
                console.error("Error deleting job:", error);
                alert("Failed to delete job.");
            }
        }
    };

    return (
        <div 
            onClick={onClose}
            className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 animate-fade-in"
        >
            <div 
                onClick={(e) => e.stopPropagation()}
                className="bg-gray-800 rounded-xl border border-gray-700 w-full max-w-2xl max-h-[90vh] flex flex-col"
            >
                <div className="flex justify-between items-center p-4 border-b border-gray-700">
                    <div>
                        <h2 className="text-xl font-bold text-white">
                            {isEditing ? `Editing: ${job.jobId}` : job.partName}
                        </h2>
                        <p className="text-xs font-mono text-gray-500">{job.jobId}</p>
                    </div>
                    <Button onClick={onClose} variant="secondary" className="p-2">
                        <X size={20} />
                    </Button>
                </div>
                <div className="p-6 overflow-y-auto space-y-6">
                    {isEditing ? (
                        // Edit Mode
                        <div className="space-y-4">
                            <Input 
                                label="Part Name" 
                                name="partName" 
                                value={editableJobData.partName} 
                                onChange={handleInputChange} 
                            />
                            <Dropdown
                                label="Assigned Employee"
                                name="employeeId"
                                value={editableJobData.employeeId}
                                onChange={handleEmployeeChange}
                                options={allEmployees}
                                placeholder="Select Employee..."
                            />
                            <Input
                                label="Estimated Time (minutes)"
                                name="estimatedTime"
                                type="number"
                                value={editableJobData.estimatedTime}
                                onChange={handleInputChange}
                            />
                            <Textarea
                                label="Description"
                                name="description"
                                value={editableJobData.description}
                                onChange={handleInputChange}
                                rows={3}
                            />
                             <Textarea
                                label="Steps (one per line)"
                                name="steps"
                                value={editableJobData.steps}
                                onChange={handleInputChange}
                                rows={5}
                            />

                            {/* Tools & Accessories for Recipe Definition */}
                            <div>
                                <h5 className="font-semibold text-white mb-2">Required Tools & Accessories</h5>
                                <div className="max-h-40 overflow-y-auto space-y-2 p-3 bg-gray-800 rounded-lg">
                                    {/* Filter allTools directly from props */}
                                    {(allTools || []).map(tool => (
                                        <div key={tool.id}>
                                            <label className="flex items-center space-x-2 text-sm font-semibold text-gray-200">
                                                <input type="checkbox" checked={editableJobData.selectedTools.has(tool.id)} onChange={() => handleToolToggle(tool.id)} className="h-4 w-4 rounded bg-gray-700 text-blue-600 focus:ring-blue-500" />
                                                <span>{tool.name}</span>
                                            </label>
                                            {editableJobData.selectedTools.has(tool.id) && (
                                                <div className="pl-6 mt-1 space-y-1 text-xs border-l-2 border-gray-700">
                                                    {/* Filter allToolAccessories directly from props */}
                                                    {(allToolAccessories.filter(acc => acc.toolId === tool.id)).map(accessory => (
                                                        <label key={accessory.id} className="flex items-center space-x-2 text-xs text-gray-300">
                                                            <input type="checkbox" checked={editableJobData.selectedAccessories.has(accessory.id)} onChange={() => handleAccessoryToggle(accessory.id)} className="h-3 w-3 rounded bg-gray-700 text-blue-600 focus:ring-blue-500" />
                                                            <span>{accessory.name}</span>
                                                        </label>
                                                    ))}
                                                </div>
                                            )}
                                        </div>
                                    ))}
                                </div>
                            </div>
                            
                            {/* Consumables for Job Editing */}
                            <div>
                                <ConsumableEditorInModal
                                    // Pass filtered inventory items to ConsumableEditorInModal
                                    allConsumables={allInventoryItems.filter(item => ['Component', 'Raw Material', 'Workshop Supply'].includes(item.category))}
                                    selectedConsumables={editableJobData.selectedConsumables}
                                    onAdd={handleAddConsumableToList}
                                    onRemove={handleRemoveConsumableFromList}
                                />
                            </div>

                            <div className="flex justify-end gap-3 mt-4">
                                <Button onClick={() => setIsEditing(false)} variant="secondary">
                                    <XCircle size={18} className="mr-2"/> Cancel
                                </Button>
                                <Button onClick={handleSave} variant="primary">
                                    <Save size={18} className="mr-2"/> Save Changes
                                </Button>
                            </div>
                        </div>
                    ) : (
                        // View Mode
                        <>
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-2">
                                <DetailRow label="Employee" value={job.employeeName} />
                                <DetailRow label="Status" value={job.status} />
                                <DetailRow label="Created On" value={formatDate(job.createdAt)} />
                                <DetailRow label="Started On" value={formatDate(job.startedAt)} />
                                <DetailRow label="Completed On" value={formatDate(job.completedAt)} />
                                {job.status === 'Paused' && job.pausedAt && (
                                    <DetailRow label="Paused At" value={formatDate(job.pausedAt)} />
                                )}
                                {job.status === 'Issue' && <DetailRow label="Issue Reason" value={job.issueReason || 'N/A'} className="text-red-400 font-semibold" />}
                            </div>
                            <div className="grid grid-cols-1 sm:grid-cols-3 gap-4">
                                <div className="bg-gray-900/50 p-4 rounded-lg text-center">
                                    <Clock size={20} className="mx-auto mb-2 text-blue-400" />
                                    <p className="text-xs text-gray-400">Est. Time</p>
                                    <p className="font-bold">{job.estimatedTime || 'N/A'} min</p>
                                </div>
                                <div className="bg-gray-900/50 p-4 rounded-lg text-center">
                                    <CheckCircle2 size={20} className="mx-auto mb-2 text-green-400" />
                                    <p className="text-xs text-gray-400">Actual Time</p>
                                    <p className="font-bold">{liveDurationFormatted}</p>
                                </div>
                                <div className="bg-gray-900/50 p-4 rounded-lg text-center">
                                    <Zap size={20} className="mx-auto mb-2 text-purple-400" />
                                    <p className="text-xs text-gray-400">Efficiency</p>
                                    <p className="font-bold">{liveEfficiencyFormatted}</p>
                                </div>
                            </div>
                            <div className="grid grid-cols-1 sm:grid-cols-3 gap-4">
                                <div className="bg-gray-900/50 p-4 rounded-lg text-center">
                                    <p className="text-xs text-gray-400">Material Cost</p>
                                    <p className="font-bold font-mono">R{job.materialCost?.toFixed(2) || '0.00'}</p>
                                </div>
                                <div className="bg-gray-900/50 p-4 rounded-lg text-center">
                                    <p className="text-xs text-gray-400">Labor Cost</p>
                                    <p className="font-bold font-mono">R{((job.laborCost === undefined || job.laborCost === null) && job.startedAt && employeeHourlyRates[job.employeeId] !== undefined) ?
                                    (
                                            (formatDuration(job, currentTime).split('m')[0] * employeeHourlyRates[job.employeeId] / 60).toFixed(2)
                                        ) : job.laborCost?.toFixed(2) || '0.00'}
                                    </p>
                                </div>
                                <div className="bg-gray-900/50 p-4 rounded-lg text-center">
                                    <DollarSign size={20} className="mx-auto mb-2 text-yellow-400" />
                                    <p className="text-xs text-gray-400">Total Job Cost</p>
                                    <p className="font-bold font-mono">{liveTotalCostFormatted}</p>
                                </div>
                            </div>
                            <div>
                                <h4 className="font-semibold text-gray-200 mb-2">Consumables Used</h4>
                                <ul className="text-sm text-gray-400 list-disc list-inside bg-gray-900/50 p-4 rounded-lg">
                                    {processedConsumablesForDisplay?.length > 0 ?
                                    processedConsumablesForDisplay.map((c, i) => (
                                        <li key={i}>
                                            {c.name} (Qty: {c.quantity?.toFixed(3) || 'N/A'} {c.unit || ''}) (R{c.price?.toFixed(2) || '0.00'}) {/* CORRECTED LINE */}
                                        </li>
                                    )) : <li>None</li>}
                                </ul>
                            </div>
                            {/* Action Buttons */}
                            <div className="flex justify-end gap-3 mt-6">
                                {canEdit && (
                                    <Button onClick={() => setIsEditing(true)} variant="secondary">
                                        <Edit size={18} className="mr-2"/> Edit Job
                                    </Button>
                                )}
                                {canDelete && (
                                    <Button onClick={handleDelete} variant="danger">
                                        <Trash2 size={18} className="mr-2"/> Delete Job
                                    </Button>
                                )}
                            </div>
                        </>
                    )}
                </div>
            </div>
        </div>
    );
};

export default JobDetailsModal;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\features\tracking\LiveTrackingTable.jsx
==================================================
import React, { useState, useEffect, useMemo } from 'react';
import { listenToJobCards, getEmployees, updateDocument, deleteDocument, getAllInventoryItems, getTools, getToolAccessories } from '../../../api/firestore'; // Added getAllInventoryItems, getTools, getToolAccessories
import JobDetailsModal from './JobDetailsModal';
import { ChevronDown, ChevronRight } from 'lucide-react';

const StatusBadge = ({ status }) => {
    const statusColors = {
        'Pending': 'bg-yellow-500/20 text-yellow-300',
        'In Progress': 'bg-blue-500/20 text-blue-300',
        'Paused': 'bg-orange-500/20 text-orange-300',
        'Awaiting QC': 'bg-purple-500/20 text-purple-300',
        'Complete': 'bg-green-500/20 text-green-300',
        'Issue': 'bg-red-500/20 text-red-400',
        'Archived - Issue': 'bg-gray-600/20 text-gray-400'
    };
    return <span className={`px-3 py-1 text-xs font-semibold rounded-full whitespace-nowrap ${statusColors[status] || 'bg-gray-500/20 text-gray-300'}`}>{status}</span>;
};

const EfficiencyBadge = ({ actualMinutes, estimatedMinutes }) => {
    if (!actualMinutes || !estimatedMinutes) {
        return <span className="text-xs text-gray-500">N/A</span>;
    }
    const efficiency = (estimatedMinutes / actualMinutes) * 100;
    let color = 'bg-yellow-500/20 text-yellow-300';
    if (efficiency < 90) color = 'bg-red-500/20 text-red-400';
    if (efficiency > 110) color = 'bg-green-500/20 text-green-400';
    return <span className={`px-3 py-1 text-xs font-semibold rounded-full ${color}`}>{Math.round(efficiency)}%</span>
};

const JobRow = ({ job, onClick, currentTime, employeeHourlyRates }) => {
    const calculateLiveDuration = (j, cTime) => {
        if (!j.startedAt) return null;
        let durationSeconds;
        const startTime = j.startedAt.seconds * 1000;
        const pausedMilliseconds = j.totalPausedMilliseconds || 0;
        if (j.status === 'Complete' || j.status === 'Awaiting QC' || j.status === 'Issue' || j.status === 'Archived - Issue') {
            if (!j.completedAt) return null;
            durationSeconds = (j.completedAt.seconds * 1000 - startTime - pausedMilliseconds) / 1000;
        } else if (j.status === 'In Progress') {
            durationSeconds = (cTime - startTime - pausedMilliseconds) / 1000;
        } else if (j.status === 'Paused' && j.pausedAt) {
            durationSeconds = (j.pausedAt.seconds * 1000 - startTime - pausedMilliseconds) / 1000;
        } else {
            return null;
        }
        if (durationSeconds < 0) return null;
        const minutes = Math.floor(durationSeconds / 60);
        const seconds = Math.floor(durationSeconds % 60);
        return { text: `${minutes}m ${seconds}s`, totalMinutes: durationSeconds / 60 };
    };

    const calculateLiveCost = (j, cTime, rates) => {
        // If totalCost is already set (e.g., after QC approval), use that value
        if (j.totalCost !== undefined && j.totalCost !== null) {
            return `R ${j.totalCost.toFixed(2)}`;
        }
        if (!j.employeeId || !rates[j.employeeId]) return 'N/A';
        const hourlyRate = rates[j.employeeId];
        if (hourlyRate === 0) return 'N/A';
        let activeSeconds = 0;
        const startTime = j.startedAt ? j.startedAt.seconds * 1000 : null;
        const pausedMilliseconds = j.totalPausedMilliseconds || 0;
        if (j.status === 'In Progress') {
            if (startTime) {
                activeSeconds = (cTime - startTime - pausedMilliseconds) / 1000;
            }
        } else if (j.status === 'Paused' && j.pausedAt && startTime) {
            activeSeconds = (j.pausedAt.seconds * 1000 - startTime - pausedMilliseconds) / 1000;
        } else {
            return 'N/A';
        }
        activeSeconds = Math.max(0, activeSeconds);
        const activeHours = activeSeconds / 3600;
        const liveLaborCost = activeHours * hourlyRate;
        
        const currentMaterialCost = j.materialCost || 0;
        const totalLiveCost = liveLaborCost + currentMaterialCost;
        return `R ${totalLiveCost.toFixed(2)}`;
    };

    const liveDuration = calculateLiveDuration(job, currentTime);
    const liveCost = calculateLiveCost(job, currentTime, employeeHourlyRates);
    const formatDate = (timestamp) => new Date(timestamp.seconds * 1000).toLocaleString();

    return (
        <tr onClick={() => onClick(job)} className="border-b border-gray-700 hover:bg-gray-700/50 cursor-pointer">
            <td className="p-3 text-gray-300 text-sm">{formatDate(job.createdAt)}</td>
            <td className="p-3 text-gray-300">{job.partName}</td>
            <td className="p-3 text-gray-300">{job.employeeName}</td>
            <td className="p-3"><StatusBadge status={job.status} /></td>
            <td className="p-3 text-gray-300 text-sm font-semibold">{liveDuration ? liveDuration.text : 'N/A'}</td>
            <td className="p-3"><EfficiencyBadge actualMinutes={liveDuration?.totalMinutes} estimatedMinutes={job.estimatedTime} /></td>
            <td className="p-3 text-gray-200 text-sm font-semibold font-mono text-right">{liveCost}</td>
        </tr>
    );
};

const LiveTrackingTable = () => {
    const [jobs, setJobs] = useState([]);
    const [employees, setEmployees] = useState([]);
    const [allInventoryItems, setAllInventoryItems] = useState([]); // State for all inventory items
    const [allTools, setAllTools] = useState([]); // State for all tools
    const [allToolAccessories, setAllToolAccessories] = useState([]); // State for all tool accessories
    const [loading, setLoading] = useState(true);
    const [selectedJob, setSelectedJob] = useState(null);
    const [showCompleted, setShowCompleted] = useState(false);
    const [currentTime, setCurrentTime] = useState(Date.now());

    const fetchAllRequiredData = async () => { // Renamed from fetchJobsAndEmployees for clarity
        setLoading(true);
        try {
            const [fetchedEmployees, fetchedInventory, fetchedTools, fetchedToolAccessories] = await Promise.all([
                getEmployees(),
                getAllInventoryItems(), // Fetch all inventory items
                getTools(), // Fetch all tools
                getToolAccessories(), // Fetch all tool accessories
            ]);
            setEmployees(fetchedEmployees);
            setAllInventoryItems(fetchedInventory);
            setAllTools(fetchedTools);
            setAllToolAccessories(fetchedToolAccessories);
            
            // Use onSnapshot for real-time updates on jobs
            const unsubscribe = listenToJobCards((fetchedJobs) => {
                setJobs(fetchedJobs);
                setLoading(false);
            });
            return unsubscribe; // Return unsubscribe to be called on cleanup
        } catch (error) {
            console.error("Failed to fetch initial data for tracking table:", error);
            setLoading(false);
        }
    };

    useEffect(() => {
        let unsubscribeJobs;
        (async () => {
            unsubscribeJobs = await fetchAllRequiredData();
        })();
        
        const intervalId = setInterval(() => {
            setCurrentTime(Date.now());
        }, 1000);

        return () => {
            if (unsubscribeJobs) unsubscribeJobs();
            clearInterval(intervalId);
        };
    }, []); // Empty dependency array means this runs once on mount and cleans up on unmount

    const employeeHourlyRates = useMemo(() => {
        return employees.reduce((acc, emp) => {
            acc[emp.id] = emp.hourlyRate || 0;
            return acc;
        }, {});
    }, [employees]);

    const { activeJobs, completedAndArchivedJobs } = useMemo(() => {
        const statusOrder = { 'In Progress': 1, 'Paused': 2, 'Awaiting QC': 3, 'Pending': 4 };
        
        const active = jobs
            .filter(job => ['In Progress', 'Paused', 'Awaiting QC', 'Pending'].includes(job.status))
            .sort((a, b) => {
                const statusCompare = statusOrder[a.status] - statusOrder[b.status];
                if (statusCompare !== 0) return statusCompare;
                const timeA = a.status === 'In Progress' 
                || a.status === 'Paused' ? a.startedAt : a.createdAt;
                const timeB = b.status === 'In Progress' || b.status === 'Paused' ? b.startedAt : b.createdAt;
                if (timeA && timeB) {
                    return timeB.seconds - timeA.seconds;
                }
                return 0;
            });
        const completed = jobs.filter(job => ['Complete', 'Issue', 'Archived - Issue'].includes(job.status));
        return { activeJobs: active, completedAndArchivedJobs: completed 
        };
    }, [jobs]);

    // Handler for updating a job from the modal
    const handleUpdateJob = async (jobId, updatedData) => {
        try {
            await updateDocument('createdJobCards', jobId, updatedData);
            // The listenToJobCards will automatically update the state, no need for manual setJobs
        } catch (error) {
            console.error("Error updating job from modal:", error);
            throw error; // Re-throw to be caught by the modal's save handler
        }
    };

    // Handler for deleting a job from the modal
    const handleDeleteJob = async (jobId) => {
        try {
            await deleteDocument('createdJobCards', jobId);
            // The listenToJobCards will automatically update the state
        } catch (error) {
            console.error("Error deleting job from modal:", error);
            throw error; // Re-throw to be caught by the modal's delete handler
        }
    };

    if (loading) return <p className="text-center text-gray-400">Loading jobs...</p>;

    return (
        <>
            <div className="bg-gray-800 rounded-xl border border-gray-700 shadow-lg overflow-hidden">
                <div className="overflow-x-auto">
                    <table className="w-full text-left">
                        <thead>
                            <tr className="border-b border-gray-600 bg-gray-900/50">
                                <th className="p-3 text-sm font-semibold text-gray-400">Created</th>
                                <th className="p-3 text-sm font-semibold text-gray-400">Part</th>
                                <th className="p-3 text-sm font-semibold text-gray-400">Employee</th>
                                <th className="p-3 text-sm font-semibold text-gray-400">Status</th>
                                <th className="p-3 text-sm font-semibold text-gray-400">Actual Time</th>
                                <th className="p-3 text-sm font-semibold text-gray-400">Efficiency</th>
                                <th className="p-3 text-sm font-semibold text-gray-400 text-right">Job Cost</th>
                            </tr>
                        </thead>
                        <tbody>
                            {activeJobs.map(job => (
                                <JobRow
                                    key={job.id}
                                    job={job}
                                    onClick={() => setSelectedJob(job)}
                                    currentTime={currentTime}
                                    employeeHourlyRates={employeeHourlyRates}
                                />
                            ))}
                        </tbody>
                    </table>
                    <div className="border-t border-gray-700">
                        <button
                            onClick={() => setShowCompleted(!showCompleted)}
                            className="w-full flex items-center justify-between p-3 text-left text-sm font-semibold text-gray-300 bg-gray-900/30 hover:bg-gray-700/50 transition-colors"
                        >
                            <span>Completed & Archived Jobs ({completedAndArchivedJobs.length})</span>
                            {showCompleted ?
                            <ChevronDown size={20} /> : <ChevronRight size={20} />}
                        </button>
                        {showCompleted && (
                            <table className="w-full text-left">
                                <thead className="invisible h-0">
                                    <tr>
                                        <th className="p-0">Created</th><th className="p-0">Part</th><th className="p-0">Employee</th>
                                        <th className="p-0">Status</th><th className="p-0">Actual Time</th><th className="p-0">Efficiency</th>
                                        <th className="p-0 text-right">Job Cost</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {completedAndArchivedJobs.map(job => (
                                        <JobRow
                                            key={job.id}
                                            job={job}
                                            onClick={() => setSelectedJob(job)}
                                            currentTime={currentTime}
                                            employeeHourlyRates={employeeHourlyRates}
                                        />
                                    ))}
                                </tbody>
                            </table>
                        )}
                    </div>
                </div>
                {selectedJob && (
                    <JobDetailsModal
                        job={selectedJob}
                        onClose={() => setSelectedJob(null)}
                        currentTime={currentTime}
                        employeeHourlyRates={employeeHourlyRates}
                        allEmployees={employees} // Pass allEmployees for dropdown in edit mode
                        onUpdateJob={handleUpdateJob} // Pass update handler
                        onDeleteJob={handleDeleteJob} // Pass delete handler
                        allInventoryItems={allInventoryItems} // Pass all inventory items for consumable editor
                        allTools={allTools} // Pass all tools for tool/accessory selection
                        allToolAccessories={allToolAccessories} // Pass all tool accessories for selection
                    />
                )}
            </div>
        </>
    );
};

export default LiveTrackingTable;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\intelligence\EfficiencyChart.jsx
==================================================
// src/components/intelligence/EfficiencyChart.jsx (New File)

import React, { useMemo } from 'react';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, Legend } from 'recharts';

const CustomTooltip = ({ active, payload, label }) => {
  if (active && payload && payload.length) {
    return (
      <div className="bg-gray-900/80 p-4 border border-gray-700 rounded-lg shadow-lg">
        <p className="label text-sm text-gray-400">{`Date: ${label}`}</p>
        <p className="intro text-white font-bold">{`Efficiency: ${payload[0].value.toFixed(0)}%`}</p>
        <p className="desc text-xs text-gray-500">Job: {payload[0].payload.partName}</p>
      </div>
    );
  }
  return null;
};

const EfficiencyChart = ({ jobs }) => {
  const chartData = useMemo(() => {
    if (!jobs || jobs.length === 0) return [];

    return jobs
      .filter(job => job.status === 'Complete' && job.estimatedTime > 0 && job.startedAt && job.completedAt)
      .map(job => {
        const actualSeconds = (job.completedAt.toDate().getTime() - job.startedAt.toDate().getTime() - (job.totalPausedMilliseconds || 0)) / 1000;
        if (actualSeconds <= 0) return null;

        const efficiency = ((job.estimatedTime * 60) / actualSeconds) * 100;

        return {
          date: new Date(job.completedAt.toDate()).toLocaleDateString('en-ZA'), // Use a consistent date format
          efficiency: efficiency,
          partName: job.partName,
        };
      })
      .filter(Boolean) // Remove any null entries
      .sort((a, b) => new Date(a.date) - new Date(b.date)); // Sort by date to connect the line properly
  }, [jobs]);

  if (chartData.length === 0) {
    return (
        <div className="flex items-center justify-center h-full">
            <p className="text-gray-500">Not enough data to display performance trend.</p>
        </div>
    );
  }

  return (
    <ResponsiveContainer width="100%" height={300}>
      <LineChart
        data={chartData}
        margin={{
          top: 5,
          right: 30,
          left: 0,
          bottom: 5,
        }}
      >
        <CartesianGrid strokeDasharray="3 3" stroke="#4b5563" />
        <XAxis dataKey="date" stroke="#9ca3af" fontSize={12} tickLine={false} axisLine={false} />
        <YAxis stroke="#9ca3af" fontSize={12} tickLine={false} axisLine={false} unit="%" />
        <Tooltip content={<CustomTooltip />} />
        <Legend wrapperStyle={{fontSize: "14px"}} />
        <Line type="monotone" dataKey="efficiency" stroke="#8b5cf6" strokeWidth={2} activeDot={{ r: 8 }} name="Job Efficiency"/>
      </LineChart>
    </ResponsiveContainer>
  );
};

export default EfficiencyChart;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\intelligence\JobCompletionAnalysisWidget.jsx
==================================================
import React, { useState, useEffect } from 'react';
import { getCompletedJobsForEmployee } from '../../api/firestore';
import { CheckCircle2, AlertTriangle } from 'lucide-react';

const JobCompletionAnalysisWidget = ({ employeeId }) => {
    const [stats, setStats] = useState({ onTime: 0, late: 0, total: 0 });
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const calculateStats = async () => {
            if (!employeeId) return;
            setLoading(true);

            try {
                const completedJobs = await getCompletedJobsForEmployee(employeeId);
                
                let onTimeCount = 0;
                let lateCount = 0;

                completedJobs.forEach(job => {
                    // Ensure the job has the necessary data for comparison
                    if (job.estimatedTime && job.startedAt && job.completedAt) {
                        const startTime = job.startedAt.toDate().getTime();
                        const completionTime = job.completedAt.toDate().getTime();
                        const pauseDuration = job.totalPausedMilliseconds || 0;

                        // Calculate actual duration in minutes
                        const actualDurationMinutes = (completionTime - startTime - pauseDuration) / (1000 * 60);

                        if (actualDurationMinutes <= job.estimatedTime) {
                            onTimeCount++;
                        } else {
                            lateCount++;
                        }
                    }
                });

                setStats({
                    onTime: onTimeCount,
                    late: lateCount,
                    total: onTimeCount + lateCount // Only count jobs that could be analyzed
                });

            } catch (error) {
                console.error("Error fetching or calculating job completion stats:", error);
                alert("Could not load job completion stats.");
            }
            setLoading(false);
        };

        calculateStats();
    }, [employeeId]);
    
    const onTimePercentage = stats.total > 0 ? (stats.onTime / stats.total) * 100 : 0;

    return (
        <div className="bg-gray-800/50 p-6 rounded-lg border border-gray-700">
            <h3 className="text-xl font-bold text-white mb-4">Job Completion Analysis</h3>
            {loading ? (
                <p className="text-gray-400">Analyzing job history...</p>
            ) : stats.total === 0 ? (
                <p className="text-gray-400">No completed jobs with time estimates found for this employee.</p>
            ) : (
                <div className="space-y-4">
                    {/* KPI Cards for On-Time and Late */}
                    <div className="grid grid-cols-2 gap-4">
                        <div className="bg-green-500/10 p-4 rounded-lg text-center">
                            <CheckCircle2 className="mx-auto text-green-400 mb-2" size={28} />
                            <p className="text-2xl font-bold text-white">{stats.onTime}</p>
                            <p className="text-sm text-green-400">On-Time / Early</p>
                        </div>
                        <div className="bg-red-500/10 p-4 rounded-lg text-center">
                            <AlertTriangle className="mx-auto text-red-400 mb-2" size={28} />
                            <p className="text-2xl font-bold text-white">{stats.late}</p>
                            <p className="text-sm text-red-400">Late</p>
                        </div>
                    </div>

                    {/* Proportional Bar */}
                    <div>
                        <p className="text-center text-sm text-gray-300 mb-2">
                            On-Time Completion Rate: <span className="font-bold text-white">{onTimePercentage.toFixed(0)}%</span>
                        </p>
                        <div className="flex h-4 w-full bg-red-500/20 rounded-full overflow-hidden border border-gray-700">
                            <div 
                                style={{ width: `${onTimePercentage}%` }}
                                className="bg-green-500 transition-all duration-500"
                            ></div>
                        </div>
                    </div>
                </div>
            )}
        </div>
    );
};

export default JobCompletionAnalysisWidget;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\intelligence\PerformanceLeaderboard.jsx
==================================================
// src/components/intelligence/PerformanceLeaderboard.jsx (Final Version)

import React, { useMemo } from 'react';
import { Link } from 'react-router-dom';
import { Star, Zap, DollarSign, ShieldCheck, CheckCircle } from 'lucide-react'; // Import Star icon

const SortButton = ({ label, active, onClick }) => (
    <button
        onClick={onClick}
        className={`px-4 py-2 text-sm font-semibold rounded-md transition-colors flex items-center gap-2 ${
            active
                ? 'bg-blue-600 text-white shadow-md'
                : 'bg-gray-700/50 text-gray-300 hover:bg-gray-600'
        }`}
    >
        {label}
    </button>
);

const getRankColor = (rank) => {
    switch (rank) {
        case 1: return 'border-yellow-400 bg-yellow-400/10';
        case 2: return 'border-gray-400 bg-gray-400/10';
        case 3: return 'border-orange-500 bg-orange-500/10';
        default: return 'border-gray-700';
    }
};

const PerformanceLeaderboard = ({ employees, activeSortKey, setActiveSortKey }) => {
    const sortConfig = {
        ops: { direction: 'desc', label: 'OPS', unit: '' }, // <-- ADD OPS
        netValueAdded: { direction: 'desc', label: 'Net Value', unit: 'R' },
        avgEfficiency: { direction: 'desc', label: 'Efficiency', unit: '%' },
        reworkRate: { direction: 'asc', label: 'Rework Rate', unit: '%' },
        jobsCompleted: { direction: 'desc', label: 'Jobs Done', unit: '' },
    };

    const sortedEmployees = useMemo(() => {
        if (!employees) return [];
        const key = activeSortKey;
        const direction = sortConfig[key]?.direction || 'desc';
        return [...employees].sort((a, b) => {
            return direction === 'asc' ? a[key] - b[key] : b[key] - a[key];
        });
    }, [employees, activeSortKey]);

    const formatValue = (value, unit) => {
        if (unit === '%') return `${Math.round(value)}%`;
        if (unit === 'R') return `R ${value.toFixed(2)}`;
        if (unit === '') return value.toFixed(1); // For OPS
        return value;
    };

    return (
        <div className="bg-gray-800/50 p-6 rounded-xl border border-gray-700">
            <h3 className="text-xl font-bold text-white mb-4">Performance Leaderboard</h3>
            
            <div className="flex flex-wrap gap-2 mb-4">
                {/* ADD new sort button for OPS */}
                <SortButton label={<><Star size={16}/> Rank by OPS</>} active={activeSortKey === 'ops'} onClick={() => setActiveSortKey('ops')} />
                <SortButton label="Rank by Net Value" active={activeSortKey === 'netValueAdded'} onClick={() => setActiveSortKey('netValueAdded')} />
                <SortButton label="Rank by Efficiency" active={activeSortKey === 'avgEfficiency'} onClick={() => setActiveSortKey('avgEfficiency')} />
                <SortButton label="Rank by Quality" active={activeSortKey === 'reworkRate'} onClick={() => setActiveSortKey('reworkRate')} />
                <SortButton label="Rank by Volume" active={activeSortKey === 'jobsCompleted'} onClick={() => setActiveSortKey('jobsCompleted')} />
            </div>

            <div className="space-y-2 max-h-96 overflow-y-auto pr-2">
                {sortedEmployees.map((emp, index) => {
                    const rank = index + 1;
                    const rankColor = getRankColor(rank);
                    const value = emp[activeSortKey];
                    const unit = sortConfig[activeSortKey]?.unit || '';

                    return (
                        <div key={emp.id} className={`flex items-center p-3 rounded-lg border-l-4 transition-all ${rankColor}`}>
                            <span className="font-bold text-lg text-white w-8">{rank}.</span>
                            <div className="flex-grow">
                                <Link to={`/employee/${emp.id}`} className="font-semibold text-blue-400 hover:underline">
                                    {emp.name}
                                </Link>
                                <p className="text-xs text-gray-400">Department: {emp.departmentName || 'N/A'}</p>
                            </div>
                            <div className="text-right">
                                <p className="font-bold text-lg text-blue-400">{formatValue(value, unit)}</p>
                                <p className="text-xs text-gray-500">{sortConfig[activeSortKey]?.label}</p>
                            </div>
                        </div>
                    );
                })}
            </div>
        </div>
    );
};

export default PerformanceLeaderboard;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\intelligence\PerformanceSnapshot.jsx
==================================================
// src/components/intelligence/PerformanceSnapshot.jsx (New File)

import React, { useMemo } from 'react';
import { TrendingUp, TrendingDown, Users, Target, AlertTriangle } from 'lucide-react';

const Insight = ({ text, type }) => {
    const config = {
        opportunity: {
            icon: <TrendingUp size={18} className="text-green-400" />,
            textColor: 'text-gray-300'
        },
        alert: {
            icon: <AlertTriangle size={18} className="text-red-400" />,
            textColor: 'text-gray-300'
        }
    };
    const current = config[type] || config.alert;

    return (
        <li className="flex items-start space-x-3">
            <div className="flex-shrink-0 mt-1">{current.icon}</div>
            <p className={`text-sm ${current.textColor}`}>{text}</p>
        </li>
    );
};

const PerformanceSnapshot = ({ metrics }) => {
    const insights = useMemo(() => {
        if (!metrics) return [];

        const {
            individual,
            team,
        } = metrics;

        const results = [];

        // Efficiency Insight
        if (individual.efficiency > team.efficiency * 1.1) {
            results.push({ text: `Efficiency (${individual.efficiency.toFixed(0)}%) is significantly above the team average of ${team.efficiency.toFixed(0)}%.`, type: 'opportunity' });
        } else if (individual.efficiency < team.efficiency * 0.9) {
            results.push({ text: `Efficiency (${individual.efficiency.toFixed(0)}%) is below the team average of ${team.efficiency.toFixed(0)}%.`, type: 'alert' });
        }

        // Rework Rate Insight
        if (individual.reworkRate > team.reworkRate + 5) { // If rework is 5% or more higher
            results.push({ text: `Rework Rate (${individual.reworkRate.toFixed(1)}%) is higher than the team average of ${team.reworkRate.toFixed(1)}%.`, type: 'alert' });
        } else if (individual.reworkRate < Math.max(team.reworkRate / 2, 0.5)) { // If it's less than half the team average
            results.push({ text: `This employee maintains an excellent quality score with a Rework Rate of just ${individual.reworkRate.toFixed(1)}%.`, type: 'opportunity' });
        }

        // Net Value Insight
        if (individual.netValueAdded > team.netValueAdded * 1.2) {
            results.push({ text: `This employee is a top value generator, adding R ${individual.netValueAdded.toFixed(0)} compared to the team average of R ${team.netValueAdded.toFixed(0)}.`, type: 'opportunity' });
        } else if (individual.netValueAdded < team.netValueAdded * 0.8) {
             results.push({ text: `Net Value Added (R ${individual.netValueAdded.toFixed(0)}) is lower than the team average (R ${team.netValueAdded.toFixed(0)}).`, type: 'alert' });
        }
        
        return results;

    }, [metrics]);

    return (
        <div className="bg-gray-800/50 p-6 rounded-xl border border-gray-700">
            <h3 className="text-xl font-bold text-white mb-4">Coach's Corner</h3>
            {insights.length > 0 ? (
                <ul className="space-y-3">
                    {insights.map((insight, index) => (
                        <Insight key={index} text={insight.text} type={insight.type} />
                    ))}
                </ul>
            ) : (
                <p className="text-gray-400 text-sm">This employee is performing consistently with the team average.</p>
            )}
        </div>
    );
};

export default PerformanceSnapshot;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\intelligence\ReworkAnalysisModal.jsx
==================================================
// src/components/intelligence/ReworkAnalysisModal.jsx (New File)

import React, { useMemo } from 'react';
import { X } from 'lucide-react';
import Button from '../ui/Button';

const ReworkAnalysisModal = ({ jobs, employeeName, onClose }) => {
    const analysis = useMemo(() => {
        if (!jobs) return {};
        
        const issueJobs = jobs.filter(job => job.status === 'Issue' || job.status === 'Archived - Issue');
        
        const reasons = issueJobs.reduce((acc, job) => {
            const reason = job.issueReason || 'No Reason Provided';
            acc[reason] = (acc[reason] || 0) + 1;
            return acc;
        }, {});

        // Sort reasons from most frequent to least
        return Object.entries(reasons).sort(([, a], [, b]) => b - a);

    }, [jobs]);

    return (
        <div 
            onClick={onClose}
            className="fixed inset-0 bg-black/60 z-50 flex items-center justify-center p-4 animate-fade-in"
        >
            <div 
                onClick={(e) => e.stopPropagation()}
                className="bg-gray-800 rounded-xl border border-gray-700 w-full max-w-lg max-h-[80vh] flex flex-col"
            >
                <div className="flex justify-between items-center p-4 border-b border-gray-700">
                    <div>
                        <h2 className="text-xl font-bold text-white">Root Cause Analysis</h2>
                        <p className="text-sm text-gray-400">For {employeeName}</p>
                    </div>
                    <Button onClick={onClose} variant="secondary" className="p-2">
                        <X size={20} />
                    </Button>
                </div>

                <div className="p-6 overflow-y-auto space-y-3">
                    {analysis.length > 0 ? (
                        analysis.map(([reason, count]) => (
                            <div key={reason} className="flex justify-between items-center bg-gray-700/50 p-3 rounded-lg">
                                <span className="font-medium text-gray-200">{reason}</span>
                                <span className="font-bold text-lg text-red-400">{count} {count > 1 ? 'times' : 'time'}</span>
                            </div>
                        ))
                    ) : (
                        <p className="text-center text-gray-500 py-8">This employee has no jobs with recorded issues.</p>
                    )}
                </div>
            </div>
        </div>
    );
};

export default ReworkAnalysisModal;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\intelligence\SkillProgressionWidget.jsx
==================================================
import React, { useState, useEffect } from 'react';
// 1. IMPORT THE GENERIC deleteDocument FUNCTION and an icon
import { getSkillHistoryForEmployee, getSkills, deleteDocument } from '../../api/firestore';
import Button from '../ui/Button';
import { Trash2 } from 'lucide-react';

const SkillProgressionWidget = ({ employeeId }) => {
    const [skillHistory, setSkillHistory] = useState([]);
    const [allSkills, setAllSkills] = useState([]);
    const [selectedSkillId, setSelectedSkillId] = useState('');
    const [loading, setLoading] = useState(true);

    // Encapsulate fetch logic to be reusable
    const fetchData = async () => {
        if (!employeeId) return;
        setLoading(true);
        try {
            const [history, skills] = await Promise.all([
                getSkillHistoryForEmployee(employeeId),
                getSkills()
            ]);

            // 2. SORT THE DATA IN THE BROWSER (client-side) after fetching
            const sortedHistory = history.sort((a, b) => {
                const dateA = a.assessmentDate?.toDate() || 0;
                const dateB = b.assessmentDate?.toDate() || 0;
                return dateB - dateA; // Sort descending (newest first)
            });

            setSkillHistory(sortedHistory);
            setAllSkills(skills);
            
            if (sortedHistory.length > 0) {
                const skillCounts = sortedHistory.reduce((acc, record) => {
                    acc[record.skillId] = (acc[record.skillId] || 0) + 1;
                    return acc;
                }, {});
                const mostFrequentSkill = Object.keys(skillCounts).sort((a, b) => skillCounts[b] - skillCounts[a])[0];
                setSelectedSkillId(mostFrequentSkill);
            }
        } catch (error) {
            console.error("Error fetching skill progression data:", error);
            alert("Could not load skill history.");
        }
        setLoading(false);
    };

    useEffect(() => {
        fetchData();
    }, [employeeId]);

    // 3. ADD A HANDLER FOR DELETING A HISTORY RECORD
    const handleDeleteHistory = async (recordId) => {
        if (window.confirm("Are you sure you want to permanently delete this history record? This action cannot be undone.")) {
            try {
                await deleteDocument('skillHistory', recordId);
                // Refresh the data from local state for an instant UI update
                setSkillHistory(prev => prev.filter(record => record.id !== recordId));
                alert("History record deleted.");
            } catch (error) {
                console.error("Error deleting history record:", error);
                alert("Failed to delete history record.");
            }
        }
    };

    const filteredHistory = skillHistory.filter(record => record.skillId === selectedSkillId);

    return (
        <div className="bg-gray-800/50 p-6 rounded-lg border border-gray-700">
            <h3 className="text-xl font-bold text-white mb-4">Skill Progression Tracker</h3>
            
            {loading ? (
                <p className="text-gray-400">Loading history...</p>
            ) : allSkills.length === 0 || skillHistory.length === 0 ? (
                <p className="text-gray-400">No skill history available for this employee yet.</p>
            ) : (
                <>
                    <div className="mb-4">
                        <label htmlFor="skill-select" className="block text-sm font-medium text-gray-300 mb-1">
                            Select a skill to see its progression:
                        </label>
                        <select
                            id="skill-select"
                            value={selectedSkillId}
                            onChange={(e) => setSelectedSkillId(e.target.value)}
                            className="bg-gray-900 border border-gray-600 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5"
                        >
                            <option value="" disabled>-- Select a Skill --</option>
                            {allSkills
                                .filter(skill => skillHistory.some(h => h.skillId === skill.id))
                                .map(skill => (
                                <option key={skill.id} value={skill.id}>{skill.name}</option>
                            ))}
                        </select>
                    </div>

                    <div className="space-y-3">
                        {filteredHistory.length > 0 ? (
                            filteredHistory.map(record => (
                                <div key={record.id} className="flex justify-between items-center bg-gray-900/50 p-3 rounded-md">
                                    <div className="flex flex-col">
                                        <p className="font-semibold text-blue-400">{record.proficiency}</p>
                                        <p className="text-gray-500 text-xs">
                                            {record.assessmentDate ? new Date(record.assessmentDate.toDate()).toLocaleString() : 'Date unknown'}
                                        </p>
                                    </div>
                                    {/* 4. ADD THE DELETE BUTTON TO EACH RECORD */}
                                    <Button onClick={() => handleDeleteHistory(record.id)} variant="icon" className="text-red-500 hover:text-red-400">
                                        <Trash2 size={18} />
                                    </Button>
                                </div>
                            ))
                        ) : (
                            <p className="text-gray-400">Please select a skill to view its history.</p>
                        )}
                    </div>
                </>
            )}
        </div>
    );
};

export default SkillProgressionWidget;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\intelligence\ValueWasteAnalysis.jsx
==================================================
import React, { useMemo } from 'react';
import { BarChart, Bar, XAxis, YAxis, Tooltip, Legend, ResponsiveContainer } from 'recharts';

const ValueWasteAnalysis = ({ jobs }) => {
    const timeAnalysisData = useMemo(() => {
        if (!jobs || jobs.length === 0) {
            return { valueAddedHours: 0, nonValueHours: 0, wastedHours: 0 };
        }

        let valueAddedSeconds = 0;
        let nonValueSeconds = 0; // Paused time
        let wastedSeconds = 0;

        jobs.forEach(job => {
            if (!job.startedAt || !job.completedAt) return;

            const startTime = job.startedAt.toDate().getTime();
            const completionTime = job.completedAt.toDate().getTime();
            const totalDurationSeconds = (completionTime - startTime) / 1000;
            const pauseDurationSeconds = (job.totalPausedMilliseconds || 0) / 1000;
            const actualWorkSeconds = totalDurationSeconds - pauseDurationSeconds;

            if (actualWorkSeconds < 0) return;

            // Categorize the time
            if (job.status === 'Complete') {
                valueAddedSeconds += actualWorkSeconds;
                nonValueSeconds += pauseDurationSeconds;
            } else if (job.status === 'Issue' || job.status === 'Archived - Issue') {
                wastedSeconds += actualWorkSeconds;
                nonValueSeconds += pauseDurationSeconds;
            }
        });

        return {
            valueAddedHours: valueAddedSeconds / 3600,
            nonValueHours: nonValueSeconds / 3600,
            wastedHours: wastedSeconds / 3600,
        };
    }, [jobs]);

    const chartData = [
        {
            name: 'Time Allocation',
            // Use keys that are simple and will match the dataKey prop in the <Bar> components
            valueAdded: timeAnalysisData.valueAddedHours,
            paused: timeAnalysisData.nonValueHours,
            wasted: timeAnalysisData.wastedHours,
        }
    ];

    const totalHours = timeAnalysisData.valueAddedHours + timeAnalysisData.nonValueHours + timeAnalysisData.wastedHours;
    if (totalHours === 0) {
        return (
             <div className="bg-gray-800/50 p-6 rounded-xl border border-gray-700">
                <h3 className="text-xl font-bold text-white mb-4">Value vs. Waste Analysis</h3>
                <p className="text-gray-500 text-center py-10">Not enough job history to analyze time allocation.</p>
            </div>
        )
    }

    return (
        <div className="bg-gray-800/50 p-6 rounded-xl border border-gray-700">
            <h3 className="text-xl font-bold text-white mb-4">Value vs. Waste Analysis (Total Hours Logged)</h3>
            <ResponsiveContainer width="100%" height={150}>
                <BarChart data={chartData} layout="vertical" stackOffset="expand">
                    <XAxis type="number" hide domain={[0, 1]} />
                    <YAxis type="category" dataKey="name" hide />
                    <Tooltip 
                        formatter={(value, name) => [`${(value * 100).toFixed(1)}%`, name]}
                        contentStyle={{ backgroundColor: '#1f2937', border: '1px solid #4b5563' }}
                    />
                    <Legend
                        // THIS IS THE CORRECTED FORMATTER LOGIC
                        formatter={(value, entry) => {
                            const { dataKey, color } = entry;
                            const hours = chartData[0][dataKey];
                            return <span style={{ color }}>{value} ({hours.toFixed(1)} hrs)</span>;
                        }}
                        iconType="circle"
                    />
                    {/* The dataKey here now perfectly matches the keys in chartData */}
                    <Bar dataKey="valueAdded" name="Value-Added Time" stackId="a" fill="#22c55e" />
                    <Bar dataKey="paused" name="Non-Value Time (Paused)" stackId="a" fill="#eab308" />
                    <Bar dataKey="wasted" name="Wasted Time (Issues)" stackId="a" fill="#ef4444" />
                </BarChart>
            </ResponsiveContainer>
        </div>
    );
};

export default ValueWasteAnalysis;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\layout\MainLayout.jsx
==================================================
// src/components/layout/MainLayout.jsx (Updated)
import React, { useState } from 'react';
import { NavLink } from 'react-router-dom';
import { useAuth } from '../../contexts/AuthContext';
import Button from '../ui/Button';
import Sidebar from './Sidebar';
import { PanelLeftClose, PanelRightClose } from 'lucide-react';
import TojemLogo from '../../assets/TOJEM 2024.png';

const MainLayout = ({ children }) => {
  const { user, signOut } = useAuth();
  const [isSidebarOpen, setSidebarOpen] = useState(false);
  const linkClass = "px-4 py-2 rounded-lg text-sm font-medium transition-colors";
  const activeLinkClass = "bg-blue-600 text-white";
  const inactiveLinkClass = "text-gray-400 hover:bg-gray-700 hover:text-white";
  return (
    <div className="flex h-screen bg-gray-900 text-white">
      <Sidebar isOpen={isSidebarOpen} />
      <div className="flex-1 flex flex-col overflow-hidden">
        <header className="flex justify-between items-center p-4 border-b border-gray-700 bg-gray-800/50">
          <div className="flex items-center gap-4">
            <Button onClick={() => setSidebarOpen(!isSidebarOpen)} variant="secondary" className="p-2">
              {isSidebarOpen ? <PanelLeftClose size={20}/> : <PanelRightClose size={20}/>}
            </Button>
            <img src={TojemLogo} alt="TOJEM OS Logo" className="h-8 sm:h-10 object-contain" />
          </div>
          <div className="text-right">
            <p className="text-sm text-gray-400">Signed in as {user.email}</p>
            <Button onClick={signOut} variant="secondary" className="mt-1 py-1 px-3 text-xs">
              Sign Out
            </Button>
          </div>
        </header>
        <nav className="flex justify-center bg-gray-800/20 p-2 shadow-lg border-b border-gray-700">
          <div className="flex flex-wrap justify-center gap-2">
            <NavLink to="/" className={({ isActive }) => `${linkClass} ${isActive ? activeLinkClass : inactiveLinkClass}`}>Dashboard</NavLink>
            <NavLink to="/stock" className={({ isActive }) => `${linkClass} ${isActive ? activeLinkClass : inactiveLinkClass}`}>Stock Control</NavLink>
            <NavLink to="/creator" className={({ isActive }) => `${linkClass} ${isActive ? activeLinkClass : inactiveLinkClass}`}>Job Creator</NavLink>
            <NavLink to="/tracking" className={({ isActive }) => `${linkClass} ${isActive ? activeLinkClass : inactiveLinkClass}`}>Tracking</NavLink>
            <NavLink to="/scan" className={({ isActive }) => `${linkClass} ${isActive ? activeLinkClass : inactiveLinkClass}`}>Scanner</NavLink>
            <NavLink to="/qc" className={({ isActive }) => `${linkClass} ${isActive ? activeLinkClass : inactiveLinkClass}`}>QC</NavLink>
            <NavLink to="/issues" className={({ isActive }) => `${linkClass} ${isActive ? activeLinkClass : inactiveLinkClass}`}>Issues</NavLink>
            <NavLink to="/performance" className={({ isActive }) => `${linkClass} ${isActive ? activeLinkClass : inactiveLinkClass}`}>Performance</NavLink>
            
            {/* ADD THE NEW NAVIGATION LINK */}
            <NavLink to="/profitability" className={({ isActive }) => `${linkClass} ${isActive ? activeLinkClass : inactiveLinkClass}`}>Profitability</NavLink>
            
            <NavLink to="/settings" className={({ isActive }) => `${linkClass} ${isActive ? activeLinkClass : inactiveLinkClass}`}>Settings</NavLink>
          </div>
        </nav>
        <main className="flex-1 overflow-y-auto p-4 sm:p-8">
          {children}
        </main>
      </div>
    </div>
  );
};

export default MainLayout;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\layout\ProtectedRoute.jsx
==================================================
import React from 'react';
import { Navigate } from 'react-router-dom';
import { useAuth } from '../../contexts/AuthContext';

const ProtectedRoute = ({ children }) => {
  const { user, loading } = useAuth();

  // 1. While Firebase is checking the auth state, show a loading message.
  if (loading) {
    return (
      <div className="bg-gray-900 min-h-screen flex items-center justify-center text-white">
        Loading Application...
      </div>
    );
  }

  // 2. If loading is finished and there's no user, redirect to the login page.
  if (!user) {
    return <Navigate to="/login" />;
  }

  // 3. If loading is finished and a user exists, show the requested page.
  return children;
};

// Ensure this exact line is at the bottom of the file
export default ProtectedRoute;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\layout\RoleBasedRoute.jsx
==================================================
import React from 'react';
import { useAuth } from '../../contexts/AuthContext';
import { Navigate } from 'react-router-dom';

/**
 * A wrapper for routes that checks if the current user has one of the required roles.
 * If the user is not authorized, it redirects them to the main dashboard.
 * @param {{children: React.ReactNode, roles: Array<string>}} props
 */
const RoleBasedRoute = ({ children, roles }) => {
    const { user } = useAuth();

    if (user && roles.includes(user.role)) {
        return children;
    }

    // Redirect them to the home page if they don't have the right role
    return <Navigate to="/" />;
};

export default RoleBasedRoute;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\layout\Sidebar.jsx
==================================================
import React, { useState } from 'react';
import { SlidersHorizontal, Calendar, Calculator, NotebookText, Sun, ChevronDown, ChevronRight } from 'lucide-react';
import NotesApplet from '../features/sidebar/NotesApplet';
import WeatherApplet from '../features/sidebar/WeatherApplet';
import CalendarApplet from '../features/sidebar/CalendarApplet';
import CalculatorApplet from '../features/sidebar/CalculatorApplet';


// This component can now be opened/closed to show the applet content
const SidebarApplet = ({ icon, text, isOpen, children }) => {
    const [isAppletOpen, setAppletOpen] = useState(false);
    return (
        <div className="my-1">
            <button onClick={() => setAppletOpen(!isAppletOpen)} className="w-full flex items-center p-3 rounded-lg text-gray-300 hover:bg-gray-700 transition-colors">
                {icon}
                {isOpen && <span className="ml-4 font-semibold text-sm">{text}</span>}
                {isOpen && (isAppletOpen ? <ChevronDown size={16} className="ml-auto"/> : <ChevronRight size={16} className="ml-auto"/>)}
            </button>
            {isAppletOpen && isOpen && (
                <div className="mt-1 border-l-2 border-blue-500/30 ml-5 pl-3">
                    {children}
                </div>
            )}
        </div>
    )
};


const Sidebar = ({ isOpen }) => {
  return (
    <div className={`bg-gray-800 border-r border-gray-700 p-4 flex flex-col transition-all duration-300 ${isOpen ? 'w-64' : 'w-20'}`}>
      <div className="flex-grow">
        <SidebarApplet isOpen={isOpen} icon={<NotebookText size={24} />} text="Notes">
            <NotesApplet />
        </SidebarApplet>
        <SidebarApplet isOpen={isOpen} icon={<Sun size={24} />} text="Weather">
            <WeatherApplet />
        </SidebarApplet>
        <SidebarApplet isOpen={isOpen} icon={<Calendar size={24} />} text="Calendar">
            <CalendarApplet />
        </SidebarApplet>
        <SidebarApplet isOpen={isOpen} icon={<Calculator size={24} />} text="Calculator">
            <CalculatorApplet />
        </SidebarApplet>
      </div>
      <div className="border-t border-gray-700 pt-4">
         <a href="/settings" className="w-full flex items-center p-3 rounded-lg text-gray-300 hover:bg-gray-700 transition-colors">
            <SlidersHorizontal size={24} />
            {isOpen && <span className="ml-4 font-semibold text-sm">App Settings</span>}
        </a>
      </div>
    </div>
  );
};

export default Sidebar;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\ui\Button.jsx
==================================================
import React from 'react';

// Base styles for all buttons
const baseStyles = "flex items-center justify-center px-4 py-2 rounded-lg font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-900";

// Styles for different button variants
const variants = {
  primary: "bg-blue-600 hover:bg-blue-700 text-white focus:ring-blue-500",
  secondary: "bg-gray-700 hover:bg-gray-600 text-gray-200 focus:ring-gray-500",
  danger: "bg-red-600 hover:bg-red-700 text-white focus:ring-red-500",
};

const Button = ({ children, onClick, variant = 'primary', className = '', type = 'button', ...props }) => {
  return (
    <button
      type={type}
      onClick={onClick}
      // Combine base styles, variant styles, and any custom classes passed in
      className={`${baseStyles} ${variants[variant]} ${className}`}
      {...props}
    >
      {children}
    </button>
  );
};

export default Button;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\ui\Dropdown.jsx
==================================================
import React from 'react';

const Dropdown = ({ label, name, value, onChange, options, placeholder }) => {
  return (
    <div className="w-full">
      {label && (
        <label htmlFor={name} className="block text-sm font-medium text-gray-400 mb-1">
          {label}
        </label>
      )}
      <select
        id={name}
        name={name}
        value={value}
        onChange={onChange}
        className="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
      >
        {placeholder && <option value="">{placeholder}</option>}
        {options.map(option => (
          <option key={option.id} value={option.id}>
            {option.name}
          </option>
        ))}
      </select>
    </div>
  );
};

export default Dropdown;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\ui\Input.jsx
==================================================
import React from 'react';

const Input = ({ label, name, type = "text", value, onChange, placeholder, ...props }) => {
  return (
    <div className="w-full">
      {label && (
        <label htmlFor={name} className="block text-sm font-medium text-gray-400 mb-1">
          {label}
        </label>
      )}
      <input
        id={name}
        name={name}
        type={type}
        value={value}
        onChange={onChange}
        placeholder={placeholder}
        className="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500"
        {...props}
      />
    </div>
  );
};

export default Input;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\components\ui\Textarea.jsx
==================================================
import React from 'react';

const Textarea = ({ label, name, value, onChange, placeholder, rows = 3 }) => {
  return (
    <div className="w-full">
      {label && (
        <label htmlFor={name} className="block text-sm font-medium text-gray-400 mb-1">
          {label}
        </label>
      )}
      <textarea
        id={name}
        name={name}
        value={value}
        onChange={onChange}
        placeholder={placeholder}
        rows={rows}
        className="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500"
      />
    </div>
  );
};

export default Textarea;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\contexts\AuthContext.jsx
==================================================
import React, { createContext, useState, useEffect, useContext } from 'react';
import { signInWithEmailAndPassword, signOut, onAuthStateChanged } from 'firebase/auth';
import { auth, db } from '../api/firebase';
import { doc, getDoc } from 'firebase/firestore';

export const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, async (userAuth) => {
      if (userAuth) {
        // User is signed in. Fetch their profile from the 'users' collection.
        const userDocRef = doc(db, 'users', userAuth.uid);
        try {
          const userDoc = await getDoc(userDocRef);
          if (userDoc.exists()) {
            // Combine auth data (uid, email) with Firestore data (role, etc.)
            setUser({ uid: userAuth.uid, email: userAuth.email, ...userDoc.data() });
          } else {
            console.warn("User has an auth account but no profile document in 'users' collection.");
            // Assign a default, non-privileged role if no profile is found
            setUser({ uid: userAuth.uid, email: userAuth.email, role: 'default' });
          }
        } catch (error) {
            console.error("Error fetching user profile:", error);
            setUser(userAuth); // Fallback if there's an error
        }
      } else {
        // User is signed out
        setUser(null);
      }
      setLoading(false);
    });
    return unsubscribe;
  }, []);

  const value = {
    user,
    loading,
    signIn: (email, password) => signInWithEmailAndPassword(auth, email, password),
    signOut: () => signOut(auth),
  };

  return (
    <AuthContext.Provider value={value}>
      {!loading && children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  return useContext(AuthContext);
};


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\hooks\useInventoryManager.js
==================================================
import { useState, useEffect, useMemo } from 'react';
import { addToPurchaseQueue } from '../api/firestore';

export const useInventoryManager = (api, suppliers) => {
  const [items, setItems] = useState([]);
  // --- ADD new lastCountedInSessionId field to the initial state ---
  const [newItem, setNewItem] = useState({ 
    name: '', itemCode: '', price: '', unit: '', supplierId: '', 
    currentStock: '', reorderLevel: '', standardStockLevel: '', 
    requiresCatalyst: false, stockTakeMethod: 'quantity', unitWeight: '', tareWeight: '',
    lastCountedInSessionId: '' // New field to track stock take status
  });
  const [editingItemId, setEditingItemId] = useState(null);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState('');
  const [sortBy, setSortBy] = useState('name-asc');
  const [showLowStock, setShowLowStock] = useState(false);

  const fetchData = async () => {
    if (!api) return;
    setLoading(true);
    const fetchedItems = await api.get();
    setItems(fetchedItems);
    setLoading(false);
  };

  useEffect(() => {
    if (api && api.get) {
      fetchData();
    }
  }, [api]);

  const getSupplierName = (supplierId) => (suppliers || []).find(s => s.id === supplierId)?.name || 'N/A';

  const displayedItems = useMemo(() => {
    let filtered = [...(items || [])];
    if (showLowStock) {
      filtered = filtered.filter(item => Number(item.currentStock) < Number(item.reorderLevel));
    }
    if (searchTerm) {
      filtered = filtered.filter(item => item.name.toLowerCase().includes(searchTerm.toLowerCase()));
    }
    filtered.sort((a, b) => {
      switch (sortBy) {
        case 'name-asc': return a.name.localeCompare(b.name);
        case 'name-desc': return b.name.localeCompare(a.name);
        case 'supplier': return getSupplierName(a.supplierId).localeCompare(getSupplierName(b.supplierId));
        case 'stock-low-high': return (Number(a.currentStock) / Number(a.reorderLevel)) - (Number(b.currentStock) / Number(b.reorderLevel));
        case 'stock-high-low': return (Number(b.currentStock) / Number(a.reorderLevel)) - (Number(a.currentStock) / Number(b.reorderLevel));
        default: return 0;
      }
    });
    return filtered;
  }, [items, searchTerm, sortBy, showLowStock, suppliers]);

  const handleInputChange = (e) => {
    const { name, value, type, checked } = e.target;
    const val = type === 'checkbox' ? checked : value;
    setNewItem(prevState => ({ ...prevState, [name]: val }));
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!newItem.name.trim() || !newItem.supplierId) return alert("Item name and supplier are required.");
    
    // --- ADD new lastCountedInSessionId field to the data being saved ---
    const dataToSave = {
      name: newItem.name,
      itemCode: newItem.itemCode || '',
      supplierId: newItem.supplierId,
      price: parseFloat(newItem.price) || 0,
      unit: newItem.unit || '',
      currentStock: parseInt(newItem.currentStock, 10) || 0,
      reorderLevel: parseInt(newItem.reorderLevel, 10) || 0,
      standardStockLevel: parseInt(newItem.standardStockLevel, 10) || 0,
      requiresCatalyst: newItem.requiresCatalyst || false,
      stockTakeMethod: newItem.stockTakeMethod || 'quantity',
      unitWeight: parseFloat(newItem.unitWeight) || 0,
      tareWeight: parseFloat(newItem.tareWeight) || 0,
      lastCountedInSessionId: newItem.lastCountedInSessionId || '', // Ensure it saves
    };

    try {
      let docId = editingItemId;
      if (editingItemId) {
        await api.update(editingItemId, dataToSave);
      } else {
        const newDoc = await api.add(dataToSave);
        docId = newDoc.id;
      }
      
      if (dataToSave.reorderLevel > 0 && dataToSave.currentStock < dataToSave.reorderLevel) {
        await addToPurchaseQueue({
          itemId: docId,
          itemName: dataToSave.name,
          supplierId: dataToSave.supplierId,
          itemCode: dataToSave.itemCode,
          category: api.categoryName
        });
        alert(`'${dataToSave.name}' is low on stock and has been automatically added to the reorder list!`);
      }
      cancelEdit();
      fetchData();
    } catch (error) {
      console.error("Error saving item:", error);
      alert("Failed to save item.");
    }
  };

  const handleEdit = (item) => { setEditingItemId(item.id); setNewItem(item); };
  // --- UPDATE cancelEdit to reset the new field ---
  const cancelEdit = () => { setEditingItemId(null); setNewItem({ name: '', itemCode: '', price: '', unit: '', supplierId: '', currentStock: '', reorderLevel: '', standardStockLevel: '', requiresCatalyst: false, stockTakeMethod: 'quantity', unitWeight: '', tareWeight: '', lastCountedInSessionId: '' }); };
  const handleDelete = async (id) => { if (window.confirm("Are you sure?")) { await api.delete(id); fetchData(); } };

  return {
    newItem, loading, editingItemId, displayedItems, sortBy, searchTerm, showLowStock,
    handleInputChange, handleSubmit, handleEdit, cancelEdit, handleDelete,
    setSortBy, setSearchTerm, setShowLowStock, getSupplierName
  };
};


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\pages\DashboardPage.jsx
==================================================
import React, { useState, useEffect, useMemo } from 'react';
import MainLayout from '../components/layout/MainLayout';
import { listenToJobCards, getAllInventoryItems } from '../api/firestore';
import { NavLink } from 'react-router-dom';
import { Activity, Clock, AlertCircle, ShoppingCart, Gauge } from 'lucide-react';
import { BarChart, Bar, XAxis, YAxis, Tooltip, ResponsiveContainer, PieChart, Pie, Cell } from 'recharts';


const KpiCard = ({ icon, title, value, color }) => (
    <div className="bg-gray-800 p-6 rounded-xl border border-gray-700 flex items-start space-x-4">
        <div className={`p-3 rounded-full ${color}`}>{icon}</div>
        <div><p className="text-gray-400 text-sm">{title}</p><p className="text-3xl font-bold text-white">{value}</p></div>
    </div>
);

const DashboardPage = () => {
    const [jobs, setJobs] = useState([]);
    const [inventory, setInventory] = useState([]);
    const [loading, setLoading] = useState(true);

    const businessData = {
        monthlyTarget: 280000.00,
        currentSales: 71922.50,
        workdaysLeftMonth: 10,
    };

    useEffect(() => {
        const fetchData = async () => {
            const inventoryItems = await getAllInventoryItems();
            setInventory(inventoryItems);
        }
        const unsubscribeJobs = listenToJobCards((fetchedJobs) => {
            setJobs(fetchedJobs);
            setLoading(false);
        });
        fetchData();
        return () => unsubscribeJobs();
    }, []);

    const dashboardData = useMemo(() => {
        const jobsInProgress = jobs.filter(j => j.status === 'In Progress').length;
        const awaitingQc = jobs.filter(j => j.status === 'Awaiting QC').length;
        const issues = jobs.filter(j => j.status === 'Issue');
        const lowStockItems = inventory.filter(item => Number(item.currentStock) < Number(item.reorderLevel)).slice(0, 5);
        const completedJobsWithTime = jobs.filter(j => j.startedAt && j.completedAt && j.estimatedTime > 0);
        let averageEfficiency = 0;
        if (completedJobsWithTime.length > 0) {
            const totalEfficiency = completedJobsWithTime.reduce((acc, job) => {
                const actualSeconds = job.completedAt.seconds - job.startedAt.seconds;
                const estimatedSeconds = job.estimatedTime * 60;
                if(actualSeconds > 0) {
                   return acc + (estimatedSeconds / actualSeconds);
                }
                return acc;
            }, 0);
            averageEfficiency = (totalEfficiency / completedJobsWithTime.length) * 100;
        }

        const statusCounts = jobs.reduce((acc, job) => {
            acc[job.status] = (acc[job.status] || 0) + 1;
            return acc;
        }, {});
        const pieChartData = Object.entries(statusCounts).map(([name, value]) => ({ name, value }));
        const PIE_CHART_COLORS = { 'Complete': '#22c55e', 'In Progress': '#3b82f6', 'Awaiting QC': '#a855f7', 'Issue': '#ef4444', 'Pending': '#eab308' };

        const recentJobsData = Array(7).fill(0).map((_, i) => {
            const date = new Date();
            date.setDate(date.getDate() - i);
            return {
                name: date.toLocaleDateString('en-US', { weekday: 'short' }),
                jobs: 0
            };
        }).reverse();

        const sevenDaysAgo = new Date();
        sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
        
        jobs.forEach(job => {
            if (job.status === 'Complete' && job.completedAt && job.completedAt.toDate() > sevenDaysAgo) {
                const dayName = job.completedAt.toDate().toLocaleDateString('en-US', { weekday: 'short' });
                const dayIndex = recentJobsData.findIndex(d => d.name === dayName);
                if (dayIndex !== -1) {
                    recentJobsData[dayIndex].jobs += 1;
                }
            }
        });

        return {
            kpis: {
                jobsInProgress, awaitingQc, issues: issues.length,
                avgEfficiency: `${Math.round(averageEfficiency)}%`,
            },
            actionableItems: { lowStockItems, jobsWithIssues: jobs.filter(j => j.status === 'Issue').slice(0, 5) },
            charts: {
                pieChartData,
                PIE_CHART_COLORS,
                recentJobsData
            }
        };
    }, [jobs, inventory]);

    if (loading) {
        return <MainLayout><p>Loading Mission Control...</p></MainLayout>;
    }

    return (
        <MainLayout>
            <div className="space-y-10">
                <h2 className="text-3xl font-bold text-white">Mission Control</h2>
                
                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
                    <KpiCard icon={<Activity size={24} />} title="Jobs In Progress" value={dashboardData.kpis.jobsInProgress} color="bg-blue-500/20 text-blue-400" />
                    <KpiCard icon={<Clock size={24} />} title="Awaiting QC" value={dashboardData.kpis.awaitingQc} color="bg-purple-500/20 text-purple-400" />
                    <KpiCard icon={<AlertCircle size={24} />} title="Jobs with Issues" value={dashboardData.kpis.issues} color="bg-red-500/20 text-red-400" />
                    <KpiCard icon={<Gauge size={24} />} title="Avg. Job Efficiency" value={dashboardData.kpis.avgEfficiency} color="bg-teal-500/20 text-teal-400" />
                </div>
                
                <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
                    <div className="lg:col-span-2 bg-gray-800 p-6 rounded-xl border border-gray-700">
                         <h3 className="font-bold text-white mb-4">Jobs Completed This Week</h3>
                         <ResponsiveContainer width="100%" height={300}>
                            <BarChart data={dashboardData.charts.recentJobsData} margin={{ top: 5, right: 20, left: -10, bottom: 5 }}>
                                <XAxis dataKey="name" stroke="#9ca3af" fontSize={12} tickLine={false} axisLine={false} />
                                <YAxis stroke="#9ca3af" fontSize={12} tickLine={false} axisLine={false} allowDecimals={false} />
                                <Tooltip cursor={{fill: 'rgba(107, 114, 128, 0.1)'}} contentStyle={{backgroundColor: '#1f2937', border: '1px solid #4b5563'}}/>
                                <Bar dataKey="jobs" fill="#3b82f6" radius={[4, 4, 0, 0]} />
                            </BarChart>
                         </ResponsiveContainer>
                    </div>
                    <div className="lg:col-span-1 bg-gray-800 p-6 rounded-xl border border-gray-700">
                        <h3 className="font-bold text-white mb-4">Live Job Status Breakdown</h3>
                         <ResponsiveContainer width="100%" height={300}>
                            <PieChart>
                                {/* --- THE FIX IS HERE --- */}
                                <Pie 
                                    data={dashboardData.charts.pieChartData} 
                                    dataKey="value" 
                                    nameKey="name" 
                                    cx="50%" 
                                    cy="50%" 
                                    outerRadius={80} // <-- Changed from 100 to 80 to prevent clipping
                                    labelLine={false} 
                                    label={({ name, percent }) => `${name} (${(percent * 100).toFixed(0)}%)`}
                                >
                                    {dashboardData.charts.pieChartData.map((entry, index) => (
                                        <Cell key={`cell-${index}`} fill={dashboardData.charts.PIE_CHART_COLORS[entry.name] || '#6b7280'} />
                                    ))}
                                </Pie>
                                <Tooltip contentStyle={{backgroundColor: '#1f2937', border: '1px solid #4b5563'}}/>
                            </PieChart>
                         </ResponsiveContainer>
                    </div>
                </div>

                <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                    <div className="bg-gray-800 p-6 rounded-xl border border-gray-700">
                        <h3 className="font-bold text-white mb-4 flex items-center"><ShoppingCart size={20} className="mr-2 text-yellow-400"/> Inventory Alerts</h3>
                        <div className="space-y-3">
                            {dashboardData.actionableItems.lowStockItems.length > 0 ? dashboardData.actionableItems.lowStockItems.map(item => (
                                <div key={item.id} className="text-sm p-3 bg-gray-700/50 rounded-lg flex justify-between items-center">
                                    <div>
                                        <p className="font-semibold text-gray-200">{item.name}</p>
                                        <p className="text-red-400">In Stock: {item.currentStock} (Reorder at {item.reorderLevel})</p>
                                    </div>
                                    <NavLink to="/stock" className="text-blue-400 hover:text-blue-300 font-semibold">View</NavLink>
                                </div>
                            )) : <p className="text-gray-400 text-sm">All stock levels are healthy.</p>}
                        </div>
                    </div>
                    <div className="bg-gray-800 p-6 rounded-xl border border-gray-700">
                        <h3 className="font-bold text-white mb-4 flex items-center"><AlertCircle size={20} className="mr-2 text-red-400"/> Jobs Requiring Attention</h3>
                        <div className="space-y-3">
                            {dashboardData.actionableItems.jobsWithIssues.length > 0 ? dashboardData.actionableItems.jobsWithIssues.map(job => (
                                <div key={job.id} className="text-sm p-3 bg-gray-700/50 rounded-lg">
                                    <p className="font-semibold text-gray-200">{job.partName} <span className="text-xs text-gray-400">({job.jobId})</span></p>
                                    <p className="text-red-400">Reason: {job.issueReason || 'No reason given.'}</p>
                                </div>
                            )) : <p className="text-gray-400 text-sm">No jobs have outstanding issues.</p>}
                        </div>
                    </div>
                </div>
            </div>
        </MainLayout>
    );
};

export default DashboardPage;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\pages\EmployeeIntelligencePage.jsx
==================================================
import React, { useState, useEffect, useMemo } from 'react';
import { useParams, Link } from 'react-router-dom';
import MainLayout from '../components/layout/MainLayout';
import { getDoc, doc } from 'firebase/firestore';
import { db } from '../api/firebase';
import { getCompletedJobsForEmployee, getOverheadCategories, getOverheadExpenses, getEmployees, listenToJobCards } from '../api/firestore';
import { ChevronsLeft, Zap, DollarSign, AlertCircle, CheckCircle2, Users } from 'lucide-react';
import EfficiencyChart from '../components/intelligence/EfficiencyChart';
import PerformanceSnapshot from '../components/intelligence/PerformanceSnapshot';
import ValueWasteAnalysis from '../components/intelligence/ValueWasteAnalysis';
import ReworkAnalysisModal from '../components/intelligence/ReworkAnalysisModal'; // <-- IMPORT NEW MODAL

const KpiCard = ({ icon, title, value, teamAverage, color, onClick }) => (
    <div onClick={onClick} className={`bg-gray-800 p-5 rounded-lg border border-gray-700 flex items-start space-x-4 ${onClick ? 'cursor-pointer hover:bg-gray-700/50' : ''}`}>
        <div className={`p-3 rounded-full ${color}`}>
            {icon}
        </div>
        <div>
            <p className="text-gray-400 text-sm">{title}</p>
            <p className="text-2xl font-bold text-white">{value}</p>
            {teamAverage && (
                 <div className="flex items-center text-xs text-gray-500 mt-1">
                    <Users size={12} className="mr-1"/>
                    <span>Team Avg: {teamAverage}</span>
                </div>
            )}
        </div>
    </div>
);

const EmployeeIntelligencePage = () => {
    const { employeeId } = useParams();
    const [employee, setEmployee] = useState(null);
    const [allEmployees, setAllEmployees] = useState([]);
    const [jobs, setJobs] = useState([]);
    const [allJobs, setAllJobs] = useState([]);
    const [overheads, setOverheads] = useState(0);
    const [loading, setLoading] = useState(true);
    const [isReworkModalOpen, setReworkModalOpen] = useState(false); // <-- NEW STATE FOR MODAL

    useEffect(() => {
        let unsubscribe = () => {};
        const fetchAllData = async () => {
            if (!employeeId) return;
            setLoading(true);
            try {
                const employeeDocRef = doc(db, 'employees', employeeId);
                const [employeeDoc, completedJobs, overheadCategories, allEmps] = await Promise.all([
                    getDoc(employeeDocRef),
                    getCompletedJobsForEmployee(employeeId),
                    getOverheadCategories(),
                    getEmployees(),
                ]);

                if (employeeDoc.exists()) setEmployee({ id: employeeDoc.id, ...employeeDoc.data() });
                setJobs(completedJobs);
                setAllEmployees(allEmps);
                unsubscribe = listenToJobCards(j => setAllJobs(j));

                let totalOverheads = 0;
                const expensePromises = overheadCategories.map(cat => getOverheadExpenses(cat.id));
                const expenseResults = await Promise.all(expensePromises);
                expenseResults.flat().forEach(exp => { totalOverheads += exp.amount || 0; });
                setOverheads(totalOverheads);

            } catch (error) { console.error("Error fetching employee data:", error); }
            setLoading(false);
        };

        fetchAllData();
        return () => unsubscribe();
    }, [employeeId]);

    const performanceMetrics = useMemo(() => {
        // ... (calculations remain the same, no changes needed here) ...
        const metrics = {
            individual: { efficiency: 0, netValueAdded: 0, reworkRate: 0, jobsCompleted: 0 },
            team: { efficiency: 0, netValueAdded: 0, reworkRate: 0 }
        };
        if (!employee || allEmployees.length === 0) return metrics;
        const overheadCostPerHour = overheads / 173.2;
        const issueJobsCount = jobs.filter(j => j.status === 'Issue' || j.status === 'Archived - Issue').length;
        const completedJobs = jobs.filter(j => j.status === 'Complete');
        let individualTotalWorkMinutes = 0, individualTotalEfficiencyRatioSum = 0, individualTotalJobValue = 0;
        completedJobs.forEach(job => {
            if (job.startedAt && job.completedAt) {
                const durationSeconds = (job.completedAt.toDate().getTime() - job.startedAt.toDate().getTime() - (job.totalPausedMilliseconds || 0)) / 1000;
                if(durationSeconds > 0) {
                    individualTotalWorkMinutes += durationSeconds / 60;
                    if (job.estimatedTime > 0) {
                        individualTotalEfficiencyRatioSum += (job.estimatedTime * 60) / durationSeconds;
                    }
                }
            }
            individualTotalJobValue += job.totalCost || 0;
        });
        const individualLaborCost = (individualTotalWorkMinutes / 60) * ((employee.hourlyRate || 0) + overheadCostPerHour);
        metrics.individual = {
            efficiency: completedJobs.length > 0 ? (individualTotalEfficiencyRatioSum / completedJobs.length) * 100 : 0,
            netValueAdded: individualTotalJobValue - individualLaborCost,
            reworkRate: jobs.length > 0 ? (issueJobsCount / jobs.length) * 100 : 0,
            jobsCompleted: jobs.length
        };
        const departmentEmployees = allEmployees.filter(e => e.departmentId === employee.departmentId);
        const departmentEmployeeIds = new Set(departmentEmployees.map(e => e.id));
        const departmentJobs = allJobs.filter(j => j.completedAt && departmentEmployeeIds.has(j.employeeId));
        const teamIssueJobsCount = departmentJobs.filter(j => j.status === 'Issue' || j.status === 'Archived - Issue').length;
        const teamCompletedJobs = departmentJobs.filter(j => j.status === 'Complete');
        let teamTotalEfficiencyRatioSum = 0, teamTotalValue = 0, teamTotalLaborCost = 0;
        teamCompletedJobs.forEach(job => {
            if (job.estimatedTime > 0 && job.startedAt && job.completedAt) {
                const actualSeconds = (job.completedAt.toDate().getTime() - job.startedAt.toDate().getTime() - (job.totalPausedMilliseconds || 0)) / 1000;
                if(actualSeconds > 0) teamTotalEfficiencyRatioSum += (job.estimatedTime * 60) / actualSeconds;
            }
            const jobWorkMinutes = ((job.completedAt.toDate().getTime() - job.startedAt.toDate().getTime() - (job.totalPausedMilliseconds || 0)) / 1000) / 60;
            const employeeForJob = allEmployees.find(e => e.id === job.employeeId);
            if(employeeForJob) teamTotalLaborCost += (jobWorkMinutes / 60) * ((employeeForJob.hourlyRate || 0) + overheadCostPerHour);
            teamTotalValue += job.totalCost || 0;
        });
        metrics.team = {
            efficiency: teamCompletedJobs.length > 0 ? (teamTotalEfficiencyRatioSum / teamCompletedJobs.length) * 100 : 0,
            netValueAdded: departmentEmployees.length > 0 ? (teamTotalValue - teamTotalLaborCost) / departmentEmployees.length : 0,
            reworkRate: departmentJobs.length > 0 ? (teamIssueJobsCount / departmentJobs.length) * 100 : 0
        };
        return metrics;
    }, [employee, jobs, allEmployees, allJobs, overheads]);

    if (loading) return <MainLayout><p className="text-white text-center">Loading Performance & Value Engine...</p></MainLayout>;
    if (!employee) return <MainLayout><p className="text-red-500 text-center">Employee not found.</p></MainLayout>;

    return (
        <MainLayout>
            <div className="space-y-8">
                {/* Header */}
                <div>
                    <Link to="/performance" className="flex items-center text-blue-400 hover:text-blue-300 mb-4">
                        <ChevronsLeft size={20} className="mr-1" />
                        Back to Business Performance Dashboard
                    </Link>
                    <div className="bg-gray-800/50 p-6 rounded-lg border border-gray-700">
                        <h2 className="text-3xl font-bold text-white">{employee.name}</h2>
                        <p className="text-gray-400">Performance & Value Engine</p>
                    </div>
                </div>

                {/* KPI Grid */}
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
                    <KpiCard icon={<Zap size={24} />} title="Overall Efficiency" value={`${performanceMetrics.individual.efficiency.toFixed(0)}%`} teamAverage={`${performanceMetrics.team.efficiency.toFixed(0)}%`} color="bg-purple-500/20 text-purple-400" />
                    <KpiCard icon={<DollarSign size={24} />} title="Net Value Added (Period)" value={`R ${performanceMetrics.individual.netValueAdded.toFixed(2)}`} teamAverage={`R ${performanceMetrics.team.netValueAdded.toFixed(2)}`} color="bg-green-500/20 text-green-400" />
                    {/* MAKE THIS CARD CLICKABLE */}
                    <KpiCard icon={<AlertCircle size={24} />} title="Rework / Issue Rate" value={`${performanceMetrics.individual.reworkRate.toFixed(1)}%`} teamAverage={`${performanceMetrics.team.reworkRate.toFixed(1)}%`} color="bg-red-500/20 text-red-400" onClick={() => setReworkModalOpen(true)} />
                    <KpiCard icon={<CheckCircle2 size={24} />} title="Jobs Completed" value={performanceMetrics.individual.jobsCompleted} color="bg-blue-500/20 text-blue-400" />
                </div>

                <PerformanceSnapshot metrics={performanceMetrics} />

                <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                    <div className="bg-gray-800/50 p-6 rounded-lg border border-gray-700">
                        <h3 className="text-xl font-bold text-white mb-4">Efficiency Over Time</h3>
                        <EfficiencyChart jobs={jobs} />
                    </div>
                    <ValueWasteAnalysis jobs={jobs} />
                </div>
            </div>

            {/* CONDITIONALLY RENDER THE MODAL */}
            {isReworkModalOpen && (
                <ReworkAnalysisModal 
                    jobs={jobs}
                    employeeName={employee.name}
                    onClose={() => setReworkModalOpen(false)}
                />
            )}
        </MainLayout>
    );
};

export default EmployeeIntelligencePage;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\pages\IssuesPage.jsx
==================================================
import React, { useState, useEffect, useMemo } from 'react';
import MainLayout from '../components/layout/MainLayout';
import { listenToJobCards, updateJobStatus } from '../api/firestore';
import JobDetailsModal from '../components/features/tracking/JobDetailsModal';
import Button from '../components/ui/Button';

const IssuesPage = () => {
    const [jobs, setJobs] = useState([]);
    const [loading, setLoading] = useState(true);
    const [selectedJob, setSelectedJob] = useState(null);

    useEffect(() => {
        const unsubscribe = listenToJobCards((fetchedJobs) => {
            setJobs(fetchedJobs);
            setLoading(false);
        });
        return () => unsubscribe();
    }, []);

    // Filter for only jobs with the 'Issue' status
    const issueJobs = useMemo(() => {
        return jobs.filter(job => job.status === 'Issue');
    }, [jobs]);

    // Action to archive the job, effectively removing it from this list
    const handleArchive = async (jobId) => {
        if (window.confirm("Are you sure you want to archive this issue? This action cannot be undone.")) {
            try {
                // We'll give it a new status to filter it out permanently
                await updateJobStatus(jobId, 'Archived - Issue');
                alert("Issue has been archived.");
            } catch (error) {
                console.error("Failed to archive issue:", error);
                alert("Error: Could not archive the issue.");
            }
        }
    };

    return (
        <>
            <MainLayout>
                <div className="space-y-8">
                    <h2 className="text-3xl font-bold text-white">Jobs Requiring Attention</h2>

                    <div className="bg-gray-800 rounded-lg border border-gray-700 overflow-hidden">
                        <div className="overflow-x-auto">
                            <table className="w-full text-left">
                                <thead>
                                    <tr className="border-b border-gray-600 bg-gray-900/50">
                                        <th className="p-3 text-sm font-semibold text-gray-400">Part</th>
                                        <th className="p-3 text-sm font-semibold text-gray-400">Employee</th>
                                        <th className="p-3 text-sm font-semibold text-gray-400">Reason for Rejection</th>
                                        <th className="p-3 text-sm font-semibold text-gray-400 text-right">Actions</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {loading ? (
                                        <tr><td colSpan="4" className="text-center p-8 text-gray-400">Loading issues...</td></tr>
                                    ) : issueJobs.length === 0 ? (
                                        <tr><td colSpan="4" className="text-center p-8 text-gray-400">No jobs require attention.</td></tr>
                                    ) : (
                                        issueJobs.map(job => (
                                            <tr key={job.id} className="border-b border-gray-700">
                                                <td className="p-3 text-gray-200">{job.partName} <span className="text-xs text-gray-500 block">{job.jobId}</span></td>
                                                <td className="p-3 text-gray-300">{job.employeeName}</td>
                                                <td className="p-3 text-red-400 italic">{job.issueReason || 'No reason provided.'}</td>
                                                <td className="p-3 text-right flex gap-2 justify-end">
                                                    <Button variant="secondary" onClick={() => setSelectedJob(job)}>View Details</Button>
                                                    <Button variant="danger" onClick={() => handleArchive(job.id)}>Archive</Button>
                                                </td>
                                            </tr>
                                        ))
                                    )}
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </MainLayout>

            {/* Reuse the JobDetailsModal we already built! */}
            {selectedJob && (
                <JobDetailsModal job={selectedJob} onClose={() => setSelectedJob(null)} />
            )}
        </>
    );
};

export default IssuesPage;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\pages\JobCreatorPage.jsx
==================================================
import React, { useState } from 'react'; // Removed useEffect, useMemo since cloning logic is gone
import MainLayout from '../components/layout/MainLayout';
import JobCardCreator from '../components/features/job_cards/JobCardCreator';
import CustomJobCreator from '../components/features/job_cards/CustomJobCreator';
// Removed searchPreviousJobs import as CloneJobSearch is removed
// Removed Search icon import as CloneJobSearch is removed
// Removed Input import as CloneJobSearch is removed

// Removed CloneJobSearch component entirely as it's no longer needed.

const JobCreatorPage = () => {
    // Simplified mode state, no need for jobToClone
    const [mode, setMode] = useState('catalog'); // 'catalog' or 'custom'

    // Removed handleJobSelectForCloning as cloning functionality is removed

    return (
        <MainLayout>
            <div className="space-y-8">
                <h2 className="text-3xl font-bold text-white">Job Card Creator</h2>

                {/* Mode Selection Tabs */}
                <div className="flex gap-2 p-1 bg-gray-800 rounded-lg max-w-xl mx-auto">
                    <button
                        onClick={() => setMode('catalog')}
                        className={`flex-1 p-2 text-sm font-semibold rounded-md transition-colors ${mode === 'catalog' ? 'bg-blue-600 text-white' : 'hover:bg-gray-700'}`}
                    >
                        Create from Catalog
                    </button>
                    {/* Removed 'Clone Previous Job' button */}
                    <button
                        onClick={() => setMode('custom')}
                        className={`flex-1 p-2 text-sm font-semibold rounded-md transition-colors ${mode === 'custom' ? 'bg-blue-600 text-white' : 'hover:bg-gray-700'}`} // 
                    >
                        Create Custom Job
                    </button>
                </div>

                {/* Removed rendering for CloneJobSearch */}

                {mode === 'custom' && <CustomJobCreator />} {/*  */}

                {/* Always render JobCardCreator for 'catalog' mode */}
                {mode === 'catalog' && (
                    <JobCardCreator
                        // Removed jobToClone prop entirely as it's no longer used
                        key="catalog-job-creation" // Key ensures component remounts for fresh state for every catalog creation
                    />
                )}
            </div>
        </MainLayout>
    );
};

export default JobCreatorPage;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\pages\LiveTrackingPage.jsx
==================================================
import React from 'react';
import MainLayout from '../components/layout/MainLayout';
import LiveTrackingTable from '../components/features/tracking/LiveTrackingTable';

const LiveTrackingPage = () => {
  return (
    <MainLayout>
      <div className="space-y-8">
        <h2 className="text-3xl font-bold text-white">Live Job Tracking</h2>
        <LiveTrackingTable />
      </div>
    </MainLayout>
  );
};

export default LiveTrackingPage;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\pages\Login.jsx
==================================================
import React, { useState } from 'react';
import { useAuth } from '../contexts/AuthContext';
import Button from '../components/ui/Button';
import Input from '../components/ui/Input';
import TojemLogo from '../assets/TOJEM 2024.png'; // Import your logo image

const LoginPage = () => {
Â  const [email, setEmail] = useState('');
Â  const [password, setPassword] = useState('');
Â  const [error, setError] = useState('');
Â  const { signIn } = useAuth();

Â  const handleLogin = async (e) => {
Â  Â  e.preventDefault();
Â  Â  setError('');
Â  Â  try {
Â  Â  Â  await signIn(email, password);
Â  Â  Â  // The onAuthStateChanged listener will handle the redirect
Â  Â  } catch (err) {
Â  Â  Â  setError('Failed to sign in. Please check your credentials.');
Â  Â  Â  console.error(err);
Â  Â  }
Â  };

Â  return (
Â  Â  <div className="bg-gray-900 min-h-screen flex items-center justify-center text-white">
Â  Â  Â  <div className="bg-gray-800 p-8 rounded-xl border border-gray-700 shadow-lg w-full max-w-md">
        {/* Replaced H1 text with your logo image for the login page */}
Â  Â  Â  Â  <img src={TojemLogo} alt="TOJEM OS Logo" className="h-16 mx-auto mb-4 object-contain" />
Â  Â  Â  Â  <p className="text-gray-400 text-center mb-6">Please sign in to continue</p>
Â  Â  Â  Â  <form onSubmit={handleLogin} className="space-y-6">
Â  Â  Â  Â  Â  <Input
Â  Â  Â  Â  Â  Â  label="Email"
Â  Â  Â  Â  Â  Â  name="email"
Â  Â  Â  Â  Â  Â  type="email"
Â  Â  Â  Â  Â  Â  value={email}
Â  Â  Â  Â  Â  Â  onChange={(e) => setEmail(e.target.value)}
Â  Â  Â  Â  Â  Â  placeholder="you@company.com"
Â  Â  Â  Â  Â  />
Â  Â  Â  Â  Â  <Input
Â  Â  Â  Â  Â  Â  label="Password"
Â  Â  Â  Â  Â  Â  name="password"
Â  Â  Â  Â  Â  Â  type="password"
Â  Â  Â  Â  Â  Â  value={password}
Â  Â  Â  Â  Â  Â  onChange={(e) => setPassword(e.target.value)}
Â  Â  Â  Â  Â  Â  placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢"
Â  Â  Â  Â  Â  />
Â  Â  Â  Â  Â  {error && <p className="text-red-500 text-sm text-center">{error}</p>}
Â  Â  Â  Â  Â  <Button type="submit" className="w-full">
Â  Â  Â  Â  Â  Â  Sign In
Â  Â  Â  Â  Â  </Button>
Â  Â  Â  Â  </form>
Â  Â  Â  </div>
Â  Â  </div>
Â  );
};

export default LoginPage;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\pages\PerformancePage.jsx
==================================================
import React, { useState, useEffect, useMemo } from 'react';
import { Link } from 'react-router-dom';
import MainLayout from '../components/layout/MainLayout';
import { getEmployees, listenToJobCards, getOverheadCategories, getOverheadExpenses, getDepartments } from '../api/firestore';
import Button from '../components/ui/Button';
import Input from '../components/ui/Input';
import Dropdown from '../components/ui/Dropdown';
import { CheckCircle2, AlertCircle, BarChart2, Clock, DollarSign, Zap, ArrowDown, ArrowUp, Award, Star } from 'lucide-react';
import PerformanceLeaderboard from '../components/intelligence/PerformanceLeaderboard';

const KpiCard = ({ icon, title, value, color }) => (
    <div className="bg-gray-800 p-5 rounded-lg border border-gray-700 flex items-start space-x-4">
        <div className={`p-3 rounded-full ${color}`}>
            {icon}
        </div>
        <div>
            <p className="text-gray-400 text-sm">{title}</p>
            <p className="text-2xl font-bold text-white">{value}</p>
        </div>
    </div>
);

const PerformancePage = () => {
    // Component states
    const [employees, setEmployees] = useState([]);
    const [jobs, setJobs] = useState([]);
    const [departments, setDepartments] = useState([]);
    const [overheadCategories, setOverheadCategories] = useState([]);
    const [allOverheadExpenses, setAllOverheadExpenses] = useState([]);
    const [loading, setLoading] = useState(true);
    const [activeRange, setActiveRange] = useState('all');
    const [customStartDate, setCustomStartDate] = useState('');
    const [customEndDate, setCustomEndDate] = useState('');
    const [selectedEmployeeIdFilter, setSelectedEmployeeIdFilter] = useState('all');
    const [sortConfig, setSortConfig] = useState({ key: 'ops', direction: 'descending' });
    const [leaderboardSortKey, setLeaderboardSortKey] = useState('ops');
    // THIS IS THE FIX: Re-adding the missing state definition
    const [leaderboardDepartmentFilter, setLeaderboardDepartmentFilter] = useState('all');

    // Effect hook for data fetching
    useEffect(() => {
        let unsubscribeJobs = () => {};
        const fetchAllDataAndSetupListeners = async () => {
            setLoading(true);
            try {
                const [fetchedEmployees, fetchedCategories, fetchedDepartments] = await Promise.all([
                    getEmployees(),
                    getOverheadCategories(),
                    getDepartments()
                ]);
                
                setDepartments(fetchedDepartments);
                const departmentsMap = new Map(fetchedDepartments.map(d => [d.id, d.name]));
                const employeesWithDeptName = fetchedEmployees.map(emp => ({ ...emp, departmentName: departmentsMap.get(emp.departmentId) || 'Unknown' }));
                setEmployees(employeesWithDeptName);
                setOverheadCategories(fetchedCategories);

                const expensePromises = fetchedCategories.map(category => getOverheadExpenses(category.id));
                const results = await Promise.all(expensePromises);
                setAllOverheadExpenses(results.flat());
                unsubscribeJobs = listenToJobCards((fetchedJobs) => setJobs(fetchedJobs));
                setLoading(false);
            } catch (error) {
                console.error("Failed to fetch all data for performance page:", error);
                setLoading(false);
            }
        };

        fetchAllDataAndSetupListeners();
        return () => { if (unsubscribeJobs) unsubscribeJobs(); };
    }, []);

    const requestSort = (key) => {
        let direction = 'descending';
        if (sortConfig.key === key && sortConfig.direction === 'descending') {
            direction = 'ascending';
        }
        setSortConfig({ key, direction });
    };

    const getSortIndicator = (key) => {
        if (sortConfig.key === key) {
            return sortConfig.direction === 'ascending' ? <ArrowUp size={14} className="ml-1" /> : <ArrowDown size={14} className="ml-1" />;
        }
        return null;
    };
    
    const performanceData = useMemo(() => {
        if (loading) {
            return {
                overallKpis: { jobsCompleted: 0, totalWorkHours: "0.0", avgEfficiency: "0%", totalJobValue: "R 0.00" },
                employeePerformanceMetrics: [],
                currentLabel: 'Loading...'
            };
        }
        
        const now = new Date();
        let reportStartDate = null;
        let reportEndDate = new Date();
        const dateRangeLabels = { '1d': 'Last 24 Hours', '7d': 'Last 7 Days', '30d': 'Last 30 Days', 'all': 'All Time', 'custom': 'Custom Range' };
        const currentLabel = dateRangeLabels[activeRange];

        if (activeRange === '1d') { reportStartDate = new Date(now); reportStartDate.setDate(now.getDate() - 1); } 
        else if (activeRange === '7d') { reportStartDate = new Date(now); reportStartDate.setDate(now.getDate() - 7); } 
        else if (activeRange === '30d') { reportStartDate = new Date(now); reportStartDate.setDate(now.getDate() - 30); } 
        else if (activeRange === 'custom') {
            reportStartDate = customStartDate ? new Date(customStartDate) : null;
            reportEndDate = customEndDate ? new Date(customEndDate) : null;
            if (reportStartDate) reportStartDate.setHours(0, 0, 0, 0);
            if (reportEndDate) reportEndDate.setHours(23, 59, 59, 999);
        }
        if (reportStartDate && activeRange !== 'custom') reportStartDate.setHours(0,0,0,0);

        const dateFilteredJobs = (jobs || []).filter(job => {
            if (!job.completedAt) return false;
            const jobCompletedDate = job.completedAt?.toDate();
            if (!jobCompletedDate) return false;
            if (reportStartDate && jobCompletedDate < reportStartDate) return false;
            if (reportEndDate && jobCompletedDate > reportEndDate) return false;
            return true;
        });
        
        const totalMonthlyOverheads = (allOverheadExpenses || []).reduce((sum, exp) => sum + (exp.amount || 0), 0);
        const totalCompanyProductiveHours = (employees.length || 0) * 45 * 4.33;
        const overheadCostPerProductiveHour = totalCompanyProductiveHours > 0 ? totalMonthlyOverheads / totalCompanyProductiveHours : 0;

        let employeeMetrics = (employees || []).map(emp => {
            const empJobs = dateFilteredJobs.filter(job => job.employeeId === emp.id);
            const empJobsCompleted = empJobs.length;
            const empIssueJobs = empJobs.filter(j => j.status === 'Issue' || j.status === 'Archived - Issue').length;
            
            let empTotalWorkMinutes = 0, empTotalEfficiencyRatioSum = 0, empTotalJobValue = 0;
            empJobs.forEach(job => {
                if (job.startedAt && job.completedAt) {
                    const durationSeconds = Math.max(0, (job.completedAt.toDate().getTime() - job.startedAt.toDate().getTime() - (job.totalPausedMilliseconds || 0)) / 1000);
                    if (durationSeconds > 0) empTotalWorkMinutes += durationSeconds / 60;
                    if (job.estimatedTime > 0 && durationSeconds > 0) empTotalEfficiencyRatioSum += (job.estimatedTime * 60) / durationSeconds;
                }
                if (typeof job.totalCost === 'number') empTotalJobValue += job.totalCost;
            });

            const empAvgEfficiency = empJobsCompleted > 0 ? (empTotalEfficiencyRatioSum / empJobsCompleted) * 100 : 0;
            const burdenedRate = (emp.hourlyRate || 0) + overheadCostPerProductiveHour;
            const totalLaborCost = (empTotalWorkMinutes / 60) * burdenedRate;
            
            return {
                ...emp,
                jobsCompleted: empJobsCompleted,
                avgEfficiency: empAvgEfficiency,
                netValueAdded: empTotalJobValue - totalLaborCost,
                reworkRate: empJobsCompleted > 0 ? (empIssueJobs / empJobsCompleted) * 100 : 0,
            };
        });

        const maxNetValue = Math.max(1, ...employeeMetrics.map(e => e.netValueAdded));
        const maxEfficiency = Math.max(100, ...employeeMetrics.map(e => e.avgEfficiency));

        const employeePerformanceMetrics = employeeMetrics.map(emp => {
            const netValueScore = Math.max(0, (emp.netValueAdded / maxNetValue) * 100);
            const efficiencyScore = Math.max(0, (emp.avgEfficiency / maxEfficiency) * 100);
            const qualityScore = Math.max(0, 100 - emp.reworkRate);
            
            const ops = (efficiencyScore * 0.4) + (netValueScore * 0.4) + (qualityScore * 0.2);
            
            return { ...emp, ops };
        });

        const jobsForOverallKpis = selectedEmployeeIdFilter === 'all'
            ? dateFilteredJobs
            : dateFilteredJobs.filter(job => job.employeeId === selectedEmployeeIdFilter);
        
        const overallJobsCompleted = jobsForOverallKpis.length;
        const overallTotalWorkMinutes = jobsForOverallKpis.reduce((acc, job) => acc + (Math.max(0, ((job.completedAt?.toDate().getTime() || 0) - (job.startedAt?.toDate().getTime() || 0) - (job.totalPausedMilliseconds || 0))) / 60000), 0);
        const overallAvgEfficiency = jobsForOverallKpis.length > 0 ? jobsForOverallKpis.reduce((acc, job) => {
            const actual = Math.max(0, ((job.completedAt?.toDate().getTime() || 0) - (job.startedAt?.toDate().getTime() || 0) - (job.totalPausedMilliseconds || 0)) / 1000);
            if(job.estimatedTime > 0 && actual > 0) return acc + (((job.estimatedTime * 60) / actual) * 100);
            return acc;
        }, 0) / jobsForOverallKpis.length : 0;
        const overallTotalJobValue = jobsForOverallKpis.reduce((acc, job) => acc + (job.totalCost || 0), 0);

        return {
            overallKpis: {
                jobsCompleted: overallJobsCompleted,
                totalWorkHours: overallTotalWorkMinutes.toFixed(1),
                avgEfficiency: `${Math.round(overallAvgEfficiency)}%`,
                totalJobValue: `R ${overallTotalJobValue.toFixed(2)}`,
            },
            employeePerformanceMetrics,
            currentLabel
        };
    }, [jobs, activeRange, employees, allOverheadExpenses, customStartDate, customEndDate, selectedEmployeeIdFilter, loading]);
    
    const sortedMetrics = useMemo(() => {
        const metrics = leaderboardDepartmentFilter === 'all'
            ? performanceData.employeePerformanceMetrics
            : performanceData.employeePerformanceMetrics.filter(e => e.departmentId === leaderboardDepartmentFilter);
        
        return [...metrics].sort((a, b) => {
            if (sortConfig.key) {
                return sortConfig.direction === 'ascending' ? a[sortConfig.key] - b[sortConfig.key] : b[sortConfig.key] - a[sortConfig.key];
            }
            return 0;
        });
    }, [performanceData.employeePerformanceMetrics, leaderboardDepartmentFilter, sortConfig]);

    return (
        <MainLayout>
            <div className="space-y-8">
                <h2 className="text-3xl font-bold text-white">Business Performance Dashboard</h2>
                
                <div className="bg-gray-800 p-4 rounded-lg border border-gray-700">
                    <div className="flex flex-wrap items-center justify-center gap-2">
                        <Button variant={activeRange === '1d' ? 'primary' : 'secondary'} onClick={() => setActiveRange('1d')}>Last 24 Hours</Button>
                        <Button variant={activeRange === '7d' ? 'primary' : 'secondary'} onClick={() => setActiveRange('7d')}>Last 7 Days</Button>
                        <Button variant={activeRange === '30d' ? 'primary' : 'secondary'} onClick={() => setActiveRange('30d')}>Last 30 Days</Button>
                        <Button variant={activeRange === 'all' ? 'primary' : 'secondary'} onClick={() => setActiveRange('all')}>All Time</Button>
                    </div>
                </div>

                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
                    <KpiCard icon={<CheckCircle2 size={24} />} title="Jobs Completed" value={performanceData.overallKpis.jobsCompleted} color="bg-green-500/20 text-green-400" />
                    <KpiCard icon={<Clock size={24} />} title="Total Work Time" value={`${performanceData.overallKpis.totalWorkHours} hrs`} color="bg-blue-500/20 text-blue-400" />
                    <KpiCard icon={<Zap size={24} />} title="Average Efficiency" value={performanceData.overallKpis.avgEfficiency} color="bg-purple-500/20 text-purple-400" />
                    <KpiCard icon={<DollarSign size={24} />} title="Total Job Value" value={performanceData.overallKpis.totalJobValue} color="bg-yellow-500/20 text-yellow-400" />
                </div>
                
                <div className="bg-gray-800 p-6 rounded-xl border border-gray-700">
                    <div className="flex flex-wrap justify-between items-center mb-4 gap-4">
                        <h3 className="text-xl font-bold text-white">
                            Performance Leaderboard <span className="text-base font-normal text-gray-400">({performanceData.currentLabel})</span>
                        </h3>
                        <div className="w-full sm:w-1/4">
                            <Dropdown
                                name="departmentFilter"
                                value={leaderboardDepartmentFilter}
                                onChange={(e) => setLeaderboardDepartmentFilter(e.target.value)}
                                options={[{ id: 'all', name: 'Overall Company' }, ...departments]}
                            />
                        </div>
                    </div>
                    <PerformanceLeaderboard
                        employees={leaderboardDepartmentFilter === 'all' ? performanceData.employeePerformanceMetrics : performanceData.employeePerformanceMetrics.filter(e => e.departmentId === leaderboardDepartmentFilter)}
                        activeSortKey={leaderboardSortKey}
                        setActiveSortKey={setLeaderboardSortKey}
                    />
                </div>

                <div className="bg-gray-800 rounded-lg border border-gray-700 overflow-hidden">
                    <h3 className="text-lg font-bold text-white p-4 border-b border-gray-700">Detailed Employee Data</h3>
                    <div className="overflow-x-auto">
                        <table className="w-full text-left text-sm">
                            <thead className="border-b border-gray-600 bg-gray-900/50">
                                <tr>
                                    <th className="p-3 font-semibold text-gray-400 cursor-pointer flex items-center" onClick={() => requestSort('ops')}>
                                        <Star size={14} className="mr-2 text-yellow-400"/> OPS {getSortIndicator('ops')}
                                    </th>
                                    <th className="p-3 font-semibold text-gray-400 cursor-pointer" onClick={() => requestSort('name')}>Employee {getSortIndicator('name')}</th>
                                    <th className="p-3 font-semibold text-gray-400 text-right cursor-pointer" onClick={() => requestSort('avgEfficiency')}>Efficiency {getSortIndicator('avgEfficiency')}</th>
                                    <th className="p-3 font-semibold text-gray-400 text-right cursor-pointer" onClick={() => requestSort('netValueAdded')}>Net Value {getSortIndicator('netValueAdded')}</th>
                                    <th className="p-3 font-semibold text-gray-400 text-right cursor-pointer" onClick={() => requestSort('reworkRate')}>Rework % {getSortIndicator('reworkRate')}</th>
                                    <th className="p-3 font-semibold text-gray-400 text-right cursor-pointer" onClick={() => requestSort('jobsCompleted')}>Jobs {getSortIndicator('jobsCompleted')}</th>
                                </tr>
                            </thead>
                            <tbody>
                                {loading ? (
                                    <tr><td colSpan="6" className="text-center p-8 text-gray-400">Loading...</td></tr>
                                ) : sortedMetrics.map(emp => (
                                    <tr key={emp.id} className="border-b border-gray-700 hover:bg-gray-700/50">
                                        <td className="p-3 text-white font-bold text-center">
                                            <div className="flex items-center justify-center bg-purple-500/20 text-purple-300 rounded-full w-12 h-12 mx-auto">
                                                {emp.ops.toFixed(1)}
                                            </div>
                                        </td>
                                        <td className="p-3 text-gray-200">
                                            <Link to={`/employee/${emp.id}`} className="text-blue-400 hover:underline">{emp.name}</Link>
                                        </td>
                                        <td className="p-3 text-right font-semibold">{`${Math.round(emp.avgEfficiency)}%`}</td>
                                        <td className="p-3 text-right font-mono">R {emp.netValueAdded.toFixed(2)}</td>
                                        <td className="p-3 text-right">{emp.reworkRate.toFixed(1)}%</td>
                                        <td className="p-3 text-right">{emp.jobsCompleted}</td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </MainLayout>
    );
};

export default PerformancePage;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\pages\ProductViabilityPage.jsx
==================================================
// src/pages/ProductViabilityPage.jsx (New File)

import React, { useState, useEffect, useMemo } from 'react';
import MainLayout from '../components/layout/MainLayout';
import { getProducts, getLinkedRecipesForProduct, getJobStepDetails, getAllInventoryItems, getEmployees, getOverheadCategories, getOverheadExpenses } from '../api/firestore';
import Dropdown from '../components/ui/Dropdown';
import Input from '../components/ui/Input';
import { DollarSign, Percent, Plus, Minus } from 'lucide-react';

const KpiCard = ({ icon, title, value, color }) => (
    <div className="bg-gray-800 p-6 rounded-xl border border-gray-700">
        <div className="flex items-start space-x-4">
            <div className={`p-3 rounded-full ${color}`}>
                {icon}
            </div>
            <div>
                <p className="text-gray-400 text-sm">{title}</p>
                <p className="text-3xl font-bold text-white">{value}</p>
            </div>
        </div>
    </div>
);

const ProductViabilityPage = () => {
    const [products, setProducts] = useState([]);
    const [allRecipes, setAllRecipes] = useState([]);
    const [inventoryItems, setInventoryItems] = useState([]);
    const [averageBurdenedRate, setAverageBurdenedRate] = useState(0);
    const [selectedProductId, setSelectedProductId] = useState('');
    const [linkedRecipes, setLinkedRecipes] = useState([]);
    const [sellingPrice, setSellingPrice] = useState('');
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const fetchData = async () => {
            setLoading(true);
            try {
                const [prods, recipes, inventory, employees, overheadCats] = await Promise.all([
                    getProducts(),
                    getJobStepDetails(),
                    getAllInventoryItems(),
                    getEmployees(),
                    getOverheadCategories()
                ]);

                setProducts(prods);
                setAllRecipes(recipes);
                setInventoryItems(inventory);

                // Calculate Average Burdened Rate
                const expensePromises = overheadCats.map(cat => getOverheadExpenses(cat.id));
                const expenseResults = await Promise.all(expensePromises);
                const totalMonthlyOverheads = expenseResults.flat().reduce((sum, exp) => sum + (exp.amount || 0), 0);
                const totalCompanyProductiveHours = (employees.length || 1) * 45 * 4.33;
                const overheadCostPerHour = totalCompanyProductiveHours > 0 ? totalMonthlyOverheads / totalCompanyProductiveHours : 0;
                const totalHourlyRate = employees.reduce((sum, emp) => sum + (emp.hourlyRate || 0), 0);
                const avgDirectRate = employees.length > 0 ? totalHourlyRate / employees.length : 0;
                setAverageBurdenedRate(avgDirectRate + overheadCostPerHour);

            } catch (error) {
                console.error("Failed to load viability data:", error);
            }
            setLoading(false);
        };
        fetchData();
    }, []);

    useEffect(() => {
        if (selectedProductId) {
            const product = products.find(p => p.id === selectedProductId);
            if (product) {
                setSellingPrice(product.sellingPrice || '');
            }
            const fetchLinks = async () => {
                const links = await getLinkedRecipesForProduct(selectedProductId);
                setLinkedRecipes(links);
            };
            fetchLinks();
        } else {
            setLinkedRecipes([]);
        }
    }, [selectedProductId, products]);

    const analysis = useMemo(() => {
        const inventoryMap = new Map(inventoryItems.map(item => [item.id, item]));
        let totalMaterialCost = 0;
        let totalLaborCost = 0;
        const detailedCosts = [];

        linkedRecipes.forEach(link => {
            const recipe = allRecipes.find(r => r.id === link.jobStepDetailId);
            if (recipe) {
                const recipeMaterialCost = (recipe.consumables || []).reduce((sum, consumable) => {
                    const inventoryItem = inventoryMap.get(consumable.itemId);
                    const price = inventoryItem?.price || 0;
                    return sum + (price * consumable.quantity);
                }, 0);

                const recipeLaborCost = (recipe.estimatedTime || 0) / 60 * averageBurdenedRate;
                
                totalMaterialCost += recipeMaterialCost;
                totalLaborCost += recipeLaborCost;

                detailedCosts.push({
                    id: link.id,
                    partName: link.partName,
                    departmentName: link.departmentName,
                    cost: recipeMaterialCost + recipeLaborCost
                });
            }
        });
        
        const totalCost = totalMaterialCost + totalLaborCost;
        const price = parseFloat(sellingPrice) || 0;
        const profit = price > 0 ? price - totalCost : 0;
        const margin = price > 0 ? (profit / price) * 100 : 0;

        return { totalCost, profit, margin, detailedCosts };

    }, [linkedRecipes, allRecipes, sellingPrice, inventoryItems, averageBurdenedRate]);


    if (loading) return <MainLayout><p className="text-center text-gray-400">Loading Profitability Engine...</p></MainLayout>;

    return (
        <MainLayout>
            <div className="space-y-8">
                <h2 className="text-3xl font-bold text-white">Product Profitability Dashboard</h2>

                <div className="bg-gray-800 p-6 rounded-xl border border-gray-700">
                    <Dropdown
                        label="Select a Product to Analyze"
                        value={selectedProductId}
                        onChange={(e) => setSelectedProductId(e.target.value)}
                        options={products}
                        placeholder="Choose a product..."
                    />
                </div>
                
                {selectedProductId && (
                    <div className="space-y-8 animate-fade-in">
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
                            <KpiCard icon={<DollarSign size={24}/>} title="True Manufacturing Cost" value={`R ${analysis.totalCost.toFixed(2)}`} color="bg-orange-500/20 text-orange-400" />
                            <div className="md:col-span-1">
                                <Input label="Enter Selling Price" type="number" value={sellingPrice} onChange={e => setSellingPrice(e.target.value)} placeholder="e.g., 50000" />
                            </div>
                            <KpiCard icon={<Plus size={24}/>} title="Net Profit" value={`R ${analysis.profit.toFixed(2)}`} color={analysis.profit >= 0 ? "bg-green-500/20 text-green-400" : "bg-red-500/20 text-red-400"} />
                            <KpiCard icon={<Percent size={24}/>} title="Profit Margin" value={`${analysis.margin.toFixed(1)}%`} color={analysis.margin >= 0 ? "bg-green-500/20 text-green-400" : "bg-red-500/20 text-red-400"} />
                        </div>

                        <div className="bg-gray-800 p-6 rounded-xl border border-gray-700">
                             <h3 className="text-xl font-bold text-white mb-4">Cost Breakdown</h3>
                             <div className="space-y-3">
                                {analysis.detailedCosts.length > 0 ? (
                                    analysis.detailedCosts.map(item => (
                                        <div key={item.id} className="flex justify-between items-center bg-gray-700/50 p-3 rounded-lg">
                                            <div>
                                                <p className="font-semibold text-gray-200">{item.partName}</p>
                                                <p className="text-xs text-gray-400">{item.departmentName} Department</p>
                                            </div>
                                            <p className="font-mono text-lg text-gray-300">R {item.cost.toFixed(2)}</p>
                                        </div>
                                    ))
                                ) : (
                                    <p className="text-gray-400 text-center py-4">No linked recipes found for this product. Go to Settings to link recipes.</p>
                                )}
                             </div>
                        </div>
                    </div>
                )}
            </div>
        </MainLayout>
    );
};

export default ProductViabilityPage;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\pages\QcPage.jsx
==================================================
import React from 'react';
import MainLayout from '../components/layout/MainLayout';
import QcQueue from '../components/features/qc/QcQueue';

const QcPage = () => {
  return (
    <MainLayout>
      <div className="space-y-8">
        <h2 className="text-3xl font-bold text-white">Quality Control Queue</h2>
        <QcQueue />
      </div>
    </MainLayout>
  );
};

export default QcPage;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\pages\ScannerPage.jsx
==================================================
import React from 'react';
import MainLayout from '../components/layout/MainLayout';
import Scanner from '../components/features/scanner/Scanner';

const ScannerPage = () => {
  return (
    <MainLayout>
       <div className="space-y-8">
        <h2 className="text-3xl font-bold text-white">Workshop Scanner</h2>
        <Scanner />
      </div>
    </MainLayout>
  );
};

export default ScannerPage;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\pages\SettingsPage.jsx
==================================================
import React, { useState, useMemo } from 'react';
import MainLayout from '../components/layout/MainLayout';
import DepartmentsManager from '../components/features/settings/DepartmentsManager';
import ToolsManager from '../components/features/settings/ToolsManager';
import EmployeesManager from '../components/features/settings/EmployeesManager';
import SuppliersManager from '../components/features/settings/SuppliersManager';
import InventoryManager from '../components/features/settings/InventoryManager';
import ToolAccessoriesManager from '../components/features/settings/ToolAccessoriesManager';
import OverheadsManager from '../components/features/settings/OverheadsManager'; 
import SkillsManager from '../components/features/settings/SkillsManager';
// REMOVE old managers and IMPORT the new one
import UnifiedProductManager from '../components/features/settings/UnifiedProductManager';

const TabButton = ({ label, isActive, onClick, isDanger = false }) => {
  const baseClasses = "px-4 py-2 text-sm font-medium rounded-md focus:outline-none transition-colors";
  const activeClasses = isDanger ? "bg-red-600 text-white" : "bg-blue-600 text-white";
  const inactiveClasses = isDanger ? "bg-gray-800 text-red-400 hover:bg-red-500/20" : "bg-gray-800 text-gray-300 hover:bg-gray-700";

  return (
    <button onClick={onClick} className={`${baseClasses} ${isActive ? activeClasses : inactiveClasses}`}>
      {label}
    </button>
  );
};

const SettingsPage = () => {
  const [activeTab, setActiveTab] = useState('products');

  const tabs = useMemo(() => ({
    products: {
      label: 'Products & Recipes',
      // REPLACE the old components with our single new one
      components: [<UnifiedProductManager key="unified-product-manager" />]
    },
    inventory: {
      label: 'Inventory & Suppliers',
      components: [<InventoryManager key="inventory" />, <SuppliersManager key="suppliers" />]
    },
    assets: {
      label: 'Tools & Assets',
      components: [<ToolsManager key="tools" />, <ToolAccessoriesManager key="tool-accessories" />]
    },
    company: {
      label: 'Company & Staff',
      components: [<DepartmentsManager key="departments" />, <EmployeesManager key="employees" />, <SkillsManager key="skills" />]
    },
    financials: {
      label: 'Financials',
      components: [<OverheadsManager key="overheads" />]
    }
  }), []); 

  return (
    <MainLayout>
      <div className="space-y-8">
        <h2 className="text-3xl font-bold text-white">Settings & Data Management</h2>

        <div className="flex flex-wrap items-center gap-2 p-2 bg-gray-900/50 rounded-lg">
          {Object.entries(tabs).map(([tabKey, tabData]) => (
            <TabButton
              key={tabKey}
              label={tabData.label}
              isActive={activeTab === tabKey}
              onClick={() => setActiveTab(tabKey)}
              isDanger={tabData.isDanger}
            />
          ))}
        </div>

        <div className="space-y-8">
          {tabs[activeTab].components}
        </div>
      </div>
    </MainLayout>
  );
};

export default SettingsPage;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\pages\StockControlPage.jsx
==================================================
import React, { useState, useEffect, useMemo } from 'react';
import MainLayout from '../components/layout/MainLayout';
import StockControlDashboard from '../components/features/stock/StockControlDashboard';
import PurchaseQueue from '../components/features/stock/PurchaseQueue';
import InTransitOrders from '../components/features/stock/InTransitOrders';
import { getPurchaseQueue, getSuppliers } from '../api/firestore';

const StockControlPage = () => {
  const [activeTab, setActiveTab] = useState('dashboard');
  const [purchaseQueueItems, setPurchaseQueueItems] = useState([]);
  const [suppliers, setSuppliers] = useState([]);
  const [loading, setLoading] = useState(true);

  const fetchData = () => {
    setLoading(true);
    Promise.all([getPurchaseQueue(), getSuppliers()]).then(([queue, supplierList]) => {
      setPurchaseQueueItems(queue);
      setSuppliers(supplierList);
      setLoading(false);
    });
  };

  useEffect(() => {
    fetchData();
  }, []);

  const TabButton = ({ id, label, count }) => {
    const isActive = activeTab === id;
    return (
      <button
        onClick={() => setActiveTab(id)}
        className={`px-5 py-2 text-sm font-semibold rounded-t-lg border-b-2 flex items-center gap-2 transition-colors ${
          isActive ? 'border-blue-500 text-white' : 'border-transparent text-gray-400 hover:border-gray-500 hover:text-gray-200'
        }`}
      >
        {label}
        {count > 0 && <span className={`text-xs rounded-full px-2 py-0.5 ${isActive ? 'bg-white text-blue-600' : 'bg-gray-600 text-gray-200'}`}>{count}</span>}
      </button>
    );
  };

  const { pendingItems, orderedItems } = useMemo(() => {
    return {
        pendingItems: (purchaseQueueItems || []).filter(i => i.status === 'pending'),
        orderedItems: (purchaseQueueItems || []).filter(i => i.status === 'ordered')
    }
  }, [purchaseQueueItems]);

  return (
    <MainLayout>
      <div className="space-y-4">
        <h2 className="text-3xl font-bold text-white">Stock Control & Purchasing</h2>
        <div className="border-b border-gray-700">
            <nav className="-mb-px flex space-x-6">
                <TabButton id="dashboard" label="Stock Overview" />
                <TabButton id="queue" label="Purchase Queue" count={pendingItems.length} />
                <TabButton id="transit" label="In-Transit Orders" count={orderedItems.length} />
            </nav>
        </div>
        <div className="mt-6">
            {loading ? <p className="text-center text-gray-400">Loading...</p> : (
                <>
                    {activeTab === 'dashboard' && <StockControlDashboard />}
                    {activeTab === 'queue' && <PurchaseQueue onOrderPlaced={fetchData} />}
                    {activeTab === 'transit' && <InTransitOrders items={orderedItems} suppliers={suppliers} onStockReceived={fetchData} />}
                </>
            )}
        </div>
      </div>
    </MainLayout>
  );
};

export default StockControlPage;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\pages\TrackingPage.jsx
==================================================
import React from 'react';
import MainLayout from '../components/layout/MainLayout';
import LiveJobTracking from '../components/features/tracking/LiveTrackingTable';

const TrackingPage = () => {
  return (
    <MainLayout>
      <div className="space-y-8">
        <h2 className="text-3xl font-bold text-white">Live Job Tracking</h2>
        <LiveJobTracking />
      </div>
    </MainLayout>
  );
};

export default TrackingPage;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\utils\jobUtils.js
==================================================
// src/utils/jobUtils.js

import { CATALYST_RULES } from '../config';

/**
 * Processes raw recipe consumables into a display-friendly format, calculating catalyst additions.
 * This centralized function ensures consistent consumable processing across the app.
 * @param {Array} consumablesFromRecipe - The raw consumables array from a job or recipe.
 * @param {Array} allInventoryItems - The master list of all inventory items.
 * @param {number} temperature - The current temperature for catalyst calculation.
 * @returns {Array} A list of processed consumables ready for display or costing.
 */
export const processConsumables = (consumablesFromRecipe, allInventoryItems, temperature) => {
    if (!consumablesFromRecipe || !Array.isArray(consumablesFromRecipe)) return [];

    const processedList = [];
    const catalystItem = allInventoryItems.find(c => c.name.toLowerCase().includes('catalyst') || c.name.toLowerCase().includes('hardener'));

    for (const consumable of consumablesFromRecipe) {
        // Find the full details from the master inventory list using either itemId (from recipe) or id (from inventory)
        const masterItem = allInventoryItems.find(c => c.id === (consumable.itemId || consumable.id));
        const itemDetails = masterItem || consumable;
        if (!itemDetails) continue;

        if (consumable.type === 'fixed') {
            processedList.push({ ...itemDetails, quantity: consumable.quantity, notes: '' });
            if (itemDetails.requiresCatalyst && catalystItem && temperature) {
                let percentage = 0;
                for (const rule of CATALYST_RULES) {
                    if (temperature <= rule.temp_max) {
                        percentage = rule.percentage;
                        break;
                    }
                }
                if (percentage > 0) {
                    const calculatedQty = consumable.quantity * (percentage / 100);
                    processedList.push({ ...catalystItem, quantity: calculatedQty, notes: `(Auto-added at ${percentage}% for ${temperature}Â°C)` });
                }
            }
        } else if (consumable.type === 'dimensional') {
            processedList.push({ ...itemDetails, cuts: consumable.cuts, notes: `See ${consumable.cuts.length} cutting instruction(s)` });
        } else if (!consumable.type && consumable.quantity) {
            processedList.push({ ...itemDetails, notes: '' });
        }
    }
    return processedList;
};


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\App.css
==================================================
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}



==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\App.jsx
==================================================
import React from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { useAuth } from './contexts/AuthContext';

// Layouts & Guards
import ProtectedRoute from './components/layout/ProtectedRoute';
import RoleBasedRoute from './components/layout/RoleBasedRoute';

// Pages
import LoginPage from './pages/Login';
import DashboardPage from './pages/DashboardPage';
import StockControlPage from './pages/StockControlPage';
import JobCreatorPage from './pages/JobCreatorPage';
import LiveTrackingPage from './pages/LiveTrackingPage';
import ScannerPage from './pages/ScannerPage';
import QcPage from './pages/QcPage';
import IssuesPage from './pages/IssuesPage';
import PerformancePage from './pages/PerformancePage';
import EmployeeIntelligencePage from './pages/EmployeeIntelligencePage';
import ProductViabilityPage from './pages/ProductViabilityPage';
import SettingsPage from './pages/SettingsPage';

function App() {
  const { user } = useAuth();

  return (
    <Router>
      <Routes>
        <Route path="/login" element={user ? <Navigate to="/" /> : <LoginPage />} />
        <Route path="/*" element={
            <ProtectedRoute>
              <Routes>
                {/* Routes accessible to ALL logged-in employees */}
                <Route path="/" element={<DashboardPage />} />
                <Route path="/tracking" element={<LiveTrackingPage />} />
                <Route path="/scan" element={<ScannerPage />} />

                {/* --- ROLE PROTECTED ROUTES --- */}

                {/* Routes for Managers and QC Inspectors */}
                <Route path="/qc" element={
                    <RoleBasedRoute roles={['Manager', 'QC Inspector']}>
                        <QcPage />
                    </RoleBasedRoute>
                } />

                {/* Routes for Managers ONLY */}
                <Route path="/stock" element={
                    <RoleBasedRoute roles={['Manager']}>
                        <StockControlPage />
                    </RoleBasedRoute>
                } />
                <Route path="/creator" element={
                    <RoleBasedRoute roles={['Manager']}>
                        <JobCreatorPage />
                    </RoleBasedRoute>
                } />
                <Route path="/issues" element={
                    <RoleBasedRoute roles={['Manager']}>
                        <IssuesPage />
                    </RoleBasedRoute>
                } />
                <Route path="/performance" element={
                    <RoleBasedRoute roles={['Manager']}>
                        <PerformancePage />
                    </RoleBasedRoute>
                } />
                 <Route path="/employee/:employeeId" element={
                    <RoleBasedRoute roles={['Manager']}>
                        <EmployeeIntelligencePage />
                    </RoleBasedRoute>
                } />
                <Route path="/profitability" element={
                    <RoleBasedRoute roles={['Manager']}>
                        <ProductViabilityPage />
                    </RolebasedRoute>
                } />
                <Route path="/settings" element={
                    <RoleBasedRoute roles={['Manager']}>
                        <SettingsPage />
                    </RoleBasedRoute>
                } />

                <Route path="*" element={<Navigate to="/" />} />
              </Routes>
            </ProtectedRoute>
          }
        />
      </Routes>
    </Router>
  );
}

export default App;


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\config.js
==================================================
// src/config.js

/**
 * Defines the rules for calculating the percentage of catalyst needed based on ambient temperature.
 * This central configuration makes it easy to adjust business rules without changing component logic.
 */
export const CATALYST_RULES = [
    { temp_max: 18, percentage: 3.0 },
    { temp_max: 28, percentage: 2.0 },
    { temp_max: 100, percentage: 1.0 }
];


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\index.css
==================================================
@tailwind base;
@tailwind components;
@tailwind utilities;

/* --- ADD THIS RULE AT THE BOTTOM --- */
/* This forces dropdown options to have a dark background and white text */
select option {
  background-color: #374151; /* This is Tailwind's gray-700 */
  color: #ffffff;
}

/* --- ADD THIS NEW RULESET TO FIX NUMBER INPUTS --- */
/* Hide the default spinner buttons on number inputs */
input[type=number]::-webkit-inner-spin-button, 
input[type=number]::-webkit-outer-spin-button { 
  -webkit-appearance: none; 
  margin: 0; 
}
input[type=number] {
  -moz-appearance: textfield; /* For Firefox */
}


==================================================
FILE: C:\Development\TOJEM-OS\tojem-os\src\main.jsx
==================================================
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';
import './index.css';
import { AuthProvider } from './contexts/AuthContext.jsx';
import './api/firebase.js'; // <-- ADD THIS LINE

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <AuthProvider>
      <App />
    </AuthProvider>
  </React.StrictMode>
);
